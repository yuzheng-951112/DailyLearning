数据结构和算法

集合结构:集合结构中过的数据元素除了同属一个集合外，他们之间没有其他不三不四的关系
线性结构:线性结构中的数据元素之间是一对一的关系
树形结构:树形结构中的数据元素之间存在一种一对多的层次关系
图形结构:图形结构的数据元素是多对多的关系

数据元素的存储结构形式有两种:顺序存储和链式存储
顺序存储结构:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
链式存储结构:以附加信息(指针)表示后续关系(需要用一个和x在一起的附加信息指示y的存储位置)

算法具有五个基本特征:输入、输出、有穷性、确定性、可行性

常用的时间复杂度所耗费的时间从小到大依次是:
O(1)<O(logn)<O(n)<O<nlogn>O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)

线性表:由零个或多个数据元素组成的有限序列
数据类型:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称
数据结构的形式定义为:数据结构是个二元数组
	Data_Structures=(D,S)
其中:D是数	据元素的有限集，S是D上关系的有限元

关系的映像方法:(表示<x,y>的方法)
顺序映像:以存储位置的相邻表示后续关系(y的存储位置和x的存储位置之间差一个常量C)
链式映像:以附加信息(指针)表示后续关系(需要用一个和x在一起的附加信息指示y的存储位置)
例如:以三个带有次序关系的整数表示一个长整数是，可以利用c语言中提供的证书数组类型，定义长整数为:
	typedef int long_int[3]

抽象数据类型定义:抽象数据类型是指一个数学模型及定义在该模型上的一组操作
原子类型:不可以再分解的基本类型，例如整型、浮点型、字符型等
结构类型:由若干个类型组成而成，是可以再分解的，例如整型数组是由若干整型数据组成的
抽象数据类型可用(D,S,P)三元组表示
	其中，D是数据对象，
		  S是D上的关系集
		  P是对D的基本操作集
抽象数据类型的表示和实现
	抽象数据类型需要通过固有数据类型(高级编程语言中已经实现的数据类型)来实现

Operation
	InitList(*l):初始化操作，建立一个空的线性表L
	ListEmpty(l):判断线性表是否为空表，若线性表为空，返回true，否则范围false
	ClearList:将线性表清空
	GetElem(l,u,*e):将线性表L中的第i个位置元素值返回给e
	LocateElem(L,e):在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序列号表示成功；否则，返回0表示失败
	ListInsert(*L,i,e):在线性表L中第i个位置插入新元素e
	ListDelete(*l,i,e);删除线性表L中第i个位置的元素，并用e返回其值
	ListLength(l);返回线性表L的元素个数
	
例题:两个线性表A、B的并集操作，即要使得集合A=AUB.
(解释下"AUB":说白了，就是把存在集合B中但不存在集合A中的元素插入到A中即可)



--------------------------------------------------------------------------------------------------------------------------------
数据结构概念
	定义:
		我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器(内存)中，以及在此基础上为实现某个功能(比
		如查找某个元素，删除某个元素，对所有元素进行排序)，而执行的相应操作，这个相应的操作叫做算法
		
		数据结构 = 个体 + 个体的关系
		算法 = 对存储数据的操作
	
	算法
		解题的方法和步骤
		
		衡量算法的标准
			1 时间复杂度
				大概程序要执行的次数，而非执行的时间
			2 空间复杂度
				算法执行过程中大概所占用的内存
			3 难以程度
			4 健壮性
			
软件运行与内存(垃圾数据)
	内存实在操作系统的统一管理下使用的！
	1 软件在运行前需要向操作系统申请储存空间，在内存空闲空间足够时，操作系统将分配一段内存空间并将外村软件拷贝一份存入该内存空
	  间中，并开启该软件的运行
	2 在软件运行期间，该软件所占内存空间不再分配给其他软件
	3 当软件运行完毕后，操作系统将回收该内存空间(注意:操作系统并不完全清空内存空间中遗留下来的额数据)，以便再次分配给其他软件使用
	
指针复习:
	一个简单的数组和指针的程序:
		#include <stdio.h>

		void main()
		{
			int a[5]={1,2,3,4,5};

			printf("%d\n%d\n%d",a,a+1,*a+4);	//a，a+1分别带表其地址(等同于(a+1)*字形类型)，*a+4=5等价于 a[0]+4=5
		}


数组例题:
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

struct arr
{
	int len ;		//最大数组长度
	int cnt ;		//实际数组长度
	int *pbase;		//数组首地址
};

void insert_arr(struct arr *parr,int pos,int num);
bool delete_arr();
int get();
bool is_empty(struct arr *parr);
bool is_full(struct arr *parr,int i);
void init_array(struct arr *parr,int length);
void append_arr(struct arr *parr,int i,int val);
void show_arr(struct arr *parr);
void sort_arr();
void inversion_arr();


void main()
{
	int max_len , actual_len;
	int arr_val;
	int arr_i;
	int i;
	int position_arr,insert_number;
	struct arr array;

	printf("请输入数组的最大长度: max_len =");
	scanf("%d",&max_len);
	init_array(&array,max_len);		//建立一个数组的空间

	printf("请输入数组的实际长度: actual_len =");
	scanf("%d",&actual_len);
	for(arr_i=0;arr_i<actual_len;arr_i++)
	{
		printf("请输入第%d个元素: val =",arr_i+1);
		scanf("%d",&arr_val);
		append_arr(&array,arr_i,arr_val);		//添加数组中的元素
	}

	show_arr(&array);


	printf("\n1.插入 2.删除 3.选取 4.排序 5.倒序");
	printf("请选择更多的功能! 功能号 = ");
	scanf("%d",&i);

	switch(i)
	{
	case 1:
		{
			printf("请输入想插入的位置 position = ");
			scanf("%d",&position_arr);
			printf("请输入想插入的数字 number = ");
			scanf("%d",&insert_number);
			insert_arr(&array,position_arr,insert_number);
			show_arr(&array);
			break;
		}
//	case 2:bool delete_arr();break;
//	case 3:bool get();break;
//	case 4:bool sort_arr();break;
//	case 5:bool inversion_arr();break;
	}

}

void init_array(struct arr *parr,int length)
{
	(*parr).pbase = (int *)malloc(sizeof(int)*length);			//这里分配的是数组的类型长度为int型
	if(NULL == parr)
	{
		printf("数组分配失败!\n");
		exit(-1);
	}
	else
	{
		(*parr).len = length;
		(*parr).cnt = 0 ;
	}
	return;
}

void append_arr(struct arr *parr,int i,int val)
{
	if( is_full(parr,parr->cnt))
	{
		printf("数组分配完成!\n");
		exit(-1);
	}
	else
	{
		parr->pbase[i] = val;
		(parr->cnt)++;
	}
}


void show_arr(struct arr *parr)
{
	if(is_empty(parr))
	{
		printf("数组为空!\n");
		exit(-1);
	}
	else
	{
		for(int j=0;j<parr->cnt;j++)
		{
			printf("%d ",parr->pbase[j]);
		}
	}

}

void insert_arr(struct arr *parr,int pos,int num)
{
	if(pos>parr->len||pos<1)
	{
		printf("输入位置不在范围内!\n");
		exit(-1);
	}
	else
	{
		(parr->cnt)++;
		for(int i=parr->cnt;i>=pos-1;i--)
		{
			parr->pbase[i+1] = parr->pbase[i];
		}
		parr->pbase[pos-1] = num;
	}
}


bool is_full(struct arr *parr,int i)
{
	if(i == parr->len)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool is_empty(struct arr *parr)
{
	if(0 == parr->cnt)
	{
		return true;
	}
	else
	{
		return false;
	}
}

typedef用法:
#include <stdio.h>

typedef int daidai;		//为int再重新多取一个名字，daidai等价于int

typedef struct student
{
	int age;
	double score;
	char sex;
}ST;

void main()
{
	daidai i=10;		//等价于 int i=10;
	printf("%d\n",i);
	
ST st={10,66.6,'f'};	//等价于 ST st={10,66.6,'f'};
	printf("%d,%lf,%c",st.age,st.score,st.sex);
}
/*
	# include <stdio.h>
	
	typedef struct student
	{
		int age;
		double score;
		char sex;
	}* PST;
	
	void main()
	{
		struct student st;
		PST ps = &st;
		ps->age = 99;
		printf("%d\n",ps->age);
	}
*/

链表分类:
	单链表:
	双链表:
		每一个节点有两个指针域
	循环链表:
		能通过任何一个节点
	非循环链表
	
算法:
	遍历
	查找
	清空
	销毁
	求长度
	排序
	删除节点
	插入节点
	
	算法:
		狭义的算法是与数据存储方式密切相关
		广义的算法是与数据的存储方式无关
		泛型:
			利用某种技术达到的效果就是:不同的存储方式，执行的操作是一样的
	
链表的优缺点:

链表实例:
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	int data;
	struct Node *pNext;
}Node,*pNode;

struct Node *build_lianbiao(int len);//创建一个非循环单链表
void traverse_lianbiao(struct Node* pHead);
void insert_list(struct Node* pHead,int pos,int val,int len);
void delete_list(struct Node* pHead,int pos,int len);
void sort_list(struct Node* pHead,int len);
bool is_empty(struct Node* pHead);
int hello(struct Node* pHead);

void main()
{
	int length;
	int insert_position,insert_val;
	int delete_position;
	int function_number;
	int get_length;
	pNode pHead = NULL;
	
	printf("请输入你需要生成链表节点个数:len =");
	scanf("%d",&length);
	pHead = build_lianbiao(length);

	traverse_lianbiao(pHead);
	
	printf("\n选择更多功能!\n");
	printf("1.插入 2.删除 3.排序 4.取出	选取功能 = ");
	scanf("%d",&function_number);

	switch(function_number)
	{
	case 1:
		{
			printf("输入要插入的位置 pos = ");
			scanf("%d",&insert_position);
			printf("输入要插入的数字 val = ");
			scanf("%d",&insert_val);
			insert_list(pHead,insert_position,insert_val,length);
			traverse_lianbiao(pHead);
		}
	case 2:
		{
			printf("请输入要删除的位置 pos = ");
			scanf("%d",&delete_position);
			delete_list(pHead,delete_position,length);
			traverse_lianbiao(pHead);
		}
	case 3:
		{
			sort_list(pHead,length);
			traverse_lianbiao(pHead);
		}
	case 4:
		{
			get_length=hello(pHead);
			printf("%d",get_length);
		}
	}
}

struct Node *build_lianbiao(int len)
{
	int val;
	
	pNode pHead = (struct Node*)malloc(sizeof(struct Node));
	if(NULL == pHead)
	{
		printf("分配失败，程序终止!\n");
		exit(-1);
	}

	pNode pTail = pHead;		//定义一个pTail做中转
	pTail->pNext = NULL;
	
	for(int i=0;i<len;i++)
	{
		printf("请输入第%d个节点的值 val = ",i+1);
		scanf("%d",&val);

		pNode pNew = (struct Node*)malloc(sizeof(struct Node));
		if(NULL == pHead)
		{
			printf("分配失败，程序终止!\n");
			exit(-1);
		}
		pNew->data = val;
		pTail->pNext = pNew;
		pNew->pNext = NULL;
		pTail = pNew;
	}

	return pHead;
}


void traverse_lianbiao(struct Node *pHead)
{
	struct Node * p = pHead->pNext;

	while(NULL != p)
	{
		printf("%d ",p->data);
		p = p->pNext;
	}
}

void insert_list(struct Node* pHead,int pos,int val,int len)
{
	if(is_empty(pHead))
	{
		printf("链表为空，插入失败!\n");
		exit(-1);
	}
	else if(pos<1||pos>len)
	{
		printf("超出范围，插入失败!\n");
		exit(-1);
	}
	else
	{
		pNode pNew = (struct Node*)malloc(sizeof(struct Node));

		for(int i=1;i<pos;i++)
		{
			pHead = pHead->pNext;
		}
		pNew->pNext = pHead->pNext;
		pHead->pNext = pNew;
		pNew->data = val;
	}
}

void delete_list(struct Node* pHead,int pos,int len)
{
	if(is_empty(pHead))
	{
		printf("链表为空，插入失败!\n");
		exit(-1);
	}
	else if(pos<1||pos>len)
	{
		printf("超出范围，删除失败!\n");
		exit(-1);
	}
	else
	{
		for(int i=1;i<pos;i++)
		{
			pHead = pHead->pNext;
		}
		pNode r = pHead->pNext;
		pHead->pNext = pHead->pNext->pNext;
		free(r);
	}
}

void sort_list(struct Node* pHead,int len)
{
	if(is_empty(pHead))
	{
		printf("链表为空，插入失败!\n");
		exit(-1);
	}
	else
	{
		int r;
		for(int i=0;i<len-1;i++)
		{
			pNode p = pHead->pNext;
			for(int j=0;j<len-i-1;j++)
			{
				if(p->data>p->pNext->data)
				{
					r = p->data;
					p->data = p->pNext->data;
					p->pNext->data = r;
				}
				p = p->pNext;
			}
		}
	}
}

int hello(struct Node* pHead)
{
	struct Node * p = pHead->pNext;
	int i=0;

	while(NULL != p)
	{
		i++;
		p = p->pNext;
	}
	return i;
}

bool is_empty(struct Node* pHead)
{
	if(NULL == pHead->pNext)
	{
		return true;
	}
	else
	{
		return false;
	}

	
栈的模拟
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	int data;
	struct Node *pNext;
}Node,*pNode;

typedef struct stack
{
	pNode top;
	pNode bottom;
}Stack,*pStack;

void init_stack(pStack ST);
void push_stack(pStack ST,int val);
void pop_stack(pStack ST,int num);
void traverse_stack(pStack ST,int num);
void clear_stack(pStack ST);			
bool is_empty(pStack ST);

void main()
{
	Stack ST;

	init_stack(&ST);
	
	int push_number;
	printf("请输入入栈个数 num = ");
	scanf("%d",&push_number);
	
	push_stack(&ST,push_number);

	int pop_number;
	printf("请输入出栈个数 num = ");
	scanf("%d",&pop_number);
	pop_stack(&ST,pop_number);

	traverse_stack(&ST,push_number-pop_number);
}

void init_stack(pStack ST)
{
	pNode pStack_head = (pNode)malloc(sizeof(Node));

	ST->top = pStack_head;
	ST->bottom = pStack_head;

	if(NULL == ST->top)
	{
		printf("动态内存分配失败!\n");
		exit(-1);
	}
	else
	{
		pStack_head->pNext = NULL;
	}
}

/*
void push_stack(pStack ST,int push_number)
{
	pNode P = ST->bottom;
	int val;

	for(int i=0;i<push_number;i++)
	{
		printf("压入栈中的值为 val = ");
		scanf("%d",&val);
		pNode pStack_new = (pNode)malloc(sizeof(Node));
		ST->top = pStack_new;
		P->pNext = pStack_new;
		pStack_new->data = val;
		pStack_new->pNext = NULL;
		P = P->pNext;
	}
}

  
void traverse_stack(pStack ST,int num)
{
	pNode P = ST->bottom->pNext;
	for(int i=0;i<num;i++)
	{
		printf("%d ",P->data);
		P = P->pNext;
	}
}
自己写的顺序是以bottom为基础到top 出栈的时候代码量大
*/

void push_stack(pStack ST,int push_number)
{
	pNode P = ST->bottom;
	int val;

	for(int i=0;i<push_number;i++)
	{
		printf("压入栈中的值为 val = ");
		scanf("%d",&val);
		pNode pStack_new = (pNode)malloc(sizeof(Node));
		pStack_new->data = val;
		pStack_new->pNext = ST->top;
		ST->top = pStack_new;
	}
}


void traverse_stack(pStack ST,int num)
{
	pNode P = ST->top;
	for(int i=0;i<num;i++)
	{
		printf("%d ",P->data);
		P = P->pNext;
	}
}

void pop_stack(pStack ST,int num)
{
	if(is_empty(ST))
	{
		printf("出栈失败，栈为空!\n");
		exit(-1);
	}
	else
	{
		for(int i=0;i<num;i++)
		{
			printf("出栈的数字为%d\n",ST->top->data);
			pNode q = ST->top;
			ST->top = q->pNext;
			free(q);
		}
	}
}

void clear_stack(pStack ST)
{

}

bool is_empty(pStack ST)
{
	if(ST->top == ST->bottom)
	{
		return true;
	}
	else
	{
		return false;
	}
}

队列
	定义:
		一种可以实现"先进先出"的存储结构
	分类:
		链式队列 -- 用链表实现
		
		静态队列 -- 用数组实现
			1.静态队列通常必须是循环队列
			2.循环队列需要几个参数来确定
				需要两个参数来确定
					front
					rear
				两个参数不同场合有不同的含义
				1 列队初始化
					front和rear的值都是零
				2 列队非空
					front代表的是队列的第一个元素
					rear代表的是队列的最厚一个有效元素的后一个元素
				3 队列空
					front和rear的值相等，但不一定是零
			3.循环队列各个参数的含义
			4.循环队列入队伪算法讲解
			两步完成:
				1 将值存入R所代表的位置
				2 正确的写法是:r = （r+1）%数组的长度
			5.循环队列出队伪算法讲解
				1 将值存入R所代表的位置
				2 正确的写法是:f = （f+1）%数组的长度
			6.如何判断循环队列是否为空
				如果front与rear的值相等
				则该队列就一定为空
			7.如何判断循环队列是否已满
			两种方式:
				1 多增加一个表标参数
				2 少用一个元素
				（r+1）%数组的长度=f
				
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Queue
{
	int *qBase;
	int front;
	int rear;
}Queue,*qQueue;

void init_Queue(qQueue qQ,int len);
void en_Queue(qQueue qQ,int en_length,int len);
bool is_full(qQueue qQ,int len);
bool is_empty(qQueue qQ);
void traverse_Queue(qQueue qQ,int len);
void out_Queue(qQueue qQ,int out_len,int len);

void main()
{
	Queue Q;
	int length,en_length,out_length;
	printf("请输入队列的长度 len = ");
	scanf("%d",&length);
	init_Queue(&Q,length);
	
	printf("请输入入队的长度 en_len = ");
	scanf("%d",&en_length);
	
	while(1)
	{
		if(en_length<6&&en_length>0)
		{
			break;
		}
		else
		{
			printf("请重新输入入队的长度 en_len = ");
			scanf("%d",&en_length);
		}
	}
	
	en_Queue(&Q,en_length,length);

	printf("请输入出队的长度 out_len = ");
	scanf("%d",&out_length);
	out_Queue(&Q,out_length,length);

	traverse_Queue(&Q,length);
	
}

void init_Queue(qQueue qQ,int len)
{
	qQ->qBase = (int *)malloc(sizeof(int)*len);
	qQ->front = 0;
	qQ->rear = 0;
}

void en_Queue(qQueue qQ,int en_len,int len)
{
	int val;
	for(int i=0;i<en_len;i++)
	{
		printf("请输入插入队列的值 val = ");
		scanf("%d",&val);
		if(is_full(qQ,len))
		{
			printf("队列已满，入队失败!");
			break;
		}
		else
		{
				qQ->qBase[qQ->rear] = val;
				qQ->rear = (qQ->rear+1)%len;		//r = （r+1）%数组的长度
		}
	}
}

void traverse_Queue(qQueue qQ,int len)
{
	if(is_empty(qQ))
	{
		printf("列队为空!\n");
		exit(-1);
	}
	else
	{
		int r = qQ->front;
		while(r != qQ->rear)
		{
			printf("%d ",qQ->qBase[r]);
			r = (r+1)%len;
		}
	}
}

void out_Queue(qQueue qQ,int out_len,int len)
{
	for(int i=0;i<out_len;i++)
	{
		if(is_empty(qQ))
		{
			printf("队列为空!\n");
			break;
		}
		else
		{
			printf("出队的数字为%d\n",qQ->qBase[qQ->front]);
			qQ->front = (qQ->front+1)%len; //f = （f+1）%数组的长度
		}
	}
}

bool is_full(qQueue qQ,int len)
{
	if(qQ->front == (qQ->rear+1)%len)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool is_empty(qQueue qQ)
{
	if(qQ->front == qQ->rear)
	{
		return true;
	}
	else
	{
		return false;
	}
}

递归:
	定义:一个函数自己或间接的调用自己
	
例题1:递归1~100相加
#include <stdio.h>

int f(int i,int sum)
{
	if(i<101)
	{
		sum = i + sum;
		i++;
		sum=f(i,sum);
	}
		return (sum);
}

void main()
{
	int i = 0,sum=0;

	sum=f(i,sum);
	printf("%d",sum);
}
方法二:逆推简单
#include <stdio.h>

int f(int n)
{
	if(1 == n)
		return 1;
	else
		return f(n-1)+n;
}

void main()
{
	printf("%d\n",f(100));
}

例题2:递归5的阶乘
方法一:顺推复杂
#include <stdio.h>

int f(int i,int sum)
{
	if(i<6)
	{
		sum=i*sum;
		i++;
		sum=f(i,sum);
	}
	return sum;
}

void main()
{
	int i=1,sum=1;

	sum=f(i,sum);
	printf("%d",sum);
}
方法二:逆推简单
#include <stdio.h>

int f(int n)
{
	if(1 == n)
		return 1;
	else
		return f(n-1)*n;
}

void main()
{
	printf("%d\n",f(6));
}

汉罗塔:（重点）hanoi函数中A、B、C三个参数的位置其实是初始位置，中间位置，目标位置
while(n>1)
{
	将n-1个盘子从A通过C移动到B
	将第N个盘子直接从A移动到C
	将n-1个盘子从B通过C移动到A
}
#include <stdio.h>

void hanoi(int n,char one,char two,char three);
void move(char x,char y);

void main()
{
	hanoi(64,'A','B','C');
}

void hanoi(int n,char one,char two,char three)
{
	if(1 == n)
	{
		move(one,three);
	}
	else
	{
		hanoi(n-1,one,two,three);
		move(one,three);
		hanoi(n-1,two,one,three);
		
	}
}

void move(char x,char y)
{
	printf("%c-->%c",x,y);
}

非线性结构
	树
		树定义:
			专业定义:1 有且只有一个称为根的节点
					 2 有若干个互不相交的子树，这些子树本身也是一颗树
			通俗的定义:1 树是由节点和边组成
					   2 每个节点只有一个父节点但可以有很多个子节点
					   3 但又一个节点例外，该节点没有父节点，此节点成为根节点
			专业术语: 节点	父节点	子节点	子孙	堂兄弟
				深度:从根结点到最底层节点的层数称为深度
				叶子节点:没有子节点的节点
				非终端节点:实际就是非叶子节点
				度:子节点的个数称为度
				
			树分类
				一般树:任意一个节点的子节点的个数都不受限制
				二叉树:任意一个节点的子节点的个数最多为两个，且子节点的位置不能更换
					分类:一般二叉树
						 满二叉树:在不增加树的层数的前提下，无法再多添加一个节点的二叉树就是满二叉树
						 完全二叉树:如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树
				森林:n个互不相交的树
			
			树的存储
				二叉树的存储
					连续存储[完全二叉树]
					
					链式存储
				一般树的存储
					双亲表示法:求父节点方便
					孩子表示法:求子节点方便
					双亲孩子表示法:求父节点和子节点都很方便
					二叉树表示法:把一个普通树转化成二叉树来存储
						具体转换方法:1 左指针域指向它的第一个孩子
									 2 右指针域指向它的右兄弟
								一个普通树转化成的二叉树一定没有右子树
				
				森林的存储
					先把森森林转化为二叉树，在存储二叉树
					
			二叉树操作
				遍历
					先序遍历:1 先访问根结点[先访问根结点]
							 2 再先序访问左子树
							 3 再先序访问右子树
					中序遍历:1 中序遍历左子树[中间访问根节点]
							 2 再访问根结点
							 3 再中序遍历右子树
					后序遍历:1 先中序遍历左子树[最后访问根节点]
							 2 在中序遍历右子树
							 3 再访问根节点
					
					已知两种遍历序列求原始二叉树
						通过先序和中序 或者 中序和后序我们可以还原出原始的二叉树
						但是通过先序和后序是无法还原出原始的二叉树
						
						
高一凡 数据结构
1 线性表的顺序表示和实现
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct sqList
{
	int *pBase;		//存储数据的首地址
	int length;		//存储数据的当前长度
	int cnt;		//当前存储空间的分配容量
}sqList,*psqList;

void init_list(struct sqList *L,int max_length);					//初始化线性表
void append_List(struct sqList *L,int actual_length,int max_length);//在线性表中添加元素
void traverse_list(sqList *L);										//显示线性表中的元素
void List_length(sqList *L);										//显示线性表的长度
void get_Listelem(sqList *L,int position);							//输入位置得到线性表对应位置的数值
void locatelem_List(sqList *L,int val);								//输入数值得到线性表对应位置或者不存在对应数值
void prior_List(sqList *L,int val);									//输入位置得到线性表对应位置的前驱
void next_List(sqList *L,int val);									//输入位置得到线性表对应位置的后驱
void insert_List(sqList *L,int insert_position,int val_insert);		//输入位置和数值在线性表中插入
void delete_List(sqList *L,int delete_position,int actual_length);	//输入位置删除线性表对应的数值
void replace_List(sqList *l,int positon_replace,int val_replace);						//替换线性表i位置的元素为val_replace
void clear_List(sqList *L);											//清除线性表中所有的元素
void union_List(sqList *L,sqList *P,int actual_length,int actual_length1);	//合并两线性表中的元素(合并所有元素)
void sort_List(sqList *L);													//给线性表排序
void merge_notaqual_List(sqList *L,sqList *P,int actual_length,int actual_length1);		//合并两线性表中的元素(合并不同的元素)
void delete_aqual_List(sqList *L,int val_delete);										//输入一个数值，在线性表中删除对应的数并输出true，失败输出false
bool aqual_List(int ,int );																//判断两个数是否相同
bool full_List(sqList *L);																//判断线性表是否已满
bool empty_List(sqList *L);																//判断线性表是否为空
bool locate_List(sqList *L,int val);													//判断线性表元素是否相同

void main()
{
	sqList L;
	sqList P;

	int max_length,actual_length,position,val,insert_position,delete_position,val_insert,val_delete,position_replace,val_replace;
	int max_length1,actual_length1;
	printf("请输入L最大的线性表长度 max_length = ");
	scanf("%d",&max_length);
	init_list(&L,max_length);

	printf("请输入实际的线性表长度 actual_length = ");
	scanf("%d",&actual_length);
	append_List(&L,actual_length,max_length);

	traverse_list(&L);
	
/*	List_length(&L);
	
	printf("\n请输入一个位置的号码 position = ");
	scanf("%d",&position);
	get_Listelem(&L,position);

	printf("\n请输入一个值找到对应位置 val = ");
	scanf("%d",&val);
	locatelem_List(&L,val);

	prior_List(&L,val);
	next_List(&L,val);

	printf("\n请输入要插入的位置 insert_position = ");
	scanf("%d",&insert_position);
	printf("请输入插入的数值 val = ");
	scanf("%d",&val_insert);
	insert_List(&L,insert_position,val_insert);
	traverse_list(&L);
	actual_length++;

	printf("\n请输入要删除的位置 delete_position = ");
	scanf("%d",&delete_position);
	delete_List(&L,delete_position,actual_length);
	traverse_list(&L);
	actual_length--;
/*
	clear_List(&L);
	traverse_list(&L);
*/
	printf("\n请输入P最大的线性长度 max_length1 =");
	scanf("%d",&max_length1);
	init_list(&P,max_length);

	printf("请输入实际的线性表长度 actual_length1 = ");
	scanf("%d",&actual_length1);
	append_List(&P,actual_length1,max_length1);

	union_List(&L,&P,actual_length,actual_length1);
//	merge_notaqual_List(&L,&P,actual_length,actual_length1);

	printf("\n请输入在列表中要删除的数值!");
	scanf("%d",&val_delete);
	delete_aqual_List(&L,val_delete);
	traverse_list(&L);
	
	printf("\n请输入被替代数的位置!");
	scanf("%d",&position_replace);
	printf("\n请输入被代替的数值!");
	scanf("%d",&val_replace);
	replace_List(&L,position_replace,val_replace);
	traverse_list(&L);

}

void init_list(struct sqList *L,int max_length)
{
	L->pBase = (int*)malloc(sizeof(int*)*max_length);
	if(NULL == L->pBase)
	{
		printf("请重新建立表，表为空!");
		exit(-1);
	}
	L->length = 0;
	L->cnt = max_length;
}

void append_List(struct sqList *L,int actual_length,int max_length)
{
	if(full_List(L))
	{
		printf("请重新建表，表已满!");
		exit(-1);
	}
	else
	{
		int val;
		for(int i=0;i<actual_length;i++)
		{
			printf("请输入表值 val = ");
			scanf("%d",&val);
			L->pBase[i] = val;
		}
		L->length = actual_length;
	}
}

void traverse_list(sqList *L)
{
	if(empty_List(L))
	{
		printf("列表为空，无法显示!");
		exit(-1);
	}
	else
	{
		for(int i=0;i<L->length;i++)
		{
			printf("%d ",L->pBase[i]);
		}
	}
}

void List_length(sqList *L)
{
	printf("\n列表的长度为%d",L->length);
}

void get_Listelem(sqList *L,int position)
{
	while(1)
	{
		if(position>0 && position<L->length)
		{
			break;
		}
		printf("请重新输入位置的号码!");
		scanf("%d",&position);
	}
	printf("对应位置的值为%d",L->pBase[position-1]);
}

void locatelem_List(sqList *L,int val)
{
	if(empty_List(L))
	{
		printf("列表为空，无法寻找");
		exit(-1);
	}
	else
	{
		int i = 0;
		while(i<=L->length)
		{
			if(val == L->pBase[i])
			{
				printf("该数的位置是第%d",i+1);
				break;
			}
			else
			{
				i++;
			}
		}
	}
}

void prior_List(sqList *L,int val)
{
	if(empty_List(L))
	{
		printf("\n列表为空，无法寻找");
		exit(-1);
	}
	else
	{
		int i = 0;
		while(i<=L->length)
		{
			if(val == L->pBase[i+1])
			{
				printf("\n该数的前驱是第%d",L->pBase[i]);
				break;
			}
			else
			{
				i++;
			}
		}
	}
}

void next_List(sqList *L,int val)
{
	if(empty_List(L))
	{
		printf("列表为空，无法寻找");
		exit(-1);
	}
	else
	{
		int i = 0;
		while(i<=L->length-1)
		{
			if(val == L->pBase[i])
			{
				printf("\n该数的前驱是第%d",L->pBase[i+1]);
				break;
			}
			else
			{
				i++;
			}
		}
	}
}

void insert_List(sqList *L,int insert_position,int val_insert)
{
	while(1)
	{
		if(insert_position<L->length)
		{
			break;
		}
		printf("请重新输入一个位置!");
		scanf("%d",&insert_position);
	}
	if(L->length>=L->cnt)
	{
		L->cnt = L->cnt+1;
		int * newpBase = (int *)malloc(sizeof(int*)*L->cnt);
		if(NULL == newpBase)
		{
			printf("分配空间失败，重新分配!");
			exit(-1);
		}
		else
		{
			for(int i=0;i<insert_position-1;i++)
			{
				newpBase[i] = L->pBase[i];
			}
			for(i=insert_position-1;i<=L->length;i++)
			{
				newpBase[i+1] = L->pBase[i];
			}
		newpBase[insert_position-1] = val_insert;
		L->pBase = newpBase;
		L->length = L->length+1;
		}
	}
	else
	{
		for(int j=L->length;j>=insert_position-1;j--)
		{
			L->pBase[j+1] = L->pBase[j];
		}
		L->pBase[insert_position-1] = val_insert;
		L->length = L->length+1;
	}
}

void delete_List(sqList *L,int delete_position,int actual_length)
{
	if(empty_List(L))
	{
		printf("\n列表为空，删除失败!");
		exit(-1);
	}
	else
	{
		while(1)
		{
			if(delete_position>0&&delete_position<=actual_length)
			{
				break;
			}
			printf("\n请重新输入要删除的数!");
			scanf("%d",&delete_position);
		}
		for(int i=delete_position;i<actual_length;i++)
		{
			L->pBase[i-1] = L->pBase[i];
			L->length = actual_length-1;
		}
	}
}

void clear_List(sqList *L)
{
	L->length = 0;
	free(L->pBase);
}

void union_List(sqList *L,sqList *P,int actual_length,int actual_length1)
{
	if(empty_List(L))
	{
		printf("直接输出P列表:");
		traverse_list(P);
	}
	if(empty_List(P))
	{
		printf("直接输出L列表:");
		traverse_list(L);
	}
	for(int j=0;j<actual_length1;j++)
	{
			insert_List(L,1,P->pBase[j]);
	}
	sort_List(L);
	traverse_list(L);	
}

void merge_notaqual_List(sqList *L,sqList *P,int actual_length,int actual_length1)
{
	if(empty_List(L))
	{
		printf("直接输出P列表:");
		traverse_list(P);
	}
	if(empty_List(P))
	{
		printf("直接输出L列表:");
		traverse_list(L);
	}
	for(int j=0;j<actual_length1;j++)
	{
		if(locate_List(L,P->pBase[j]))
		{
			insert_List(L,1,P->pBase[j]);
		}
	}
	sort_List(L);
	traverse_list(L);
}

void sort_List(sqList *L)
{
	if(empty_List(L))
	{
		printf("列表为空，无法排序!\n");
		exit(-1);
	}
	else
	{
		int swap;
		for(int i=0;i<L->length-1;i++)
		{
			for(int j=0;j<L->length-1-i;j++)
			{
				if(L->pBase[j]>L->pBase[j+1])
				{	
					swap = L->pBase[j];
					L->pBase[j] = L->pBase[j+1];
					L->pBase[j+1] = swap;
				}
			}
		}
	}
}

bool full_List(sqList *L)
{
	if(L->cnt == 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool empty_List(sqList *L)
{
	if(0 == L->length)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool locate_List(sqList *L,int val)
{
	if(empty_List(L))
	{
		printf("列表为空，无法寻找");
		return false;
	}
	else
	{
		int i = 0;
		while(i<=L->length&&aqual_List(L->pBase[i],val))
		{
			i++;
		}
		if(i<=L->length)
		{
			return false;
		}
		else
		{
			return true;
		}
	}
}

bool aqual_List(int num_one,int num_tow)
{
	if(num_one == num_tow)
	{
		return false;
	}
	else
	{
		return true;
	}
}

void delete_aqual_List(sqList *L,int val_delete)
{
	if(empty_List(L))
	{
		printf("列表为空，无法寻找");
		exit(-1);
	}
	else
	{
		int j=L->length;
		for(int i=0;i<j;)
		{
			if(val_delete == L->pBase[i])
			{
				for(int k=i+1;k<j-1;k++)
				{
					L->pBase[k-1] = L->pBase[k];
				}
				L->length = L->length - 1;
			}
			else
			{
				i++;
			}
		}
	}
}

void replace_List(sqList *L,int positon_replace,int val_replace)
{
	while(1)
	{
		if(positon_replace<L->length)
		{
			break;
		}
		printf("\n重新输入替换数的位置!");
		scanf("%d",&positon_replace);
	}
	L->pBase[positon_replace] = val_replace;
}

线性链表
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	int data;
	struct Node *pNext;
}Node,*pNode;

struct Node* init_struct();								//初始化链表
void build_struct(pNode pHead,int max_len);				//建立链表元素
void traverse_struct(pNode pHead);						//显示链表中元素	
void delete_struct(pNode pHead,int pos_delete);			//删除链表中元素
int get_structelem(pNode pHead,int pos_node);			//输入节点，找到链表中元素
void locate_structelem(pNode pHead,int elem_val);		//输入数值得到链表对应位置或者不存在对应数值
void prior_structelem(pNode pHead,int pos_priornode);	//输入位置得到链表对应位置的前驱
void next_structelem(pNode pHead,int pos_nextnode);		//输入位置得到链表对应位置的后驱
void clear_struct(pNode pHead);							//清除链表中所有的元素
void merge_struct(pNode pHead,pNode pHead1);			//合并两链表中的元素(合并不同的元素)
void insert_struct(pNode pHead,int pos_insert,int val);	//输入位置和数值在链表中插入
void sort_struct(pNode pHead,int j);					//给链表排序
void union_struct(pNode pHead,pNode pHead1);			//合并两链表中的元素(合并所有元素)
int length_struct(pNode pHead);							//得到链表的长度
bool empty(pNode pHead);								//判断链表是否为空
bool equal_elem(int elem_a,int elem_b);					//判断两个数书否相等

bool locate_struct(pNode pHead,int locate_val);			//输入一个数值判断链表中是否有此数
void creat_struct(pNode pHead);							//逆序输入建立链表
pNode creat_ascend(pNode pHead);						//按非逆序建立n个元素的链表
void head_insert(pNode pHead,int val);					//在链表头插入一个数值
void insert_ascend(pNode pHead,int ascend_val);			//按非降序插入一个数值
void end_insert(pNode pHead,int end_val);				//输入一个数值在末尾插入
int get_firstelem(pNode pHead);							//得到第一个元素


void main()
{
	int max_len,pos_delete,pos_insert,pos_node,elem_val,pos_priornode,pos_nextnode,insert_val,head_val,ascend_val,end_val;
	int max_len1;
	pNode pHead = NULL;
	pNode pHead1 = NULL;

/*	printf("输入需要生成节点的个数 max_len = ");
	scanf("%d",&max_len);
	pHead = init_struct();
	build_struct(pHead,max_len);

	printf("输入需要生成节点的个数 max_len1 = ");
	scanf("%d",&max_len1);
	pHead1 = init_struct();
	build_struct(pHead1,max_len1);

	printf("请输入删除的节点位置 pos_delete=");
	scanf("%d",&pos_delete);
	while(1)
	{
		if(pos_delete>0&&pos_delete<=length_struct(pHead))
		{
			break;
		}
		printf("删除节点不在范围，重新输入!");
		scanf("%d",&pos_delete);
	}
	delete_struct(pHead,pos_delete);

	printf("请输入插入的节点位置 pos_insert=");
	scanf("%d",&pos_insert);
	printf("请输入插入的节点数值 insert_val=");
	scanf("%d",&insert_val);
	while(1)
	{
		if(pos_insert>0&&pos_insert<=length_struct(pHead))
		{
			break;
		}
		printf("插入节点不在范围，重新输入!");
		scanf("%d",&pos_insert,insert_val);
	}
	insert_struct(pHead,pos_insert,insert_val);

	printf("请输入节点的位置 pos_node=");
	scanf("%d",&pos_node);
	printf("该节点为%d\n",get_structelem(pHead,pos_node));

	printf("请输入特定数值找到节点 elem_val=");
	scanf("%d",&elem_val);
	locate_structelem(pHead,elem_val);

	printf("请输入先驱节点的位置 pos_priornode=");
	scanf("%d",&pos_priornode);
	prior_structelem(pHead,pos_priornode);

	printf("请输入后驱节点的位置 pos_nextnode=");
	scanf("%d",&pos_nextnode);
	next_structelem(pHead,pos_nextnode);

	traverse_struct(pHead);

	merge_struct(pHead,pHead1);
	union_struct(pHead,pHead1);
	sort_struct(pHead,length_struct(pHead));
	traverse_struct(pHead1);

	clear_struct(pHead);

	traverse_struct(pHead);
*/

//	creat_struct(pHead);
	pHead = creat_ascend(pHead);

	printf("请输入要插入的值 head_val=");
	scanf("%d",&head_val);
	head_insert(pHead,head_val);
	traverse_struct(pHead);
	
	printf("\n请输入要插入的值 ascend_val=");
	scanf("%d",&ascend_val);
	insert_ascend(pHead,ascend_val);
	traverse_struct(pHead);

	printf("\n请输入要插入的值 end_val=");
	scanf("%d",&end_val);
	end_insert(pHead,end_val);
	traverse_struct(pHead);

	printf("\n第一个数值=%d",get_firstelem(pHead));

}

struct Node* init_struct()
{
	pNode pHead = (pNode)malloc(sizeof(Node));
	if(NULL == pHead)
	{
		printf("分配失败!");
		exit(-1);
	}
	else
	{
		pHead->pNext = NULL;
	}
	return pHead;
}

void build_struct(pNode pHead,int max_len)
{
	pNode pTail = pHead;
	pTail->pNext = NULL;
	int val;
	for(int i=0;i<max_len;i++)
	{
		pNode pNew = (pNode)malloc(sizeof(Node));
		printf("请输入第%d的值=",i+1);
		scanf("%d",&val);
		pNew->data = val;
		pTail->pNext = pNew;
		pNew->pNext = NULL;
		pTail = pNew ;
	}
}

void delete_struct(pNode pHead,int pos_delete)
{
	if(empty(pHead))
	{
		printf("链表为空!");
		exit(-1);
	}
	else
	{
		if(1 == pos_delete)
		{
			pNode r = pHead->pNext;
			pHead = pHead->pNext->pNext;
			free(r);
		}
		else
		{
			pNode p = pHead->pNext;
			for(int i=0;i<pos_delete-2;i++)
			{
				p = p->pNext;
			}
			pNode r = p->pNext;
			p->pNext = p->pNext->pNext;
			free(r);
		}
	}
}

void insert_struct(pNode pHead,int pos_insert,int val)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	if(1 == pos_insert)
	{
		pNode p = pHead->pNext;
		pNew->pNext = p;
		pHead->pNext = pNew;
		pNew->data = val;
	}
	else
	{
		pNode p = pHead->pNext;
		for(int i=0;i<pos_insert-2;i++)
		{
			p = p->pNext;
		}
		pNode r = p->pNext;
		pNew->pNext = r;
		p->pNext = pNew;
		pNew->data = val;
	}
}

int get_structelem(pNode pHead,int pos_node)
{
	if(empty(pHead))
	{
		printf("链表为空!");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNext;
		for(int i=0;i<pos_node-1;i++)
		{
			p = p->pNext; 
		}
		return p->data;
	}
}

void locate_structelem(pNode pHead,int elem_val)
{
	int i = 1;
	pNode p = pHead->pNext;
	if(empty(pHead))
	{
		printf("链表为空!");
		exit(-1);
	}
	else
	{
		do
		{
			if(elem_val == p->data)
			{
				break;
			}
			p = p->pNext;
			i++;
		}
		while(p->pNext);
	}
	if(5 == i)
	{
		if(elem_val == p->data)
		{
			printf("此数值对应节点位置为%d\n",i);
		}
		else
		{
			printf("此数值不在范围内!\n");
		}
	}
	else
	{
		printf("此数值对应节点位置为%d\n",i);
	}
}

void prior_structelem(pNode pHead,int pos_priornode)
{
	printf("%d\n",get_structelem(pHead,pos_priornode-1));
}

void next_structelem(pNode pHead,int pos_nextnode)
{
	printf("%d\n",get_structelem(pHead,pos_nextnode+1));
}

void clear_struct(pNode pHead)
{
	pNode p = pHead->pNext;
	pNode q = NULL;
	while(NULL != p->pNext)
	{
		q = p;
		p = p->pNext;
		free(q);
	}
	pHead->pNext = NULL; 
}

int length_struct(pNode pHead)
{
	pNode p = pHead->pNext;
	int i = 1;
	while(NULL != p->pNext)
	{
		i++;
		p = p->pNext;
	}
	return i;
}

void traverse_struct(pNode pHead)
{
	if(empty(pHead))
	{
		printf("链表为空!");
		exit(-1);
	}	
	else
	{
		pNode p = pHead->pNext;
		printf("链表个节点的值为:");
		while(NULL != p)
		{
			printf("%d ",p->data);
			p = p->pNext;
		}
	}
}

void merge_struct(pNode pHead,pNode pHead1)
{
	if(empty(pHead))
	{
		if(empty(pHead1))
		{
			printf("两链表都为空!\n");
		}
		else
		{
			printf("直接输出pHead1链表:");
			traverse_struct(pHead1);
		}
	}
	else
	{
		if(empty(pHead1))
		{
			printf("直接输出pHead链表:");
			traverse_struct(pHead);
		}
		else
		{
			pNode p = pHead1->pNext;
			for(int i=0;i<length_struct(pHead1);i++)
			{
				insert_struct(pHead,2,p->data);
				p = p->pNext;
			}
		}
	}

}

void union_struct(pNode pHead,pNode pHead1)
{
	if(empty(pHead))
	{
		if(empty(pHead1))
		{
			printf("两链表都为空!\n");
		}
		else
		{
			printf("直接输出pHead1链表:");
			traverse_struct(pHead1);
		}
	}
	else
	{
		pNode p = pHead->pNext;
		for(int i=0;i<length_struct(pHead);i++)
		{
			pNode p1 = pHead1->pNext;
			for(int k=0;k<length_struct(pHead1);k++)
			{
				if(equal_elem(p1->data,p->data))
				{
					break;
				}
				else
				{
					p1 = p1->pNext;
				}
			}
			if(k>=length_struct(pHead1))
			{
				insert_struct(pHead1,1,p->data);
			}
			else
			{
				printf("第%d个数在phead1中存在\n",k);
			}
			p = p->pNext;
		}
	}

}

 
void sort_struct(pNode pHead,int len)
{
	if(empty(pHead))
	{
		printf("链表为空!");
		exit(-1);
	}
	else
	{
		int r;
		for(int i=0;i<len-1;i++)
		{
			pNode p = pHead->pNext;
			for(int k=0;k<len-i-1;k++)
			{
				if(p->data > p->pNext->data)
				{
					r = p->data;
					p->data = p->pNext->data;
					p->pNext->data = r;
				}	
			p = p->pNext;
			}
		}
	}	
}

bool empty(pNode pHead)
{
	if(NULL == pHead->pNext)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool equal_elem(int elem_a,int elem_b)
{
	if(elem_a == elem_b)
	{
		return true;
	}
	else
	{
		return false;
	}
}

/*
bool locate_struct(pNode pHead,int locate_val)
{
	pNode p = pHead->pNext;
	for(int i=0;i<length_struct(pHead);i++)
	{
		if(locate_val == p->data)
		{
			break;
		}
		else
		{
			if(p->pNext != NULL)
			{
				p = p->pNext;
			}
		}
	}
	if(i == length_struct(pHead))
	{
		return true;				//return 执行完之后函数就停止执行，跳出函数
	}
	else
	{
		return false;
	}
}

void union_struct(pNode pHead,pNode pHead1)
{
	pNode p = pHead->pNext;
	for(int i=0;i<length_struct(pHead);i++)
	{
		if(locate_struct(pHead1,p->data))
		{
			insert_struct(pHead1,1,p->data);
		}
		p = p->pNext;
	}
}

void creat_struct(pNode pHead)
{
	int n;
	pHead = (pNode)malloc(sizeof(Node));
	pHead->pNext = NULL;
	printf("请输入节点N的个数 N=");
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	{
		pNode pNew = (pNode)malloc(sizeof(Node));
		scanf("%d",&pNew->data);
		pNew->pNext = pHead->pNext;
		pHead->pNext = pNew;
	}
	traverse_struct(pHead);
}
*/
pNode creat_ascend(pNode pHead)
{
	int n;
	pHead = init_struct();
	printf("请输入元素个数 n=");
	scanf("%d",&n);
	pNode pNew = (pNode)malloc(sizeof(Node));
	scanf("%d",&pNew->data);
	pHead->pNext = pNew;
	pNew->pNext = NULL;
	for(int j=1;j<n;j++)
	{
		pNode pNew = (pNode)malloc(sizeof(Node));
		scanf("%d",&pNew->data);
		pNode q = pHead;
		pNode p =pHead->pNext;
		while(p&&p->data<pNew->data)			//while(p)就是说指针如果有指向就执行while语句，如果是0，也就是NULL（while(p)和if(p)在这里意思差不多都是当p不为空的是执行后续语句，等价于while(p!=NULL)和if(p!=NULL)）
		{
			q = p;
			p = p->pNext;
		}
		pNew->pNext = q->pNext;
		q->pNext = pNew;
	}
	return pHead;
}

void head_insert(pNode pHead,int val)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = val;
	pNew->pNext = pHead->pNext;
	pHead->pNext = pNew;
}

void insert_ascend(pNode pHead,int ascend_val)
{
	pNode q = pHead;
	pNode p = pHead->pNext;
	while(p&&ascend_val>p->data)
	{
		q = p;
		p = p->pNext;
	}
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = ascend_val;
	pNew->pNext = q->pNext;
	q->pNext = pNew;
}

void end_insert(pNode pHead,int end_val)
{
	pNode p = pHead->pNext;
	while(p->pNext != NULL)						//P->pNext更方便找前面一个节点
	{
		p = p->pNext;
	}
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = end_val;
	p->pNext = pNew;
	pNew->pNext = NULL;
}

int get_firstelem(pNode pHead)
{
	if(empty(pHead))
	{
		printf("链表为空!");
		return true;
	}
	else
	{
		return (pHead->pNext->data);
	}
}

用链表建立一个学生系统
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#define NAMELEN 8
#define CLASSLEN 4

typedef struct Stud
{
	char name[NAMELEN+1];
	long int num;
	char sex;
	int age;
	char Class[CLASSLEN+1];
	int health;
}Stud,*pStud;

typedef struct Node
{
	struct Stud *data;
	struct Node *pNext;
}Node,*pNode;

struct Node* init_Stud();
void build_Stud(pNode pHead,pStud e);
void traverse_Stud(pNode pHead);
void insert_Stud(pNode pHead,pStud e);
void delete_Stud_num(pNode pHead,long int num);
void delete_Stud_name(pNode pHead,char name[]);
void Find_Stud_num(pNode pHead,long int num);
void Find_Stud_name(pNode pHead,char name[]);
void fwrite_file(pNode pHead,FILE *fp);
void fread_file(pNode pHead,FILE *fp);
void modify_num_file(pNode pHead,long int num);
void modify_name_file(pNode pHead,char name[]);
struct Stud* readin_Stud();
bool empty(pNode pHead);

void main()
{
	int i,flag;
	long int delete_num,find_num,modify_num;
	char delete_name[NAMELEN+1],find_name[NAMELEN+1],modify_name[NAMELEN+1];
	FILE *fp;
	Stud student[4] = {{"王小林",790631,'m',18,"计91",0},{"陈红  ",790632,'f',20,"计91",1},{"刘建平",790633,'m',21,"计91",0},{"张丽丽",790634,'m',17,"计91",2}};
	pNode pHead = NULL;
	pHead = init_Stud();
	build_Stud(pHead,student);
	
	while(flag)	
	{
		printf("1:将结构体数组student中的记录按学号非降序插入\n");
		printf("2:将文件中的记录按学号非降序插入链表\n");
		printf("3:键盘输入新纪录，并将其按学号非降序插入链表\n");
		printf("4:删除链表中第一个给定学号的记录\n");
		printf("5:删除链表中第一个给定姓名的记录\n");
		printf("6:修改链表中第一个给定学号的记录\n");
		printf("7:修改链表中第一个给定姓名的记录\n");
		printf("8:查找链表中第一个给定学号的记录\n");
		printf("9:查找链表中第一个给定姓名的记录\n");
		printf("10:显示链表所有记录\n");
		printf("11:将链表中的所有记录存入文件\n");
		printf("12:结束\n");
		do
		{
			printf("选择的操作为:");
			scanf("%d",&i);
		}while(i>12||i<0);
		printf("\n");
		switch(i)
		{
		case 1:	{
					for(int i=1;i<4;i++)
					{
						insert_Stud(pHead,student+i);
					}
					break;
				}
		case 2:if((fp = fopen("text.txt","a+") )== NULL)
				{
					fprintf(stderr,"%s","open failed!");
					exit(-1);
				}
				else
				{
					rewind(fp);							//要读取文件必须回到文件的开头这一步很重要
					fread_file(pHead,fp);
				}
				fclose(fp);
				break;
		case 3:
				insert_Stud(pHead,readin_Stud());
				break;
		case 4:
				printf("请输入删除学生的学号:");
				scanf("%ld",&delete_num);
				delete_Stud_num(pHead,delete_num);
				break;
		case 5:	printf("请输入删除学生的名字:");
				scanf("%s",delete_name);
				delete_Stud_name(pHead,delete_name);
				break;
		case 6:printf("请输入修改学生的学号:");
			   scanf("%ld",&modify_num);
			   modify_num_file(pHead,modify_num);
			   break;
		case 7:printf("请输入修改学生的名字:");
			   scanf("%s",&modify_name);
			   modify_name_file(pHead,modify_name);
			   break;
		case 8:printf("请输入查找学生的学号:");
			   scanf("%ld",&find_num);
			   Find_Stud_num(pHead,find_num);
			   break;
		case 9:printf("请输入查找学生的名字:");
			   scanf("%s",find_name);
			   Find_Stud_name(pHead,find_name);
			   break;
		case 10:traverse_Stud(pHead);
				break;
		case 11:if((fp = fopen("text.txt","a+") )== NULL)
				{
					fprintf(stderr,"%s","open failed!");
					exit(-1);
				}
				else
				{
					fwrite_file(pHead,fp);
				}
				fclose(fp);
				break;
		case 12:flag = 0;
				break;
		}
	}
}

struct Node* init_Stud()
{
	pNode pHead = (pNode)malloc(sizeof(Node));
	if(pHead == NULL)
	{
		printf("分配失败!");
		exit(-1);
	}
	else
	{
		pHead->pNext = NULL;
	}
	return pHead;
}

void build_Stud(pNode pHead,pStud e)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	if(pHead == NULL)
	{
		printf("分配失败!");
		exit(-1);
	}
	else
	{
		pNew->data = e;
		pHead->pNext = pNew;
		pNew->pNext = NULL;
	}
}

void traverse_Stud(pNode pHead)
{
	if(empty(pHead))
	{
		printf("学生表为空!");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNext;
		printf("学号   姓名   年纪   性别   班级   健康\n");
		while(p)
		{
			printf("%6ld %3s %d %5c %9s %3d\n",p->data->num,p->data->name,p->data->age,p->data->sex,p->data->Class,p->data->health);
			p = p->pNext;
		}
	}
}

void insert_Stud(pNode pHead,pStud e)
{
	pNode p = pHead->pNext;
	pNode q = pHead;
	while(p&&e->name>p->data->name)
	{
		q = p;
		p = p->pNext;
	}
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = e;
	pNew->pNext = q->pNext;
	q->pNext = pNew;
}

struct Stud* readin_Stud()
{
	pStud stdentelem = (pStud)malloc(sizeof(Stud));
	if(stdentelem == NULL)
	{
		printf("学生名单建立失败!");
		exit(-1);
	}
	else
	{
		printf("请输入学生的学号:");
		scanf("%ld",&stdentelem->num);
		printf("\n请输入学生的姓名:");
		scanf("%s",stdentelem->name);
		printf("\n请输入学生的性别:");
		scanf("%*c%c",&stdentelem->sex);
		printf("\n请输入学生的年纪:");
		scanf("%d",&stdentelem->age);
		printf("\n请输入学生的班级:");
		scanf("%s",stdentelem->Class);
		printf("\n请输入学生的健康状况");
		scanf("%d",&stdentelem->health);
	}
	return stdentelem;
}

void delete_Stud_num(pNode pHead,long int num)
{
	if(empty(pHead))
	{
		printf("学生表为空!");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNext;
		pNode q = pHead;
		while(p&&p->data->num != num)
		{
			q = p;
			p = p->pNext;
		}
		if(p)
		{
			q->pNext = p->pNext;
			free(p);
		}
		else
		{
			printf("删除失败!\n");
		}
	}
}

void delete_Stud_name(pNode pHead,char name[])
{
	if(empty(pHead))
	{
		printf("链表为空!");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNext;
		pNode q = pHead;
		while(p&&strcmp(p->data->name, name) != 0)
		{
			q = p;
			p = p->pNext;
		}
		if(p)
		{	
			q->pNext = p->pNext;
			free(p);
		}
		else
		{
			printf("删除失败!\n");
		}
	}
}

void Find_Stud_num(pNode pHead,long int num)
{
	if(empty(pHead))
	{
		printf("链表为空!\n");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNext;
		while(p&&p->data->num != num)
		{
			p = p->pNext;
		}
		if(p)
		{
			printf("%6ld %3s %d %5c %9s %3d\n",p->data->num,p->data->name,p->data->age,p->data->sex,p->data->Class,p->data->health);
		}
		else
		{
			printf("输入名找不到!\n");
		}
	}
}

void Find_Stud_name(pNode pHead,char name[])
{
	if(empty(pHead))
	{
		printf("链表为空!\n");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNext;
		while(p&&strcmp(p->data->name, name) != 0)
		{
			p = p->pNext;
		}
		if(p)
		{
			printf("%6ld %3s %d %5c %9s %3d\n",p->data->num,p->data->name,p->data->age,p->data->sex,p->data->Class,p->data->health);
		}
		else
		{
			printf("输入名找不到!\n");
		}
	}
}

void fwrite_file(pNode pHead,FILE *fp)
{
	if(empty(pHead))
	{
		printf("存储列表为空!\n");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNext;
		while(p)
		{
			fwrite(p->data,sizeof(Stud),1,fp);
			p = p->pNext;
		}
	}
}

void fread_file(pNode pHead,FILE *fp)
{
	int count;
	do
	{
		pStud stdentelem = (pStud)malloc(sizeof(Stud));
		if(stdentelem == NULL)
		{
			printf("学生名单建立失败!");
			exit(-1);
		}
		else
		{
			count = fread(stdentelem,sizeof(Stud),1,fp);
			if(count>0)
			{
				insert_Stud(pHead,stdentelem);
			}
		}
	}while(count > 0);
}

void modify_num_file(pNode pHead,long int num)
{
	if(empty(pHead))
	{
		printf("学生表为空!");
		exit(-1);
	}
	else
	{
		char s[80];
		pNode p = pHead->pNext;
		while(p&&p->data->num != num)
		{
			p = p->pNext;
		}
		if(p)
		{
			printf("%6ld %3s %d %5c %9s %3d\n",p->data->num,p->data->name,p->data->age,p->data->sex,p->data->Class,p->data->health);
			printf("请输入要修改的内容，不修改的按回车键跳过\n");
			fflush(stdin);
			printf("请输入要修改的姓名:");
			gets(s);
			if(strlen(s)>0)
			{
				strcpy(p->data->name,s);
			}
			printf("请输入要修改的学号:");
			gets(s);
			if(strlen(s)>0)
			{
				p->data->num = atoi(s);
			}
			printf("请输入要修改的性别:");
			gets(s);
			if(strlen(s)>0)
			{
				p->data->sex = s[0];
			}
			printf("请输入要修改的年纪:");
			gets(s);
			if(strlen(s)>0)
			{
				p->data->age = atoi(s);
			}
			printf("请输入要修改的班级:");
			gets(s);
			if(strlen(s)>0)
			{
				strcpy(p->data->Class,s);
			}
			printf("请输入要修改的健康状况:");
			gets(s);
			if(strlen(s)>0)
			{
				p->data->health = atoi(s);
			}
		}
		else
		{
			printf("不出在输入学号!\n");
			exit(-1);
		}
		//fflush(stdin);
	}
}

void modify_name_file(pNode pHead,char name[])
{
	if(empty(pHead))
	{
		printf("学生表为空!");
		exit(-1);
	}
	else
	{
		char s[80];
		pNode p = pHead->pNext;
		while(p&&strcmp(p->data->name,name) != 0)
		{
			p = p->pNext;
		}
		if(p)
		{
			printf("%6ld %3s %d %5c %9s %3d\n",p->data->num,p->data->name,p->data->age,p->data->sex,p->data->Class,p->data->health);
			printf("请输入要修改的内容，不修改的按回车键跳过\n");
			fflush(stdin);
			printf("请输入要修改的姓名:");
			gets(s);
			if(strlen(s)>0)
			{
				strcpy(p->data->name,s);
			}
			printf("请输入要修改的学号:");
			gets(s);
			if(strlen(s)>0)
			{
				p->data->num = atoi(s);
			}
			printf("请输入要修改的性别:");
			gets(s);
			if(strlen(s)>0)
			{
				p->data->sex = s[0];
			}
			printf("请输入要修改的年纪:");
			gets(s);
			if(strlen(s)>0)
			{
				p->data->age = atoi(s);
			}
			printf("请输入要修改的班级:");
			gets(s);
			if(strlen(s)>0)
			{
				strcpy(p->data->Class,s);
			}
			printf("请输入要修改的健康状况:");
			gets(s);
			if(strlen(s)>0)
			{
				p->data->health = atoi(s);
			}
		}
		else
		{
			printf("不存在输入姓名!\n");
			exit(-1);
		}
	}
}

bool empty(pNode pHead)
{
	if(pHead->pNext == NULL)
	{
		return true;
	}
	else
	{
		return false;
	}
}





文件的读取(fopen的用法)
#include <stdio.h>

void main()
{
	int ch;

	FILE *fp;
	fp = fopen("text1.txt","r");
	ch = getc(fp);
	while(ch != EOF)				//ch ！= EOF代表的ch不为结束符'\0'
	{
		putchar(ch);
		ch = getc(fp);
	}
}
/*
fopen()成功打开一个文件后:函数返回一个文件指针，以便其他函数用这个指针来指向该文件
fopen()失败打开一个文件后:fopen()函数返回空指针，也就是NULL
*/

文件的关闭(fclose的用法)
if(fclose(fp) != 0)
{
	printf("Error in closing file %s\n",);
}
/*
如果文件成功关闭，fclose()函数将返回值0，否则返回EOF
*/

getchar()和putchar()的用法
#include <stdio.h>
#define SPACE ' '

void main()
{
	char ch;

	ch = getchar();					//都一个字符
	while(ch != '\n')				//当一行未结束时		//在读取文件时用while(ch != EOF) EOF代表文件结尾
	{	
		if(ch == SPACE)
		{
			putchar(ch);			//空格不变
		}
		else
		{	
			putchar(ch+1);			//非空格加1
		}
		ch = getchar();				//打印换行符
	}
	putchar(ch);
}
/*
ch = getchar();等同于scanf("%c",&ch);
putchar(ch);等同于printf("%c",ch)
但是在getchar()执行时 是输入一串字符(或数字)，再按回车		
(1)用户输入的字符被存放在键盘缓冲区中.直到用户按回车为止
(2)当用户键入回车之后，getchar才开始从stdio流中每次读入一个字符.且将用户输入的字符回显到屏幕.	（也就是说getchar()是一个个读取缓存区的输入字符）
*/

puts与gets的用法
(1)gets用法
#include <stdio.h>
#define MAX 81

void main()
{
	char name[MAX];
	printf("Hi,what's your name?\n");
	gets(name);									//比较gets(name)与ch = getchar();	gets(name)它是从系统的标准设备获得一个字符串
	printf("Nice name,%s.\n",name);
}(2)gets当作指针的用法
#include <stdio.h>
#define MAX 81

void main()
{   
	char name[MAX];
	char *ptr;									//将get(name)赋值给一个地址

	printf("Hi,what's your name?\n");
	ptr = gets(name);
	printf("%s? Ah! %s!\n",name,ptr);
}
/*
gets()函数如果返回顺利，它返回的是读入字符串的地址，如果出错或遇到文件结尾，它就返回一个空(或0)地址。
gets()遇到回车\n会取出来 所以不用清空stdin
*/
(3)puts()函数的用法
#include <stdio.h>

void main()
{
	char side_a[] = "SIDE A";
	char dont[] = {'w','o','w','!'};				//puts()在输出字符串时会自动在其后面添加一个换行符
	char side_b[] = "SIDE B";

	puts(dont);
}
/*
dont缺少一个表示结束的空字符('\0')，因此它不是一个空字符，这样PUTS()就不知道该停在哪里,停止之后会加上换行符('\n')
*/

#include <stdio.h>

void main()
{
	char buf[100];

	puts("hello world !");

	gets(buf);
}
/*
puts("hello world!")是向设备输入字符串
gets(buf);是从将输入设备的字符串存入内存中
*/

getc()和putc()函数的用法
(1)ch = getc(fp);  	//从指针fp制定的文件中获得一个字符
(2)putc(ch,fpout);	//将字符ch写入到FILE指针fpout指定的文件中
(3)#include <stdio.h>

void main()
{
	int ch;

	FILE *fp;
	fp = fopen("D:/娱乐文件/Microsoft Visual Studio/MyProjects/倒萨倒萨/text1.txt","r");
	ch = getc(fp);							//从标准文件中获得一个字符
	while(ch != EOF)
	{
		putchar(ch);
		ch = getc(fp);
	}
}
/*
文件结尾:从文件中读取数据的程序需要在达到文件结尾时停止。在尝试读入字符时发现已经到文件结尾，getc()函数会返回一个特殊值EOF
*/

文件的输入(fscanf的用法)和输出(fprintf用法)
#include <stdio.h>

void main()
{
	FILE *fp;
	char words[MAX];

	if((fp = fopen("D:/娱乐文件/Microsoft Visual Studio/MyProjects/倒萨倒萨/text1.txt","a+")) == NULL);
	{
		fprintf(stdout,"Can't open \"words\" file.\n");
		exit(-1);
	}
	puts("Enter words to add to the file press the Enter");
	puts("key at the beginning of line to terminate.");
	while(gets(word) != NULL && word[0] != '\0')			//gets()需要知道输入合适才结束，解决的方法是读字符串直到遇到一个换行字符(\n),按回车键可以产生这个字符，他读取换行字符之前的所有字符，在这些字符后添加一个空字符(\0)(也就是将\n变成\0),然后把这个字符串交给调用它的程序
	{
		fprintf(fp,"%s",words);							//fprintf()是向文件中写入数据
	}
	puts("file contentds");
	rewind(fp);
	while(fscanf(fp,"%s",word) == 1)					//这里将内容以空格的形式分开，以单个字符串(%s)为一个单元 只要存在字符串就循环
	{
		puts(word);
	}
	if(fclose(fp) != 0)
	{
		fprintf(stderr,"Error closing file\n");
	}
}
/*
fprintf()是以空字符为结束('/0')
fscanf遇到(' ')空格和换行(\n)时结束，注意空格时也结束
*/

fgets()用法和fputs()
比较fgets()与gets的用法:
(1)它需要第二个参数来说明最大入字符数。如果这个参数值为n，fgets()就会读取最多n-1个字符(第n个字符赋值'\0')或读完一个换行符为止，由这两者中最先满足的那个来结束输入,第三种就是读取的的字符超过n个字符，则fgets只返回一个不完整的行，但是，缓存区总是以NULL字符结尾
(2)如果fgets()读取到换行符，就会把它存放到字符串里，而不是像gets()那样丢失它
(3)它还需要第三个参数来说明读哪个文件。从键盘上读数据时，可以使用stdin(代表standard input作为该参数，这个标识符stdio.h中定义),这是采取键盘输入到电脑缓存区
#include <stdio.h>
#define MAX 81

void main()
{
	char name[MAX];
	char *ptr;
	
	printf("Hi,what's your name?\n");
	ptr = fgets(name,MAX,stdin);				//输入成功时，返回char型指针，指向读入的字符内容，含换行键(gets类似，但不含换行键)；输入失败时，返回NULL
	printf("%s? Ah! %s\n",name,ptr);
}
输入:yuzheng
显示:
Hi,what's your name?
Jon Dougt
Jon Dougt				//在上面一行输入JON Dough时fgets()也会记录换行符号(\n),在下面输出时printf()会输出记录的(\n)
? Ah! Jon Dougt
!
比较fputs()函数是gets()的面向文件的版本
(1)fputs()需要第二个参数来说明要写的文件。
(2)与puts()不同，fputs()并不为输出自动添加换行符(并且以"\0"结束符)
*(a)gets()丢掉输入里的换行符，但是puts()为输出添加换行。另一方面，fgets()存储输入中的换行符，而fputs()也不为输出添加换行符。
char line[81];
while(gets(line))	//如果遇到文件结尾，gets()就返回空指针。空指针的值为0(或NULL)，这样就结束了循环
	put(line);
*(b)
char line[81];
while(fgets(line,81,stdin))				//键盘输入缓存区(stdin)读取字符串
	fputs(line,stdout);					//将line的字符串输出显示(stdout)
	/*
	第一个循环中，line数组中的字符串被显示在单独的一行上，这是由于puts()为它添加了一个换行符。
	第二个循环中，line数组中的字符同样显示在单独的一行上，这是由于fgets()存储了一个换行符
	*/

	

利用c语言实现文件的读取输入输出
关于fprintf()的实现
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define SIZE 81

int  main(void)
{
	FILE *fp;
	char *filename = "D:/娱乐文件/Microsoft Visual Studio/MyProjects/法大师傅大师傅房贷首付/text.txt";
	char buf[SIZE] = {0};
	char *pout;
	char errcode;

	fp = fopen(filename,"r");
	if(fp == NULL)
	{
		fprintf(stderr,"%s,%s\n",filename,"open failed");
		system("pause");
		return -1;
	}

	do
	{
		pout = fgets(buf,SIZE,fp);
		if(pout == NULL)
		{
			if(feof(fp))		//feof(文件指针)函数检测判断是否结尾，如果文件结束，则返回值为1，否则为0
			{
				fprintf(stderr,"%s\n","file end!");				//stderr为控制台
			}	
			else
			{
				errcode = ferror(fp);		//ferror()输入输出函数判断是否错误，如错误返回值为非0，如果没错误返回0
				fprintf(stderr,"%s\n",strerror(errcode));		//strerror(数字)根据数字不同来输出描述出错的原因:
/*
0 : Success
1 : Operation not permitted
2 : No such file or directory
3 : No such process
4 : Interrupted system call
5 : Input/output error
6 : Device not configured
7 : Argument list too long
8 : Exec format error
9 : Bad file descripto
*/
			}

			fclose(fp);
			system("pause");
			return -1;
		}
	
	fprintf(stderr,"%s\n",buf);
	}while(pout != NULL);

	fclose(fp);

	system("pause");
	return 0;
}

关于fscanf()的应用
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define SIZE 81

int  main(void)
{
	FILE *fp;
	char *filename = "D:/娱乐文件/Microsoft Visual Studio/MyProjects/法大师傅大师傅房贷首付/text.txt";
	char buf[SIZE] = {0};
	char *pout;
	char errcode;
	char count;				//int a1,a2,a3,a4

	fp = fopen(filename,"r");
	if(fp == NULL)
	{
		fprintf(stderr,"%s,%s\n",filename,"open failed");
		system("pause");
		return -1;
	}

	do
	{
		count = fscanf(fp,"%[^\n]",buf);				//count = fscanf(fp,"%d,%d,%d,%d",a1,a2,a3,a4);		
		//如果用%s形式,fscanf实际上读取的是一个单词
		//遇到空格、换行都会停止读取
		//%s自能度一个单词，%[^\n]可以读一行(%[^\n]的意思是默认不读\n)
		//实际上,fscanf是按行读取的，遇到空格、换行都会停止；如果当前格式读取的内容，与格式不一样就会报错
		if(count>0)
		{
			fprintf(stderr,"%s\n",buf);						//fprintf(stderr,"%d--%d--%d--%d",a1,a2,a3,a4);
		}
		else
		{
			if(feof(fp))
			{
				fprintf(stderr,"%s\n","file end!");
			}
			else
			{
				errcode = ferror(fp);
				fprintf(stderr,"%s",strerror(errcode));
			}

			fclose(fp);
			system("pause");
		}

	}while(count > NULL);

	fclose(fp);

	system("pause");
	return 0;
}

关于fread的学习
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define SIZE 120

int  main(void)
{
	FILE *fp;
	char *filename = "D:/娱乐文件/Microsoft Visual Studio/MyProjects/text.txt";
	char buf[SIZE] = {0};
	char *pout;
	char errcode;
	char count;	
	int *p;

	fp = fopen(filename,"r");
	if(fp == NULL)
	{
		fprintf(stderr,"%s,%s\n",filename,"open failed");
		system("pause");
		return -1;
	}

	buf[SIZE] = 0;				//以0或'\0'结尾是防止读溢出，会读出乱码
	count = fread(buf,sizeof(char),(SIZE-1)/sizeof(char),fp);						
	//fread是以字节的形式读取，所以换行符会被当作一个普通的字符来读取
	//fread虽然以字节的形式读取，但是，他是以一个单位作为整体来读取的
	//这个单位的大小，就是第二个参数
	//如果是char单位，返回值就是字节数
	//如果是int单位，返回值是字节数/sizeof(int)
	//如果用fread读取二进制文本内容，以字符串的形式输出，可能输出的结果不是完整的
	if(count>0)
	{
		buf[count] = 0;
		p = (int*)buf;
		for(int i;i<count;i++)
		{
			fprintf(stderr,"%d",buf);
		}
	}
	else
	{
		if(feof(fp))
		{
				fprintf(stderr,"%s\n","file end!");
		}
		else
		{
			errcode = ferror(fp);
			fprintf(stderr,"%s",strerror(errcode));
		}

	}
	fclose(fp);

	system("pause");
	return 0;
}

fprintf详细讲解
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main()
{
	FILE *fp;

	if((fp = fopen("text.txt","a+")) != NULL)
	{
		fprintf(fp,"%s\n","hello world");
	}
	else
	{
		fprintf(stderr,"%s","open failed!");
		exit(-1);
	}

	fclose(fp);
}

fputs(char *str,FILE *fp)
参数:
	str:写入字符串
	fp:文件指针
		可以是文件
		可以是便准输出:输出到屏幕
		可以是标准输入:把一个字符串作为输入
返回值:
	成功返回非负数
	失败返回EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define SIZE 80

void main()
{
	FILE *fp;
	char buf[SIZE];

	if((fp = fopen("text.txt","a+")) != NULL)
	{
		strcpy(buf,"\nnew strcpy");
		fputs(buf,fp);
	}
	else
	{
		fprintf(stderr,"%s","open failed!");
		exit(-1);
	}

	fclose(fp);
}

fwrite用法的详解
fwrite(void *buf,size_t size,size_t count,FILE *fp)
参数:
	buf:要写入的内存数组地址
	size:写入元素的大小
	count:写入元素的大小
	fp:文件指针
返回值
	返回成功写入的单元数
	如果小于count，则发生错误
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define SIZE 80
#define NAMELEN 8
#define CLASSLEN 4

typedef struct Stud
{
	char name[NAMELEN+1];
	long int num;
	char sex;
	int age;
	char Class[CLASSLEN+1];
	int health;
}Stud,*pStud;

void main()
{
	Stud student[4] = {{"王小林",790631,'m',18,"计91",0},{"陈红  ",790632,'f',20,"计91",1},{"刘建平",790633,'m',21,"计91",0},{"张丽丽",790634,'m',17,"计91",2}};
	FILE *fp;
	char buf[SIZE];
	int x = 123456;
	double y = 123.456;
	int a[5]={1,2,3,4,5};
	double b[3]={1.1,2.2,3.3};

	if((fp = fopen("text.txt","a+")) != NULL)
	{
		strcpy(buf,"\n1new strcpy");
		//fwrite(buf,sizeof(buf),strlen(buf),fp);
		//fwrite(&x,sizeof(int),1,fp);
		//fwrite(&y,sizeof(double),1,fp);
		//fwrite(b,sizeof(double),sizeof(b)/sizeof(double),fp);
		//fwrite(a,sizeof(int),sizeof(a)/sizeof(int),fp);

		fwrite(&student,sizeof(Stud),4,fp);
	}
	else
	{
		fprintf(stderr,"%s","open failed!");
		exit(-1);
	}

	fclose(fp);
}

完成格式化读写，按行读写
#include <stdio.h>
#include <stdlib.h>

void fwrite();
void fread();

void main()
{

	fwrite();

	fread();
}

void fwrite()
{
	FILE *fp;
	int total = 0;
	int num = 0;
	int count = 0;
	
	do
	{
		printf("total = ");
		scanf("%d",&total);
		if(total<=0)
		{
			printf("请重新输入合法数据");
		}
		else
		{
			break;
		}
	}while(total<=0);
	

	if(( fp = fopen("text.txt","w+")) != NULL)
	{
		fprintf(fp,"%d\n",total);
		for(;count<total;count++)
		{
			printf("num%d:",count+1);
			scanf("%d",&num);
			fprintf(fp,"%d\n",num);
		}
	}
	else
	{
		printf("open failed\n");
		exit(-1);
	}
	fclose(fp);
}

void fread()
{
	FILE *fp;
	int total = 0;
	int num = 0;
	int count = 0;
	
	if(( fp = fopen("text.txt","r")) != NULL)
	{
		printf("total =");
		fscanf(fp,"%d",&total);
		printf("%d\n",total);
		for(;count<total;count++)
		{
			fscanf(fp,"%d",&num);
			printf("->%d\n",num);
		}
	}
	else
	{
		printf("open failed\n");
		exit(-1);
	}
	fclose(fp);
}

完成结构体的输入输入输出
#include <stdio.h>
#include <string.h>

typedef struct
{
	char name[30];
	unsigned int id;
}Publisher,*PPublisher;

typedef struct
{
	int price;
	char title[30];
	PPublisher ppubilisher;
}Book,*pBook;

void my_book_write();
void my_book_read();

void main()
{
//	my_book_write();

	my_book_read();
}

void my_book_write()
{
	FILE *fp;
	Book bk1,bk2;
	Publisher pub1,pub2;

	bk1.price = 123;
	strcpy(bk1.title,"music");
	bk1.ppubilisher = &pub1;

	pub1.id = 345;
	strcpy(pub1.name,"publisher one");

	bk2.price = 987;
	strcpy(bk2.title,"history");
	bk2.ppubilisher = NULL;

	if((fp = fopen("text.txt","w")) != NULL)
	{
		fwrite(&bk1,sizeof(Book),1,fp);
		if(bk1.ppubilisher != NULL)
		{
			fwrite(bk1.ppubilisher,sizeof(Publisher),1,fp);
		}
		fwrite(&bk2,sizeof(Book),1,fp);
		if(bk2.ppubilisher != NULL)
		{
			fwrite(bk2.ppubilisher,sizeof(Publisher),1,fp);
		}
	}
	else
	{
		printf("open failed\n");
	}
	fclose(fp);
}

void my_book_read()
{
	int count;
	FILE *fp;
	Book bk1,bk2;
	Publisher pub1,pub2;
	bk1.ppubilisher = &pub1;
	bk2.ppubilisher = &pub2;

//	rewind(fp);
	if((fp = fopen("text.txt","r")) != NULL)
	{
		count = fread(&bk1,sizeof(Book),1,fp);
		if(count<0)
		{
			printf("fread failed!\n");
		}
		else
		{
			printf("book1.title = %s\nbook1.price = %d\n",bk1.title,bk1.price);
			if(bk1.ppubilisher != NULL)
			{
				count = fread(&pub1,sizeof(Publisher),1,fp);
				if(count<0)
				{
					printf("fread failed!");
				}
				else
				{
					printf("book1.name = %s\nbook1.id = %d\n",pub1.name,pub1.id);
				}
			}
		}
	}
	else
	{
		printf("open failed\n");
	}

	count = fread(&bk2,sizeof(Book),1,fp);
	if(count<0)
	{
		printf("fread failed!\n");
	}
	else
	{
		printf("book2.title = %s\nbook2.price = %d\n",bk2.title,bk2.price);
		if(bk2.ppubilisher != NULL)
		{
			count = fread(&pub2,sizeof(Publisher),1,fp);
			if(count<0)
			{
				printf("fread failed!");
			}
			else
			{
				printf("book2.name = %s\nbook2.id = %d\n",pub2.name,pub2.id);
			}
		}
	}
	fclose(fp);
}






静态链表(静态定义一个相当大的空间)
一个简单的静态链表程序
#include <stdio.h>
#include <string.h>
#define MAXSIZE 100
#define NAMEMAX 8

typedef struct
{
	char name[NAMEMAX+1];
	int cur;
}compnent,SLinklist[MAXSIZE];

void main()
{
	SLinklist s={{"",1},{"qian",2},{"sun",3},{"li",4},{"zhou",5},{"wu",6},{"zhao",7},{"zheng",8},{"wang",9}};
	int i;
	i = s[0].cur;
	while(i)
	{
		printf("%s\n",s[i].name);
		i = s[i].cur;
	}
	printf("\n");
	s[4].cur = 9;
	s[6].cur = 8;
	s[9].cur = 5;
	s[8].cur = 10;
	strcpy(s[9].name,"shi");
	i = s[0].cur;
	while(i)
	{
		printf("%s\n",s[i].name);
		i = s[i].cur;
	}
	printf("\n");
}

静态链表一(针对单一链表)
#include <stdio.h>
#include <stdlib.h>
#define MAXSIZE 100

typedef struct
{
	int num;
	int cur;
}component,SLinklist[MAXSIZE];

void create_list(SLinklist L);
void init_list(SLinklist L,int len);
int length_list(SLinklist L);
int malloc_list(SLinklist L);
void insert_list(SLinklist L,int index);
void delete_list(SLinklist L,int index);
int get_list_num(SLinklist L,int index);
void sort_list_num(SLinklist L);
void traverse_list(SLinklist L);
bool empty_list(SLinklist L);
bool full_list(SLinklist L);


void main()
{
	int len,insert_index,delete_index,get_index;
	SLinklist L;
	create_list(L);

	printf("请输入要建立链表的长度 len:");
	scanf("%d",&len);
	init_list(L,len);

	traverse_list(L);

	printf("\n请输入要插入链表的位置 insert_index:");
	scanf("%d",&insert_index);
	insert_list(L,insert_index);

	traverse_list(L);

	printf("\n请输入要删除链表的位置 delete_index:");
	scanf("%d",&delete_index);
	delete_list(L,delete_index);

	sort_list_num(L);
	traverse_list(L);

	printf("\n请输入要删除链表的位置 get_index:");
	scanf("%d",&get_index);
	printf("%d",get_list_num(L,get_index));
	

}

void create_list(SLinklist L)
{
	L[MAXSIZE-1].cur = 0;
	for(int i=0;i<MAXSIZE-1;i++)
	{
		L[i].cur = i+1;
	}
}

void init_list(SLinklist L,int len)
{
	if(len<1||len>MAXSIZE-2)
	{
		printf("初始化的个数已经超过了，请从新输入len=");
		scanf("%d",&len);
	}
	for(int i=1;i<=len;i++)
	{
		scanf("%d",&L[i].num);
	}
	L[0].cur = len+1;
	L[MAXSIZE-1].cur = 1;
	L[len].cur = 0;
}

int length_list(SLinklist L)
{
	int j=0,k = L[MAXSIZE-1].cur;
	do
	{
		k = L[k].cur;
		j++;
	}while(L[k].cur);
	return j;
}

int malloc_list(SLinklist L)
{
	int k = L[0].cur;
	L[0].cur = L[k].cur;
	return k;
}

void free_list(SLinklist L,int k)
{
	L[k].cur = L[0].cur;
	L[0].cur = k;
}

void insert_list(SLinklist L,int index)
{
	if(index<1||index>length_list(L)+1)
	{
		printf("插入位置不在范围!");
		exit(-1);
	}
	else
	{
		int num,k=MAXSIZE-1;
		int j = malloc_list(L);
		printf("输入要插入的数字:");
		scanf("%d",&num);
		L[j].num = num;
		for(int i=1;i<index;i++)
		{
			k = L[k].cur;
		}
		L[j].cur = L[k].cur;
		L[k].cur = j;
	}
}

void delete_list(SLinklist L,int index)
{
	if(index<1||index>length_list(L)+1)
	{
		printf("插入位置不在范围!");
		exit(-1);
	}
	else
	{
		int m,k=MAXSIZE-1;
		for(int i=1;i<index;i++)
		{
			k = L[k].cur;
		}
		m = L[k].cur;
		L[k].cur = L[m].cur;
		free_list(L,m);
	}
}

int get_list_num(SLinklist L,int index)
{
	if(index<1||index>length_list(L)+1)
	{
		printf("插入位置不在范围!");
		exit(-1);
	}
	else
	{
		int k=MAXSIZE-1;
		for(int i=0;i<index;i++)
		{
			k = L[k].cur;
		}
		return L[k].num;
	}
}

void sort_list_num(SLinklist L)
{
	int m,k=MAXSIZE-1;
	for(int i=0;i<length_list(L)-1;i++)
	{
		for(int j=0;j<length_list(L)-i-1;j++)
		{
			if(L[j].num>L[j+1].num)
			{
				m = L[j].num;
				L[j].num = L[j+1].num;
				L[j+1].num = m;
			}
		}
	}
}

void traverse_list(SLinklist L)
{
	int k=L[MAXSIZE-1].cur;

	if(k == 0)
	{
		printf("链表为空!\n");
		exit(-1);
	}
	else
	{
		for(int i=0;i<length_list(L)+1;i++)
		{
			printf("->%d",L[k].num);
			k = L[k].cur;
		}
	}
}

bool empty_list(SLinklist L)
{
	if(L[MAXSIZE-1].cur == 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool full_list(SLinklist L)
{
	if(L[0].cur == MAXSIZE-1)
	{
		return true;
	}
	else
	{
		return false;
	}
}


静态链表二(针对多链表) 陆斯文 换道 跟车
#include <stdio.h>
#include <stdlib.h>
#define MAXSIZE 100

typedef struct
{
	int num;
	int cur;
}component,SLinklist[MAXSIZE];

void init_space(SLinklist L);
int init_list(SLinklist L);
int malloc(SLinklist L);
void insert_list(SLinklist L,int n,int i,int e);
bool empty_list(SLinklist L,int n);
int length_list(SLinklist L,int n);
void claer_list(SLinklist L,int n);
void traverse_list(SLinklist L,int n);
void get_listelem(SLinklist L,int n,int pos);
void delete_listelem(SLinklist L,int n,int pos);
void free(SLinklist L,int n);
void union_list(SLinklist L,int La,int Lb,int Lc);
bool cmp_list(SLinklist L,int Lb_num,int La);
void merge_list(SLinklist L,int La,int Lb,int Lc);
void sort_list(SLinklist L,int n);
void write_list(SLinklist L,int n);
void read_list(SLinklist L,int n);

void main()
{
	int get_pos,delete_pos,insert_num;
	SLinklist L;
	init_space(L);
	int La = init_list(L);
	int Lb = init_list(L);
	int Lc = init_list(L);
	
	printf("La表是否为空?%d(1:空 0:否)\n",empty_list(L,La));
	printf("La表的表长=%d\n",length_list(L,La));
	for(int j=1;j<=5;j++)
	{
		printf("请输入%d插入的数 insert_num =",j);
		scanf("%d",&insert_num);
		insert_list(L,La,j,insert_num);
	}
	printf("在空表La的表头依次插入1~5后 La:");
	traverse_list(L,La);
	
	printf("Lb表是否为空?%d(1:空 0:否)\n",empty_list(L,Lb));
	printf("Lb表的表长=%d\n",length_list(L,Lb));
	for(j=1;j<=5;j++)
	{	
		printf("请输入%d插入的数 insert_num =",j);
		scanf("%d",&insert_num);
		insert_list(L,Lb,j,insert_num);
	}
	printf("在空表Lb的表尾一次插入1~5后 Lb=");
	traverse_list(L,Lb);
	
//	claer_list(L,La);
//	printf("清空La后 La = ");
//	traverse_list(L,La);
//	printf("La表是否为空?%d(1:空 0:否)\n",empty_list(L,La));
//	printf("La表的表长=%d\n",length_list(L,La));

	do
	{
		printf("请输入要得到表的编号 get_pos =");
		scanf("%d",&get_pos);
	}while(get_pos<1||get_pos>length_list(L,Lb)+1);
	get_listelem(L,Lb,get_pos);

	do
	{
		printf("请输入要得到表的编号 delete_pos =");
		scanf("%d",&delete_pos);
	}while(delete_pos<1||delete_pos>length_list(L,Lb)+1);
	delete_listelem(L,Lb,delete_pos);

	traverse_list(L,Lb);

	printf("Lc表是否为空?%d(1:空 0:否)\n",empty_list(L,Lc));
	printf("Lc表的表长=%d\n",length_list(L,Lc));
//	union_list(L,La,Lb,Lc);
	merge_list(L,La,Lb,Lc);

	sort_list(L,Lc);

	write_list(L,Lc);

	read_list(L,Lc);

	traverse_list(L,Lc);
}

void init_space(SLinklist L)
{
	for(int i=0;i<MAXSIZE-1;i++)
	{
		L[i].cur = i+1;
	}
	L[MAXSIZE-1].cur = 0;
}

int init_list(SLinklist L)
{
	int j = malloc(L);
	L[j].cur = 0;
	return j;
}

int malloc(SLinklist L)
{
	int i = L[0].cur;
	L[0].cur = L[i].cur;
	return i;
}

void free(SLinklist L,int n)
{
	L[n].cur = L[0].cur;
	L[0].cur = n;
}

bool empty_list(SLinklist L,int n)
{
	if(L[n].cur == 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}

int length_list(SLinklist L,int n)
{
	int i=0;
	while(L[n].cur != 0)
	{
		n = L[n].cur;
		i++;
	}
	return i;
}

void insert_list(SLinklist L,int n,int i,int e)
{
	int j,w,k=n;
	if(i<1||i>length_list(L,n)+1)
	{
		printf("插入不在范围!");
		exit(-1);
	}
	else
	{
		j = malloc(L);
		if(j)
		{
			L[j].num = e;
			for(w=1;w<i;w++)
			{
				k = L[k].cur;
			}
			L[j].cur = L[k].cur;
			L[k].cur = j;
		}
	}
}

void traverse_list(SLinklist L,int n)
{
	int i = L[n].cur;
	while(i)
	{
		printf("%d ",L[i].num);
		i = L[i].cur;
	}
	printf("\n");
}

void get_listelem(SLinklist L,int n,int pos)
{
	if(empty_list(L,n))
	{
		printf("\n链表为空!");
		exit(-1);
	}
	else
	{
		for(int i=0;i<pos;i++)
		{
			n = L[n].cur;
		}
		printf("编号对应的数字为 num = %d\n",L[n].num);
	}
}

void delete_listelem(SLinklist L,int n,int pos)
{
	int k;
	if(empty_list(L,n))
	{
		printf("\n链表为空!");
		exit(-1);
	}
	else
	{
		for(int i=0;i<pos-1;i++)
		{
			n = L[n].cur;
		}
		k = L[n].cur;
		L[n].cur = L[k].cur;
		free(L,k);
	}
}

void union_list(SLinklist L,int La,int Lb,int Lc)
{
	int insert_num,n=La,m=Lb;
	for(int i=1;i<length_list(L,La)+1;i++)
	{
		n = L[n].cur;
		insert_list(L,Lc,i,L[n].num);
	}
	for(i=1;i<length_list(L,Lb)+1;i++)
	{	
		m = L[m].cur;
		if(cmp_list(L,L[m].num,La))
		{
			insert_list(L,Lc,1,L[m].num);
		}
	}
}

void merge_list(SLinklist L,int La,int Lb,int Lc)
{
	int insert_num,n=La,m=Lb;
	for(int i=1;i<length_list(L,La)+1;i++)
	{
		n = L[n].cur;
		insert_list(L,Lc,i,L[n].num);
	}
	for(i=1;i<length_list(L,Lb)+1;i++)
	{
		m = L[m].cur;
		insert_list(L,Lc,1,L[m].num);
	}
}

void sort_list(SLinklist L,int n)
{
	int k,w;
	for(int i=0;i<length_list(L,n)-1;i++)
	{
		int m = n;
		do
		{
			if(L[m].num > L[L[m].cur].num)
			{
				w = L[m].num;
				L[m].num = L[L[m].cur].num;
				L[L[m].cur].num = w;
			}
			m = L[m].cur;
		}while(L[m].cur != 0);
	}
}

bool cmp_list(SLinklist L,int Lb_num,int La)
{
	int n = L[La].cur,i=0;
	while(L[n].num != Lb_num && i<length_list(L,La)+1)
	{
		n = L[n].cur;
		i++;
	}
	if(i>=length_list(L,La)+1)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void write_list(SLinklist L,int n)
{
	FILE *fp;
	int k = n;
	if((fp = fopen("D:/VC++6.0【win10可用】/VC++6.0/MyProjects/静态链表/text.txt","w+")) == NULL)
	{
		printf("文件打开失败!\n");
		exit(-1);
	}
	else
	{
		n = L[n].cur;
		for(int i=1;i<length_list(L,k)+1;i++)
		{
			printf("向文档里插入的数字为%d\n",L[n].num);
			fprintf(fp,"%d\n",L[n].num);
			n = L[n].cur;
		}
	}
	fclose(fp);
}

void read_list(SLinklist L,int n)
{
	FILE *fp;
	int k = n , num;
	if((fp = fopen("D:/VC++6.0【win10可用】/VC++6.0/MyProjects/静态链表/text.txt","r")) == NULL)
	{
		printf("文件打开失败!\n");
		exit(-1);
	}
	else
	{
		for(int i=1;i<length_list(L,k)+1;i++)
		{
			fscanf(fp,"%d",&num);
			printf("->%d",num);
		}
		printf("\n");
	}
}

void claer_list(SLinklist L,int n)
{
	int j,k,i=L[n].cur;
	L[n].cur = 0;
	k = L[0].cur;
	L[0].cur = i;
	while(i)
	{
		j = i;
		i = L[i].cur;
	}
	L[j].cur = k;
	printf("\n");
}

循环链表
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	int data;
	struct Node *pNext;
}Node,*pNode;

pNode init_struct();
pNode build_struct(pNode pTail);
void traverse_struct(pNode pTail);
pNode ListInsert(pNode pTail,int pos,int data);
void getelem_struct(pNode pTail);
void findpos_strcut(pNode pTail);
pNode merge_struct(pNode pTail,pNode pTail1);
pNode union_struct(pNode pTail,pNode pTail1);
void sort_struct(pNode pTail);
void write_file(pNode pTail);
void read_file(pNode pTail);

int length_struct(pNode pTail);
bool empty(pNode pTail);

void main()
{
	int pos,data;
	pNode pTail = NULL,pTail1 = NULL;
	pTail = init_struct();
	pTail = build_struct(pTail);

//	printf("请输入要插入的节点位置 pos = ");
//	scanf("%d",&pos);
//	printf("请输入要插入的节点数值 val = ");
//	scanf("%d",&data);
//	pTail = ListInsert(pTail,pos,data);
//	getelem_struct(pTail);
//	findpos_strcut(pTail);
	pTail1 = init_struct();
	pTail1 = build_struct(pTail1);
//	merge_struct(pTail,pTail1);
    pTail = union_struct(pTail,pTail1);
	sort_struct(pTail);
	write_file(pTail);
	read_file(pTail);
	traverse_struct(pTail);
}

pNode init_struct()
{
	pNode pTail = (pNode)malloc(sizeof(Node));
	if(pTail == NULL)
	{
		printf("尾指针建立失败!\n");
		exit(-1);
	}
	else
	{
		pTail->pNext = pTail;
	}
	return pTail;
}

pNode build_struct(pNode pTail)
{
	int len;
	printf("请输入建立节点的个数 len = ");
	scanf("%d",&len);
	for(int i=0;i<len;i++)
	{
		pNode pNew = (pNode)malloc(sizeof(Node));
		printf("请输入新建节点的值 val = ");
		scanf("%d",&pNew->data);
		if(pNew == NULL)
		{
			printf("新表建立失败!\n");
			exit(-1);
		}
		else
		{
			pNew->pNext = pTail->pNext;
			pTail->pNext = pNew;
			pTail = pNew;
		}
	}
	return pTail;
}

pNode ListInsert(pNode pTail,int pos,int data)
{
	int j=0;
	if(pos<1||pos>length_struct(pTail)+2)
	{
		printf("超出插入范围!");
		exit(-1);
	}
	else
	{
		if(pos<=length_struct(pTail)+1 && pos>=1)
		{
			pNode p = pTail->pNext;
			while(j<pos-1)
			{
				p = p->pNext;
				j++;
			}
			pNode pNew = (pNode)malloc(sizeof(Node));
			pNew->data = data;
			pNew->pNext = p->pNext;
			p->pNext = pNew;
		}
		else
		{
			pNode pNew = (pNode)malloc(sizeof(Node));
			pNew->data = data;
			pNew->pNext = pTail->pNext;
			pTail->pNext = pNew;
			pTail = pNew;
		}
	}
	return pTail;
}

void getelem_struct(pNode pTail)
{
	int pos,j=0;
	pNode p = pTail->pNext;
	printf("请输入要查找的节点位置 pos = ");
	scanf("%d",&pos);
	if(pos<1||pos>length_struct(pTail)+1)
	{
		printf("超出插入范围!");
		exit(-1);
	}
	else
	{
		while(j<pos)
		{
			p = p->pNext;
			j++;
		}
		printf("查找结点的数值为 val = %d\n",p->data);
	}
}

void findpos_strcut(pNode pTail)
{
	int elemval,j=1;
	pNode p = pTail->pNext,q = p->pNext;
	printf("请输入要查找的数值 elemval = ");
	scanf("%d",&elemval);
	while(p != pTail && elemval != q->data )
	{
		p = p->pNext;
		q = p->pNext;
		j++;
	}
	if(p == pTail)
	{
		printf("不存在要查找的数值!\n");
		exit(-1);
	}
	else
	{
		printf("要查找数字的位置为 pos = %d\n",j);
	}
}

pNode merge_struct(pNode pTail,pNode pTail1)
{
	pNode q = pTail1->pNext;
	pTail1->pNext = pTail->pNext->pNext;
	pTail->pNext->pNext = q->pNext;
	free(q);
	pTail = pTail1;
	return pTail;
}

pNode union_struct(pNode pTail,pNode pTail1)
{
	printf("->%d\n",length_struct(pTail1));
	pNode p1 = pTail1->pNext->pNext;
	for(int i=1;i<=length_struct(pTail1)+1;i++)
	{
		int j=1;
		pNode p = pTail->pNext,q = p->pNext;
		while(p != pTail && p1->data != q->data)
		{
			p = p->pNext;
			q = p->pNext;
			j++;
		}
		printf("%d \n",j);
		if(j>length_struct(pTail)+1)
		{
			pTail = ListInsert(pTail,length_struct(pTail)+2,p1->data);
		}
		p1 = p1->pNext;
	}
	return pTail;
}

void sort_struct(pNode pTail)
{
	int swap;
	for(int i=0;i<length_struct(pTail);i++)
	{
		pNode p = pTail->pNext->pNext;
		for(int j=0;j<length_struct(pTail)-i;j++)
		{
			if(p->data > p->pNext->data)
			{
				swap = p->data;
				p->data = p->pNext->data;
				p->pNext->data = swap;
			}
			p = p->pNext;
		}
	}
}

void write_file(pNode pTail)
{
	FILE *fp;

	if((fp = fopen("D:/VC++6.0【win10可用】/VC++6.0/MyProjects/text.txt","w+")) == NULL)
	{
		printf("文件打开失败!\n");
		exit(-1);
	}
	else
	{
		pNode p = pTail->pNext,q = p->pNext;
		fprintf(fp,"%d\n",length_struct(pTail)+1);
		do
		{
			fprintf(fp,"%d\n",q->data);
			p = p->pNext;
			q = p->pNext;
		}while(p != pTail);
		fclose(fp);
	}
}

void read_file(pNode pTail)
{
	FILE *fp;

	if((fp = fopen("D:/VC++6.0【win10可用】/VC++6.0/MyProjects/text.txt","r")) == NULL)
	{
		printf("文件打开失败!\n");
		exit(-1);
	}
	else
	{
		int data,total;
		fscanf(fp,"%d",&total);
		printf("文件中数字总数为: %d\n",total);
		for(int i=0;i<length_struct(pTail)+1;i++)
		{
			fscanf(fp,"%d",&data);
			printf("%d\n",data);
		}
	}
}

void traverse_struct(pNode pTail)
{
	if(empty(pTail))
	{
		printf("链表为空!\n");
		exit(-1);
	}
	else
	{
		pNode p = pTail->pNext->pNext;
		for(int i=0;i<length_struct(pTail)+1;i++)
		{
			printf("%d ",p->data);
			p = p->pNext;
		}
	}
}

int length_struct(pNode pTail)
{
	int i=0;
	pNode p = pTail->pNext;
	while(p->pNext != pTail)
	{
		i++;
		p = p->pNext;
	}
	return i;
}

bool empty(pNode pTail)
{
	if(pTail->pNext == pTail)
	{
		return true;
	}
	else
	{
		return false;
	}
}

双向链表
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	struct Node* pNext;
	struct Node* pbefore;
	int data;
}Node,*pNode;

pNode init_struct();
void build_struct(pNode pHead);
void traverse_struct(pNode pHead);
int length_struct(pNode pHead);
int findpos_struct(pNode pHead,int elem);
int findelem_struct(pNode pHead,int pos);
void sort_struct(pNode pHead);
void merge_struct(pNode pHead,pNode pHead1);
void union_struct(pNode pHead,pNode pHead1);
void insert_struct(pNode pHead,int pos,int elem);
void delete_struct(pNode pHead,int pos);
void clear_struct(pNode pHead);
void write_struct(pNode pHead);
void read_struct(pNode pHead);

bool empty(pNode pHead);

void main()
{
	int findelem,pos,findpos,elem,insert_pos,insert_elem,delete_pos;
	pNode pHead = NULL;
//	pNode pHead1 = NULL;
	pHead = init_struct();
//	pHead1 = init_struct();
	build_struct(pHead);
//	build_struct(pHead1);
//	union_struct(pHead,pHead1);
//	merge_struct(pHead,pHead1);
//	sort_struct(pHead);
//	clear_struct(pHead);
	write_struct(pHead);
	read_struct(pHead);

/*
	printf("请输入删除的位置:");
	scanf("%d",&delete_pos);
	delete_struct(pHead,delete_pos);

	printf("请输入插入的位置:");
	scanf("%d",&insert_pos);
	printf("请输入插入的数字:");
	scanf("%d",&insert_elem);
	insert_struct(pHead,insert_pos,insert_elem);

	printf("请输入要查找的元素:");
	scanf("%d",&findelem);
	pos = findpos_struct(pHead,findelem);
	printf("对应位置为:%d\n",pos);

	printf("请输入要查找的位置:");
	scanf("%d",&findpos);
	elem = findelem_struct(pHead,findpos);
	printf("对应元素为:%d",elem);
*/
	traverse_struct(pHead);
}

pNode init_struct()
{
	pNode pHead = (pNode)malloc(sizeof(Node));
	if(pHead == NULL)
	{
		printf("表头建立失败!\n");
		exit(-1);
	}
	pHead->pbefore = pHead;
	pHead->pNext = pHead;
	return pHead;
}

void build_struct(pNode pHead)
{
	int len,num;
	printf("请输入建立链表的长度 = ");
	scanf("%d",&len);
	pNode p = pHead;
	for(int i=0;i<len;i++)
	{
		pNode pNew = (pNode)malloc(sizeof(Node));
		printf("请输入新建节点的数值 = ");
		scanf("%d",&num);
		pNew->data = num;
		p->pNext = pNew;
		pNew->pNext = pHead;
		pNew->pbefore = p;
		p = pNew;
		pHead->pbefore = pNew;
	}
}

int length_struct(pNode pHead)
{
	if(empty(pHead))
	{
		printf("链表为空!");
		exit(-1);
	}
	else
	{
		int j = 1;
		pNode p = pHead->pNext;
		while(p->pNext != pHead)
		{
			j++;
			p = p->pNext;
		}
		return j;
	}
}

int findpos_struct(pNode pHead,int elem)
{
	if(empty(pHead))
	{
		printf("链表为空,没有对应元素!");
		exit(-1);
	}
	else
	{
		int j = 1;
		pNode p = pHead->pNext;
		while(p != pHead && elem != p->data)
		{
			j++;
			p = p->pNext;
		}
		if(j>length_struct(pHead))
		{
			printf("没有对应元素!\n");
		}
		else
		{
			return j;
		}
	}
}

int findelem_struct(pNode pHead,int pos)
{
	if(empty(pHead))
	{
		printf("链表为空,没有对应元素!");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNext;
		for(int i=1;i<pos;i++)
		{
			p = p->pNext;
		}
		return p->data;
	}
}

void insert_struct(pNode pHead,int pos,int elem)
{
	if(pos<1 && pos>length_struct(pHead)+1)
	{
		printf("插入不在范围!\n");
		exit(-1);
	}
	else
	{
		pNode pNew = (pNode)malloc(sizeof(Node));
		pNew->data = elem;
		pNode ptemp = pHead;
		for(int i=0;i<pos-1;i++)
		{
			ptemp = ptemp->pNext;
		}
			pNew->pbefore = ptemp;
			pNew->pNext = ptemp->pNext;
			ptemp->pNext->pbefore = pNew;
			ptemp->pNext = pNew;
	}
}

void delete_struct(pNode pHead,int pos)
{
	if(pos<1 && pos>length_struct(pHead))
	{
		printf("删除不在范围!\n");
		exit(-1);
	}
	else
	{
		pNode ptemp = pHead;
		for(int i=0;i<pos-1;i++)
		{
			ptemp = ptemp->pNext;
		}
		pNode qtemp = ptemp->pNext;
		qtemp->pNext->pbefore = ptemp;
		ptemp->pNext = qtemp->pNext;
		free(qtemp);
	}
}

void clear_struct(pNode pHead)
{
	pNode q,p = pHead->pNext;
	while(p != pHead)
	{
		q = p->pNext;
		free(p);
		p = q;
	}
	pHead->pbefore = pHead;
	pHead->pNext = pHead;
}

void sort_struct(pNode pHead)
{
	int swap,i,j;
	for(i=0;i<length_struct(pHead)-1;i++)
	{
		pNode p = pHead->pNext;
		for(j=0;j<length_struct(pHead)-i-1;j++)
		{
			if(p->data > p->pNext->data)
			{
				swap = p->data;
				p->data = p->pNext->data;
				p->pNext->data = swap;
				p = p->pNext;
			}
		}
	}
}

void merge_struct(pNode pHead,pNode pHead1)
{
	pNode p = pHead->pNext;
	while(p->pNext != pHead)
	{
		p = p->pNext;
	}
	pNode p1 = pHead1->pNext;
	pNode p2 = pHead1->pbefore;
	p->pNext = p1;
	p->pbefore = p2;
	p->pbefore->pNext = pHead;
}


void union_struct(pNode pHead,pNode pHead1)
{
	pNode p1 = pHead1->pNext;
	while(p1 != pHead1)
	{
		pNode p = pHead->pNext;
		while(p != pHead && p1->data != p->data)
		{
			p = p->pNext;
		}
		if(p == pHead)
		{
			insert_struct(pHead,length_struct(pHead)+1,p1->data);
		}
		p1 = p1->pNext;
	}
}

void write_struct(pNode pHead)
{
	FILE *fp;

	if((fp = fopen("D:/VC++6.0【win10可用】/VC++6.0/MyProjects/text.txt","w+")) == NULL)
	{
		printf("文件打开失败!\n");
		exit(-1);
	}
	else
	{
		fprintf(fp,"%d\n",length_struct(pHead));
		pNode p = pHead->pNext;
		for(int i=0;i<length_struct(pHead);i++)
		{
			fprintf(fp,"%d\n",p->data);
			p = p->pNext;
		}
		fclose(fp);
	}
}

void read_struct(pNode pHead)
{
	FILE *fp;

	if((fp = fopen("D:/VC++6.0【win10可用】/VC++6.0/MyProjects/text.txt","r")) == NULL)
	{
		printf("文件打开失败!\n");
		exit(-1);
	}
	else
	{
		int total,num;
		fscanf(fp,"%d",&total);
		printf("链表有效节点个数为:%d\n",total);
		for(int i=0;i<length_struct(pHead);i++)
		{
			fscanf(fp,"%d",&num);
			printf("->%d",num);
		}
		fclose(fp);
	}
	printf("\n");
}

void traverse_struct(pNode pHead)
{
	if(empty(pHead))
	{
		printf("链表为空!\n");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNext;
		do
		{
			printf("->%d",p->data);
			p = p->pNext;
		}while(p != pHead);
	}
	printf("\n");
}

bool empty(pNode pHead)
{
	if(pHead->pNext == pHead)
	{
		return true;
	}
	else
	{
		return false;
	}
}

重新定义的链表
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	int data;
	struct Node* pNext;
}Node,*pNode;

struct LinkList
{
	int len;
	struct Node* pNodeHead;
	struct Node* pNodeTail;
};

struct LinkList* init_struct();
void build_list(LinkList* pHead);
void traverse_list(LinkList* pHead);
int length_list(LinkList* pHead);
void insert_list(LinkList* pHead,int pos,int elem);
void delete_list(LinkList* pHead,int pos);
void clear_list(LinkList* pHead);
void findelem_list(LinkList* pHead,int pos);
void findpos_list(LinkList* pHead,int elem);
void merge_list(LinkList* pHead,LinkList* pHead1);
void union_list(LinkList* pHead,LinkList* pHead1);
void write_list(LinkList* pHead);
void read_list(LinkList* pHead);

bool empty(LinkList* pHead);

void main()
{
	int insert_pos,insert_elem,delete_pos,delete_elem,find_pos,find_elem;
	LinkList *pHead,*pHead1;
	pHead = init_struct();
//	pHead1 = init_struct();
	build_list(pHead);
//	build_list(pHead1);
/*
	printf("请输入要插入数的位置:");
	scanf("%d",&insert_pos);
	printf("请输入要插入数的数值:");
	scanf("%d",&insert_elem);
	insert_list(pHead,insert_pos,insert_elem);

	printf("请输入要删除数的位置:");
	scanf("%d",&delete_pos);
	delete_list(pHead,delete_pos);

	printf("请输入要找的位置:");
	scanf("%d",&find_pos);
	findelem_list(pHead,find_pos);
	
	printf("请输入要找的数字:");
	scanf("%d",&find_elem);
	findpos_list(pHead,find_elem);
*/

//	merge_list(pHead,pHead1);
//	union_list(pHead,pHead1);

//	clear_list(pHead);

	write_list(pHead);
	read_list(pHead);

//	traverse_list(pHead);
}

struct LinkList* init_struct()
{
	LinkList* TempPhead = (LinkList*)malloc(sizeof(LinkList));
	pNode pfirst = (pNode)malloc(sizeof(Node));
	if(TempPhead == NULL || pfirst == NULL)
	{
		printf("表头类型失败!\n");
		exit(-1);
	}
	else
	{
		TempPhead->pNodeHead = pfirst;
		TempPhead->pNodeTail = pfirst;
		TempPhead->len = 0;
		pfirst->pNext = NULL;
	}
	return TempPhead;
}

void build_list(LinkList* pHead)
{
	int len,num;
	printf("请输入要建立链表的长度:");
	scanf("%d",&len);
	pNode p = pHead->pNodeHead;
	for(int i=0;i<len;i++)
	{
		pNode pNew = (pNode)malloc(sizeof(Node));
		if(pNew == NULL)
		{
			printf("链表建立失败!\n");
			exit(-1);
		}
		else
		{
			printf("请输入插入的数:");
			scanf("%d",&num);
			pNew->data = num;
			pNew->pNext = NULL;
			p->pNext = pNew;
			pHead->pNodeTail = pNew;
		}
		p = pNew;
	}
	pHead->len = len;
}

void insert_list(LinkList* pHead,int pos,int elem)
{
	if(pos<1 && pos>length_list(pHead)+1)
	{
		printf("插入超出范围!\n");
		exit(-1);
	}
	else
	{
		int j=0;
		pNode p = pHead->pNodeHead;
		while(j<pos-1)
		{
			p = p->pNext;
			j++;
		}
		pNode pNew = (pNode)malloc(sizeof(Node));
		pNew->data = elem;
		pNew->pNext = p->pNext;
		p->pNext = pNew;
		if(p == pHead->pNodeTail)
		{
			pHead->pNodeTail = pNew;
		}
		pHead->len++;
	}
}

void delete_list(LinkList* pHead,int pos)
{
	if(pos<1 && pos>length_list(pHead))
	{
		printf("删除超出范围!\n");
		exit(-1);
	}
	else
	{
		int j=0;
		pNode p = pHead->pNodeHead;
		while(j<pos-1)
		{
			p = p->pNext;
			j++;
		}
		pNode q = p->pNext;
		p->pNext = p->pNext->pNext;
		free(q);
		pHead->len--;
	}	
}

void clear_list(LinkList* pHead)
{
	if(empty(pHead))
	{
		printf("链表为空!");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNodeHead->pNext,p;
		while(p)
		{
			q = p->pNext;
			free(q);
			p = q;
		}
		pHead->pNodeTail = pHead->pNodeHead;
		pHead->len = 0;
	}
}

void findelem_list(LinkList* pHead,int pos)
{
	pNode p = pHead->pNodeHead->pNext;
	for(int i=1;i<pos;i++)
	{
		p = p->pNext;
	}
	printf("第%d位置的数是%d\n",pos,p->data);
}

void findpos_list(LinkList* pHead,int elem)
{
	pNode p = pHead->pNodeHead->pNext;
	int j = 1;
	while(p && p->data != elem)
	{
		p = p->pNext;
		j++;
	}
	printf("要找的数字的位置为%d:\n",j);
}

void merge_list(LinkList* pHead,LinkList* pHead1)
{
	pHead->pNodeTail->pNext = pHead1->pNodeHead->pNext;
	pHead->pNodeTail = pHead1->pNodeTail;
	pHead->len = pHead->len + pHead1->len;
	free(pHead1->pNodeHead);
	free(pHead1);
}

void union_list(LinkList* pHead,LinkList* pHead1)
{
	pNode p1 = pHead1->pNodeHead->pNext;
	while(p1)
	{
		pNode p = pHead->pNodeHead->pNext;
		while(p && p->data != p1->data)
		{
			p = p->pNext;
		}
		if(p == NULL)
		{
			insert_list(pHead,length_list(pHead)+1,p1->data);
		}
		p1 = p1->pNext;
	}
}

void write_list(LinkList* pHead)
{
	FILE *fp;

	if((fp = fopen("D:/VC++6.0【win10可用】/VC++6.0/MyProjects/text.txt","w+")) == NULL)
	{
		printf("文件代开失败!\n");
		exit(-1);
	}
	else
	{
		fprintf(fp,"%d\n",pHead->len);
		pNode p = pHead->pNodeHead->pNext;
		for(int i=0;i<pHead->len;i++)
		{
			fprintf(fp,"%d\n",p->data);
			p = p->pNext;
		}
		fclose(fp);
	}
}

void read_list(LinkList* pHead)
{
	FILE *fp;

	if((fp = fopen("D:/VC++6.0【win10可用】/VC++6.0/MyProjects/text.txt","r")) == NULL)
	{
		printf("文件代开失败!\n");
		exit(-1);
	}
	else
	{
		int total,num;
		fscanf(fp,"%d",&total);
		printf("total = %d\n",total);
		for(int i=0;i<pHead->len;i++)
		{
			fscanf(fp,"%d",&num);
			printf("->%d",num);
		}
		fclose(fp);
	}
	printf("\n");
}

int length_list(LinkList* pHead)
{
	int i=1;
	pNode p = pHead->pNodeHead->pNext;
	while(p != pHead->pNodeTail)
	{
		p = p->pNext;
		i++;
	}
	return i;
}

void traverse_list(LinkList* pHead)
{
	if(empty(pHead))
	{
		printf("链表为空!");
		exit(-1);
	}
	else
	{
		pNode p = pHead->pNodeHead->pNext;
		for(int i=0;i<length_list(pHead);i++)
		{
			printf("->%d",p->data);
			p = p->pNext;
		}
	}
}

bool empty(LinkList* pHead)
{
	if(pHead->pNodeHead == pHead->pNodeTail)
	{
		return true;
	}
	else
	{
		return false;
	}
}

一元多项式的表达及相加
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <math.h>

typedef struct DataType
{
	float coef;
	int expn;
}elemType;

typedef struct List
{
	struct DataType data;
	struct List *pPrior;
	struct List *pNext;
}List,*pList;

pList init_List();
void create_List(pList pHead);
int length_List(pList pHead);
void traverse_List(pList pHead);
double getvalue_List(pList pHead);
void clear_List(pList pHead);
void lastadd_List(pList pHead,float coef,int expn);
void delete_List(pList pHead,int pos);
void add_List(pList pHead,pList pHead1);
void sub_List(pList pHead,pList pHead1);
void mul_List(pList pHead,pList pHead1);
void div_List(pList pHead,pList pHead1);

bool empty(pList pHead);

void main()
{
	int m,expn,pos,i;
	float coef;
	pList pHead = NULL,pHead1 = NULL;
	pHead = init_List();
	create_List(pHead);
	pHead1 = init_List();
	create_List(pHead1);
/*
	printf("请输入插入last的系数和指数:");
	scanf("%f %d",&coef,&expn);
	lastadd_List(pHead,coef,expn);
	traverse_List(pHead);

	printf("请输入要删除数字的位置 pos=");
	scanf("%d",&pos);
	delete_List(pHead,pos);
	traverse_List(pHead);

	add_List(pHead,pHead1);
	sub_List(pHead,pHead1);*/
	mul_List(pHead,pHead1);
//	div_List(pHead,pHead1);
}

pList init_List()
{
	pList pHead = (pList)malloc(sizeof(List));
	if(pHead == NULL)
	{
		printf("建表失败!\n");
		exit(-1);
	}
	else
	{
		pHead->pNext = pHead;
		pHead->pPrior = pHead;
	}
	return pHead;
}

void create_List(pList pHead)
{
	float coef;
	int m,expn;
	pList ptemp = pHead;
	printf("请输入多项式的项数:");
	scanf("%d",&m);
	for(int i=0;i<m;i++)
	{
		pList pNew = (pList)malloc(sizeof(List));
		printf("请输入第%d的系数和指数:",i+1);
		scanf("%f %d",&coef,&expn);
		pNew->data.coef = coef;
		pNew->data.expn = expn;
		ptemp->pNext = pNew;
		pNew->pNext = pHead;
		pNew->pPrior = ptemp;
		ptemp = pNew;
	}
	pHead->pPrior = ptemp;
}

int length_List(pList pHead)
{
	int i = 1;
	pList p = pHead->pNext;
	while(p != pHead->pPrior)
	{
		p = p->pNext;
		i++;
	}
	return i;
}

void traverse_List(pList pHead)
{
	if(empty(pHead))
	{
		printf("多项式为空!");
		exit(-1);
	}
	else
	{
		pList p = pHead->pNext;
		for(int i=0;i<length_List(pHead);i++)
		{
			if(p->data.coef>=0)
			{
				printf("%.2f*x^%d",p->data.coef,p->data.expn);
			}
			else
			{
				printf("(%.2f)*x^%d",p->data.coef,p->data.expn);
			}
			p = p->pNext;
			if(i != length_List(pHead)-1)
			{
				printf("+");
			}
		}
	}
}

double getvalue_List(pList pHead)
{
	double sum = 0;
	double x;
	printf("\n");
	pList p = pHead->pNext;
	for(int i=0;i<length_List(pHead);i++)
	{
		printf("请输入带入参数x = ");
		scanf("%lf",&x);
		sum = sum + p->data.coef*pow(x,p->data.expn);
		p = p->pNext;
	}
	return sum;
}

void add_List(pList pHead,pList pHead1)
{
	pList p1 = pHead1->pNext;
	while(p1 != pHead1)
	{
		pList p = pHead->pNext,q;
		while(p != pHead && p->data.expn != p1->data.expn)
		{
			p = p->pNext;
		}
		q = p1->pNext;
		if(p->data.expn == p1->data.expn)
		{
			p->data.coef = p->data.coef + p1->data.coef;
		}
		else
		{
			lastadd_List(pHead,p1->data.coef,p1->data.expn);
		}
		free(p1);
		p1 = q;
	}
	traverse_List(pHead);
	printf("%lf",getvalue_List(pHead));
}

void sub_List(pList pHead,pList pHead1)
{
	pList p1 = pHead1->pNext;
	while(p1 != pHead1)
	{
		pList p = pHead->pNext,q;
		while(p != pHead && p->data.expn != p1->data.expn)
		{
			p = p->pNext;
		}
		q = p1->pNext;
		if(p->data.expn == p1->data.expn)
		{
			p->data.coef = p->data.coef - p1->data.coef;
		}
		else
		{
			lastadd_List(pHead,-(p1->data.coef),p1->data.expn);
		}
		free(p1);
		p1 = q;
	}
	traverse_List(pHead);
	printf("%lf",getvalue_List(pHead));
}

void mul_List(pList pHead,pList pHead1)
{
	double sum;
	float coef;
	int expn;
	printf("[");
	traverse_List(pHead);
	printf("]*[");
	traverse_List(pHead);
	printf("]");
	printf("=");

	int i=0;
	pList pHead2;
	pHead2 = init_List();
//	create_List(pHead2);
	pList p1 = pHead1->pNext,p2;
	while(p1 != pHead1)
	{
		pList p = pHead->pNext,q;
		while(p != pHead)
		{
			coef = p->data.coef*p1->data.coef;
			expn = p->data.expn+p1->data.expn;
			p2 = pHead2->pNext;
			while(i<length_List(pHead2) && p2->data.expn != expn)
			{
				p2 = p2->pNext;
				i++;
			}
			if(expn == p2->data.expn)
			{
				p2->data.coef = p2->data.coef + coef;
			}
			else
			{
				lastadd_List(pHead2,coef,expn);
			}
			p = p->pNext;
		}
		q = p1->pNext;
		free(p1);
		p1 = q;
	}
	traverse_List(pHead2);
	sum = getvalue_List(pHead2);
	printf("%lf",sum);
}

void div_List(pList pHead,pList pHead1)
{
	double sum;
	printf("[");
	traverse_List(pHead);
	printf("]/[");
	traverse_List(pHead);
	printf("]");
	sum = getvalue_List(pHead)*getvalue_List(pHead1);
	printf("%lf",sum);
}

void lastadd_List(pList pHead,float coef,int expn)
{
	pList p = pHead->pPrior;
	pList pNew = (pList)malloc(sizeof(List));
	pNew->data.coef = coef;
	pNew->data.expn = expn;
	p->pNext = pNew;
	pNew->pPrior = p;
	pNew->pNext = pHead;
	pHead->pPrior = pNew;
}

void clear_List(pList pHead)
{
	pList p = pHead->pNext,q;
	while(p->pNext != pHead)
	{
		q = p->pNext;
		free(p);
		p = q;
	}
}

void delete_List(pList pHead,int pos)
{
	if(pos<1 || pos>length_List(pHead))
	{
		printf("删除不在范围!");
		exit(-1);
	}
	else
	{
		int i=1;
		pList p = pHead->pNext;
		while(i<pos-1)
		{
			i++;
			p = p->pNext;
		}
		pList q = p->pNext;
		p->pNext = q->pNext;
		q->pNext->pPrior = p;
		free(q);
	}
}

bool empty(pList pHead)
{
	if(pHead->pNext == pHead)
	{
		return true;
	}
	else
	{
		return false;
	}
}

栈的实现及表示
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#define STACK_INIT_SIZE 10
#define STACKINCREMENT 2

typedef struct stack
{
	int *top;
	int *bottom;
	int stacksize;
}Stack,*pStack;

void init_Stack(pStack ST);
void push_Stack(pStack ST,int num);
void traverse_Stack(pStack ST);
void pop_Stack(pStack ST);
void destroy_Stack(pStack ST);
void clear_Stack(pStack ST);

bool empty(pStack ST);

void main()
{
	int push_total,pop_total,num;
	pStack ST = (pStack)malloc(sizeof(Stack));
	if(ST == NULL)
	{
		printf("动态内存分配失败!");
		exit(-1);
	}
	init_Stack(ST);
	printf("请输入要入栈的个数 push_total = ");
	scanf("%d",&push_total);
	for(int i=0;i<push_total;i++)
	{
		printf("请输入入栈的数字 num = ");
		scanf("%d",&num);
		push_Stack(ST,num);
	}

	printf("请输入要出栈的个数 pop_total = ");
	scanf("%d",&pop_total);
	for(i=0;i<pop_total;i++)
	{
		pop_Stack(ST);
	}

	destroy_Stack(ST);

	traverse_Stack(ST);
}

void init_Stack(pStack ST)
{
	ST->bottom = (int*)malloc(STACK_INIT_SIZE*sizeof(int));
	if(ST->bottom == NULL)
	{
		printf("栈的头地址创建失败!");
		exit(-1);
	}
	else
	{
		ST->top = ST->bottom;
		ST->stacksize = STACK_INIT_SIZE;
	}
}

void push_Stack(pStack ST,int num)
{
	if(ST->top-ST->bottom>=ST->stacksize)
	{
		ST->bottom = (int*)realloc(ST->bottom,(ST->stacksize+STACKINCREMENT)*sizeof(int));
		if(ST->bottom == NULL)
		{
			printf("动态内存分配失败!");
			exit(-1);
		}
		ST->top = ST->bottom + ST->stacksize;
		ST->stacksize = ST->stacksize + STACKINCREMENT;
	}
	*(ST->top)++ = num;					//这一步分解就是*(ST->top) = num;    ST->top++;
}

void pop_Stack(pStack ST)
{
	if(empty(ST))
	{
		printf("栈为空，无法出栈!\n");
		exit(-1);
	}
	else
	{
		printf("->%d",*(ST->top-1));
		ST->top--;
	}
}

void destroy_Stack(pStack ST)
{
	free(ST->bottom);
	ST->bottom = NULL;
	ST->top = NULL;
	ST->stacksize = 0;
}

void clear_Stack(pStack ST)	//设置成空栈
{
	ST->top = ST->bottom;
}

void traverse_Stack(pStack ST)
{
	int* ptemp = ST->bottom;
	while(ptemp != ST->top)
	{
		printf("->%d",*ptemp);
		ptemp++;
	}
	printf("\n");
}

bool empty(pStack ST)
{
	if(ST->bottom == ST->top)
	{
		return true;
	}
	else
	{
		return false;
	}
}

链栈
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	struct Node *pNext;
	int data;
}Node,*pNode;

typedef struct stack
{
	pNode bottom;
	pNode top;
}Stack,*pStack;

void init_Stack(pStack ST);
void build_Stack(pStack ST);
void traverse_Stack(pStack ST);
void push_Stack(pStack ST,int push_num);
void pop_Stack(pStack ST);
void clear_Stack(pStack ST);
void destroy_Stack(pStack ST);
int length_Stack(pStack ST);

bool empty(pStack ST);

void main()
{
	int push_num,total;
	pStack ST = (pStack)malloc(sizeof(Stack));
	init_Stack(ST);
	build_Stack(ST);

	printf("请输入要入栈总数 total = ");
	scanf("%d",&total);
	for(int i=0;i<total;i++)
	{
		printf("请输入要入栈的数 push_num = ");
		scanf("%d",&push_num);
		push_Stack(ST,push_num);
	}


	printf("请输入要出栈总数 total = ");
	scanf("%d",&total);
	for(i=0;i<total;i++)
	{
		pop_Stack(ST);
	}
	printf("\n");

//	clear_Stack(ST);
//	destroy_Stack(ST);

	traverse_Stack(ST);

	printf("\n%d",length_Stack(ST));
}

void init_Stack(pStack ST)
{
	pNode pStack_Head = (pNode)malloc(sizeof(Node));
	if(pStack_Head == NULL)
	{
		printf("分配内存失败!");
		exit(-1);
	}
	else
	{
		ST->bottom = pStack_Head;
		ST->top = pStack_Head;
		pStack_Head->pNext = NULL;
	}
}

void build_Stack(pStack ST)
{
	int total,num;
	printf("请输入要栈入总数 total = ");
	scanf("%d",&total);
	
	pNode ptemp = ST->bottom;
	for(int i=0;i<total;i++)
	{
		pNode pNew = (pNode)malloc(sizeof(Node));
		printf("请输入要入栈的数 num = ");
		scanf("%d",&num);
		pNew->data = num;
		ptemp->pNext = pNew;
		pNew->pNext = NULL;
		ptemp = pNew;
	}
	ST->top = ptemp;
}

void push_Stack(pStack ST,int push_num)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = push_num;
	ST->top->pNext = pNew;
	pNew->pNext = NULL;
	ST->top = pNew;
}

void pop_Stack(pStack ST)
{
	pNode p = ST->bottom;
	while(p->pNext != ST->top)
	{
		p = p->pNext;
	}
	printf("->%d",p->pNext->data);
	free(p->pNext);
	p->pNext = NULL;
	ST->top = p;
}

int length_Stack(pStack ST)
{
	int i=0; 
	pNode p = ST->bottom;
	while(p != ST->top)
	{
		i++;
		p = p->pNext;
	}
	return i;
}

void traverse_Stack(pStack ST)
{
	if(empty(ST))
	{
		printf("栈为空!");
		exit(-1);
	}
	else
	{
		pNode p = ST->bottom->pNext;
		while(p != ST->top->pNext)
		{
			printf("->%d",p->data);
			p = p->pNext;
		}
	}
}

void clear_Stack(pStack ST)
{
	ST->top = ST->bottom;
}

void destroy_Stack(pStack ST)
{
	pNode p = ST->bottom->pNext,q;
	while(p)
	{
		q = p->pNext;
		free(p);
		p = q;
	}
	ST->top = ST->bottom;
}

bool empty(pStack ST)
{
	if(ST->bottom == ST->top)
	{
		return true;
	}
	else
	{
		return false;
	}
}

栈10进制转换为8进制
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	struct Node *pNext;
	int data;
}Node,*pNode;

typedef struct stack
{
	pNode bottom;
	pNode top;
}Stack,*pStack;


void init_Stack(pStack ST);
void push_Stack(pStack ST,int push_num);
void pop_Stack(pStack ST);
bool empty(pStack ST);
int length_Stack(pStack ST);

void main()
{
	unsigned num;
	pStack ST = (pStack)malloc(sizeof(Stack));
	init_Stack(ST);
	printf("待转换的数字 num=");
	scanf("%d",&num);
	while(num != 0)
	{
		push_Stack(ST,num%8);
		num = num/8;
	}

//	printf("\n%d",length_Stack(ST));
/*
	for(int i=0;i<=length_Stack(ST);i++)	//这里length_Stack(ST)是一个变量 随着每次pop_Stack(ST)而减少
	{
		pop_Stack(ST);
	}
*/
	while(!empty(ST))
	{
		pop_Stack(ST);
	}

//	printf("\n%d",length_Stack(ST));
}

void init_Stack(pStack ST)
{
	pNode pStack_Head = (pNode)malloc(sizeof(Node));
	if(pStack_Head == NULL)
	{
		printf("分配内存失败!");
		exit(-1);
	}
	else
	{
		ST->bottom = pStack_Head;
		ST->top = pStack_Head;
		pStack_Head->pNext = NULL;
	}
}

void push_Stack(pStack ST,int push_num)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = push_num;
	ST->top->pNext = pNew;
	pNew->pNext = NULL;
	ST->top = pNew;
}

void pop_Stack(pStack ST)
{
	pNode p = ST->bottom;
	while(p->pNext != ST->top)
	{
		p = p->pNext;
	}
	printf("->%d",p->pNext->data);
	free(p->pNext);
	p->pNext = NULL;
	ST->top = p;	
}

bool empty(pStack ST)
{
	if(ST->bottom == ST->top)
	{
		return true;
	}
	else
	{
		return false;
	}
}

int length_Stack(pStack ST)
{
	int i=0; 
	pNode p = ST->bottom;
	while(p != ST->top)
	{
		i++;
		p = p->pNext;
	}
	return i;
}

逆序栈
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	struct Node *pNext;
	int data;
}Node,*pNode;

typedef struct Stack
{
	pNode top;
	pNode bottom;
}Stack,*pStack;

void init_Stack(pStack ST);
void build_Stack(pStack ST);
void push_Stack(pStack ST,int push_num);
void pop_Stack(pStack ST);
void traverse_Stack(pStack ST);
void clear_Stack(pStack ST);
void destroy_Stack(pStack ST);

void main()
{
	int i,total,push_num;
	pStack ST = (pStack)malloc(sizeof(Stack));
	init_Stack(ST);
	build_Stack(ST);

	printf("请输入入栈数=");
	scanf("%d",&total);
	for(i=0;i<total;i++)
	{
		printf("请输入入栈的数=");
		scanf("%d",&push_num);
		push_Stack(ST,push_num);
	}

	printf("请输入出栈数=");
	scanf("%d",&total);
	for(i=0;i<total;i++)
	{
		pop_Stack(ST);
	}
	printf("\n");

	traverse_Stack(ST);
}

void init_Stack(pStack ST)
{
	pNode Stack_Head = (pNode)malloc(sizeof(Node));
	if(Stack_Head == NULL)
	{
		printf("头节点分配失败!\n");
		exit(-1);
	}
	else
	{
		ST->bottom = Stack_Head;
		ST->top = ST->bottom;
		Stack_Head->pNext = NULL;
	}
}

void build_Stack(pStack ST)
{
	int total,num;
	printf("请输入入栈数=");
	scanf("%d",&total);
	for(int i=0;i<total;i++)
	{
		pNode pNew = (pNode)malloc(sizeof(Node));
		if(pNew == NULL)
		{
			printf("内存分配失败!\n");
			exit(-1);
		}
		else
		{
			printf("请输入入栈的数=");
			scanf("%d",&num);
			pNew->data = num;
			pNew->pNext = ST->top;
			ST->top = pNew;
		}
	}
}

void push_Stack(pStack ST,int push_num)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	if(pNew == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	else
	{
		pNew->data = push_num;
		pNew->pNext = ST->top;
		ST->top = pNew;
	}
}

void pop_Stack(pStack ST)
{
	printf("->%d",ST->top->data);
	pNode ptemp = ST->top;
	ST->top = ptemp->pNext;
	free(ptemp);
}

void traverse_Stack(pStack ST)
{
	pNode p = ST->top;
	while(p != ST->bottom)
	{
		printf("->%d",p->data);
		p = p->pNext;
	}
}

void clear_Stack(pStack ST)
{
	ST->top = ST->bottom;
}

void destroy_Stack(pStack ST)
{
	pNode q = ST->top,p;
	while(q != ST->bottom)
	{
		p = q->pNext;
		free(q);
		q = p;
	}
	free(ST->bottom);
	ST->bottom = NULL;
	ST->top = ST->bottom;
}

bool empty(pStack ST)
{
	if(ST->top == ST->bottom)
	{
		return true;
	}
	else
	{
		return false;
	}
}

栈括号匹配
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	struct Node *pNext;
	int data;
}Node,*pNode;

typedef struct stack
{
	pNode bottom;
	pNode top;
}Stack,*pStack;

void init_Stack(pStack ST);
void push_Stack(pStack ST,int push_num);
char pop_Stack(pStack ST);
void traverse_Stack(pStack ST);
bool empty(pStack ST);

void main()
{
	char str[80],*p,e;
	pStack ST = (pStack)malloc(sizeof(Stack));
	if(ST == NULL)
	{
		printf("内存分配失败!");
		exit(-1);
	}
	init_Stack(ST);
	p = gets(str);
	while(*p)
	{	
		switch(*p)
		{
		case '(':push_Stack(ST,*p);
				p++;
				break;
		case ')':if(ST->bottom != ST->top)
				{
					e = pop_Stack(ST);
					if(e == '(')
					{
						printf("左右小括号匹配成功!\n");
					}
					else
					{
						printf("左右小括号匹配失败!\n");
						push_Stack(ST,e);
					}
				}
				else
				{
					printf("左右小括号匹配失败!\n");
				}
				p++;
				break;
		case '[':push_Stack(ST,*p);
				p++;
				break;
		case ']':if(ST->bottom != ST->top)
				{
					e = pop_Stack(ST);
					if(e == '[')
					{
						printf("左右中括号匹配成功!\n");
					}
					else
					{
						printf("左右中括号匹配失败!\n");
						push_Stack(ST,e);
					}
				}
				else
				{
					printf("左右中括号匹配失败!\n");
				}
				p++;
				break;
		case '{':push_Stack(ST,*p);
				p++;
				break;
		case '}':if(ST->bottom != ST->top)
				{
					e = pop_Stack(ST);
					if(e == '{')
					{
						printf("左右大括号匹配成功!\n");
					}
					else
					{
						printf("左右大括号匹配失败!\n");
						push_Stack(ST,e);
					}
				}
				else
				{
					printf("左右大括号匹配失败!\n");
				}
				p++;
				break;
		default:p++;
				break;
		}
	}
	if(ST->bottom != ST->top)
	{	
		e = pop_Stack(ST);
		if(e == '(' || e == '[' || e == '{')
		{
			printf("匹配失败!\n");
		}
	}
}

void init_Stack(pStack ST)
{
	pNode pStack_Head = (pNode)malloc(sizeof(Node));
	if(pStack_Head == NULL)
	{
		printf("分配内存失败!");
		exit(-1);
	}
	else
	{
		ST->bottom = pStack_Head;
		ST->top = pStack_Head;
		pStack_Head->pNext = NULL;
	}
}

void push_Stack(pStack ST,int push_num)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = push_num;
	ST->top->pNext = pNew;
	pNew->pNext = NULL;
	ST->top = pNew;
}

char pop_Stack(pStack ST)
{
	char e;
	pNode p = ST->bottom;
	while(p->pNext != ST->top)
	{
		p = p->pNext;
	}
	e = p->pNext->data;
	free(p->pNext);
	p->pNext = NULL;
	ST->top = p;
	return e;
}

void traverse_Stack(pStack ST)
{
	if(ST->bottom == ST->top)
	{
		printf("栈为空!");
		exit(-1);
	}
	else
	{
		pNode p = ST->bottom->pNext;
		while(p != ST->top->pNext)
		{
			printf("->%d",p->data);
			p = p->pNext;
		}
	}
}

行编辑器
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	struct Node *pNext;
	int data;
}Node,*pNode;

typedef struct Stack
{
	pNode top;
	pNode bottom;
}Stack,*pStack;

void init_Stack(pStack ST);
void push_Stack(pStack ST,int push_num);
void pop_Stack(pStack ST);
void clear_Stack(pStack ST);
void traverse_Stack(pStack ST);
void copy(FILE *fp,pStack ST);

void main()
{
	FILE *fp;
	fp = fopen("D:/VC++6.0【win10可用】/VC++6.0/MyProjects/text,txt","w");
	char ch;
	pStack ST = (pStack)malloc(sizeof(Stack));
	init_Stack(ST);
	ch = getchar();
	while(ch != EOF)
	{
		while(ch != EOF && ch != '\n')		//以空格为单位完成对每行的筛选
		{
			switch(ch)
			{
			case'#':pop_Stack(ST);
					break;
			case'@':clear_Stack(ST);
					break;
			default:push_Stack(ST,ch);
			}
			ch = getchar();
		}
		traverse_Stack(ST);
		copy(fp,ST);
		clear_Stack(ST);
		if(ch != EOF)
		{
			ch = getchar();
		}
	}
}

void init_Stack(pStack ST)
{
	pNode pStack_Head = (pNode)malloc(sizeof(Node));
	if(pStack_Head == NULL)
	{
		printf("分配内存失败!");
		exit(-1);
	}
	else
	{
		ST->bottom = pStack_Head;
		ST->top = pStack_Head;
		pStack_Head->pNext = NULL;
	}
}

void push_Stack(pStack ST,int push_num)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = push_num;
	ST->top->pNext = pNew;
	pNew->pNext = NULL;
	ST->top = pNew;
}

void pop_Stack(pStack ST)
{
	pNode p = ST->bottom;
	while(p->pNext != ST->top)
	{
		p = p->pNext;
	}
//	printf("%c",p->pNext->data);
	free(p->pNext);
	p->pNext = NULL;
	ST->top = p;
}

void clear_Stack(pStack ST)
{
	ST->top = ST->bottom;
}

void traverse_Stack(pStack ST)
{
	if(ST->top == ST->bottom)
	{
		printf("栈为空!");
		exit(-1);
	}
	else
	{
		pNode p = ST->bottom->pNext;
		while(p != ST->top->pNext)
		{
			printf("%c",p->data);
			p = p->pNext;
		}
	}
	printf("\n");
}

void copy(FILE *fp,pStack ST)
{
	if(ST->top == ST->bottom)
	{
		printf("栈为空!");
		exit(-1);
	}
	else
	{
		pNode p = ST->bottom->pNext;
		while(p != ST->top->pNext)
		{
			fprintf(fp,"%c",p->data);
			p = p->pNext;
		}
	}
	fputc('\n',fp);
}

迷宫求解
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#define MAXLENGTH 25

typedef int Maze_Type[MAXLENGTH][MAXLENGTH];
Maze_Type m;
int curstep = 1;

struct Pos
{
	int x;
	int y;
};

struct maze_elem
{
	int ord;
	struct Pos seat;
	int di;
};

typedef struct Node
{
	struct Node *pNext;
	struct maze_elem data;
}Node,*pNode;

typedef struct stack
{
	pNode bottom;
	pNode top;
}Stack,*pStack;

void init_Stack(pStack ST);
void push_Stack(pStack ST,struct maze_elem push_num);
struct maze_elem pop_Stack(pStack ST);
void printf_maze(int x,int y);
bool MazePath(struct Pos begin,struct Pos end);
bool empty(pStack ST);
bool Pass(struct Pos cerpos);
void FootPrint(struct Pos curpos);
struct Pos NextPos(struct Pos curpos,int di);
void MarkPrint(struct Pos seat);

void main()
{
	int i,j,x,y,x1,y1;
	struct Pos begin,end; 

	printf("请输入迷宫的行数,列数(包括外墙):");
	scanf("%d,%d",&x,&y);
	for(i=0;i<x;i++)
	{
		m[0][i] = 0;
		m[x-1][i] = 0;
	}
	for(j=i;j<y-1;j++)
	{
		m[j][0] = 0;
		m[j][y-1] = 0;
	}
	for(i=1;i<x-1;i++)
	{
		for(j=1;j<y-1;j++)
		{
			m[i][j] = 1;
		}
	}
	printf("请输入迷宫内墙元素:");
	scanf("%d",&j);
	printf("请依次输入迷宫内墙每个单元的行数,列数:\n");
	for(i=1;i<=j;i++)
	{
		scanf("%d,%d",&x1,&y1);
		m[x1][y1] = 0;
	}
	printf("迷宫结构如下!\n");
	printf_maze(x,y);
	printf("请输入起点的行数,列数:");
	scanf("%d,%d",&begin.x,&begin.y);
	printf("请输入重点的行数,列数:");
	scanf("%d,%d",&end.x,&end.y);
	if(MazePath(begin,end))
	{
		printf("此迷宫从入口到出口的一条路径如下\n");
		printf_maze(x,y);
	}
	else
	{
		printf("此迷宫没有从入口到出口的路径\n");
	}
}

void printf_maze(int x,int y)
{
	for(int i=0;i<x;i++)
	{
		for(int j=0;j<y;j++)
		{
			printf("%d  ",m[i][j]);
		}
		printf("\n");
	}
}

bool MazePath(struct Pos begin,struct Pos end)
{
	struct maze_elem elem;
	pStack ST = (pStack)malloc(sizeof(Stack));
	init_Stack(ST);
	Pos curpos;
	curpos = begin;
	do
	{
		if(Pass(curpos))
		{
			FootPrint(curpos);
			elem.ord = curstep;
			elem.seat.x = curpos.x;
			elem.seat.y = curpos.y;
			elem.di = 0;
			push_Stack(ST,elem);
			curstep++;
			if(curpos.x == end.x && curpos.y == end.y)
				return true;
			curpos = NextPos(curpos,elem.di);
		}
		else
		{
			if(!empty(ST))
			{
				elem = pop_Stack(ST);
				curpos.x = elem.seat.x;
				curpos.y = elem.seat.y;
				curstep--;
				while(elem.di == 3 && !empty(ST))
				{
					MarkPrint(elem.seat);
					elem = pop_Stack(ST);
					curstep--;
				}
				if(elem.di<3)
				{
					elem.di++;
					push_Stack(ST,elem);
					curstep++;
					curpos = NextPos(curpos,elem.di);
				}
			}
		}
	}while(!empty(ST));
	return false;
}

bool Pass(struct Pos cerpos)
{
	if(m[cerpos.x][cerpos.y] == 1)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void FootPrint(struct Pos curpos)
{
	m[curpos.x][curpos.y] = curstep;
}

void MarkPrint(struct Pos seat)
{
	m[seat.x][seat.y] = -1;
}

struct Pos NextPos(struct Pos curpos,int di)
{
	struct Pos direc[4] = {{0,1},{1,0},{0,-1},{-1,0}}; //代表东西南北
	curpos.x = curpos.x + direc[di].x;
	curpos.y = curpos.y + direc[di].y;
	return curpos;
}

void init_Stack(pStack ST)
{
	pNode pStack_Head = (pNode)malloc(sizeof(Node));
	if(pStack_Head == NULL)
	{
		printf("分配内存失败!");
		exit(-1);
	}
	else
	{
		ST->bottom = pStack_Head;
		ST->top = pStack_Head;
		pStack_Head->pNext = NULL;
	}
}

void push_Stack(pStack ST,struct maze_elem push_num)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = push_num;
	ST->top->pNext = pNew;
	pNew->pNext = NULL;
	ST->top = pNew;
}

struct maze_elem pop_Stack(pStack ST)
{
	struct maze_elem e;
	pNode p = ST->bottom;
	while(p->pNext != ST->top)
	{
		p = p->pNext;
	}
	e = p->pNext->data;
	free(p->pNext);
	p->pNext = NULL;
	ST->top = p;
	return e;
}

bool empty(pStack ST)
{
	if(ST->bottom == ST->top)
	{
		return true;
	}
	else
	{
		return false;
	}
}

表达式求值
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Node
{
	struct Node *pNext;
	int data;
}Node,*pNode;

typedef struct stack
{
	pNode bottom;
	pNode top;
}Stack,*pStack;

void init_Stack(pStack ST);
void push_Stack(pStack ST,int push_num);
char pop_Stack(pStack ST);
bool IN(char c);
char Precede(char x,char c);
char GetTop_Stack(pStack ST);
char Operate(char a,char theta,char b);

void main()
{
	pStack OPTR	= (pStack)malloc(sizeof(Stack)),
		   OPND = (pStack)malloc(sizeof(Stack));			//OPTR、OPNd分别用来寄存运算符号和运算数
	char a,b,c,x,theta;
	init_Stack(OPTR);
	push_Stack(OPTR,'#');		//
	init_Stack(OPND);
	c = getchar();
	x = GetTop_Stack(OPTR);
	while(c != '#' || x != '#')
	{
		if(IN(c))				//IN(c)判断c是否为符号数
		{
			switch(Precede(x,c))
			{
			case'<':push_Stack(OPTR,c);
					if(c != '#')
					{
						c = getchar();
					}
					break;
			case'=':x = pop_Stack(OPTR);
					if(c != '#')
					{
						c = getchar();
					}
					break;
			case'>':theta = pop_Stack(OPTR);
					b = pop_Stack(OPND);
					a = pop_Stack(OPND);
					push_Stack(OPND,Operate(a,theta,b));
					break;
			}
		}
		else if(c > '0' && c <= '9')
		{
			push_Stack(OPND,c);
			c = getchar();
		}
		else
		{
			printf("错误四");
			exit(-1);
		}
		x = GetTop_Stack(OPTR);
	}
	printf("%c",GetTop_Stack(OPND));
}

char Operate(char a,char theta,char b)
{
	char sum;
	a = a - 48;
	b = b - 48;
	switch(theta)
	{
	case'+':sum = a + b + 48;
			break;
	case'-':sum = a - b + 48;
			break;
	case'*':sum = a * b + 48;
			break;
	case'/':sum = a / b + 48;
			break;
	}
	return sum;
}

char Precede(char x,char c)
{
	char f;
	switch(c)
	{
	case'+':
	case'-':if(x == '(' || x == '#')	//'+' '-'的优先级高于'(' '#'
				f = '<';
			else
				f = '>';
			break;
	case'*':
	case'/':if(x == '*' || x == '/' || x == ')')							//'*' '/'的优先级低于'(' 和本身
				f = '>';
			else
				f = '<';
			break;
	case'(':if(x == ')')
			{
				printf("错误一");
				exit(-1);
			}
			else
			{
				f = '<';
			}
			break;
	case')':switch(x)
			{
			case'(':f = '=';
			break;
			case'#':printf("错误二");
			break;
			default:f = '>';
			}
			break;
	case'#':switch(x)
			{
			case'(':printf("错误三");
					exit(-1);
			case'#':f = '=';
					break;
			default:f = '>';
			}
			break;
	}
	return f;
}

bool IN(char c)
{
	switch(c)
	{
	case'+':
	case'-':
	case'*':
	case'/':
	case'(':
	case')':
	case'#':return true;
	default:return false;
	}
}

void init_Stack(pStack ST)
{
	pNode pStack_Head = (pNode)malloc(sizeof(Node));
	if(pStack_Head == NULL)
	{
		printf("分配内存失败!");
		exit(-1);
	}
	else
	{
		ST->bottom = pStack_Head;
		ST->top = pStack_Head;
		pStack_Head->pNext = NULL;
	}
}

void push_Stack(pStack ST,int push_num)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = push_num;
	ST->top->pNext = pNew;
	pNew->pNext = NULL;
	ST->top = pNew;
}

char pop_Stack(pStack ST)
{
	char e;
	pNode p = ST->bottom;
	while(p->pNext != ST->top)
	{
		p = p->pNext;
	}
	e = p->pNext->data;
	free(p->pNext);
	p->pNext = NULL;
	ST->top = p;
	return e;
}

char GetTop_Stack(pStack ST)
{
	char e;
	pNode p = ST->bottom;
	while(p->pNext != ST->top)
	{
		p = p->pNext;
	}
	e = p->pNext->data;
	return e;
}

链式列队
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct QNode
{
	int data;
	struct QNode *pNext;
}QNode,*qQNode;

typedef struct Queue
{
	qQNode front;
	qQNode rear;
}Queue,*qQueue;

void init_QU(qQueue QU);
void enQU(qQueue QU,int num);
void traverse_QU(qQueue QU);
int deQU(qQueue QU);
int length_QU(qQueue QU);
bool empty(qQueue QU);
void clear_QU(qQueue QU);
void destroy(qQueue QU);

void main()
{
	int ennum,denum,into_total;
	qQueue QU = (qQueue)malloc(sizeof(Queue));
	init_QU(QU);

	printf("请输入入队数:");
	scanf("%d",&into_total);
	for(int i=0;i<into_total;i++)
	{
		printf("请输入入队数值:");
		scanf("%d",&ennum);
		enQU(QU,ennum);
	}

	printf("出队数值为:%d\n",deQU(QU));
//	clear_QU(QU);
	destroy(QU);

//	traverse_QU(QU);
}

void init_QU(qQueue QU)
{
	qQNode head_Node = (qQNode)malloc(sizeof(QNode));
	if(head_Node == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	QU->front = head_Node;
	QU->rear = QU->front;
	head_Node->pNext = NULL;
	head_Node->data = 0;
}

void enQU(qQueue QU,int num)
{
	qQNode pNew = (qQNode)malloc(sizeof(QNode));
	if(pNew == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	pNew->data = num;
	QU->rear->pNext = pNew;
	QU->rear = pNew;
	pNew->pNext = NULL;
	QU->front->data++;
}

int deQU(qQueue QU)
{
	qQNode q = QU->front->pNext;
	QU->front->pNext = q->pNext;
	int e = q->data;
	free(q);
	QU->front->data--;
	if(QU->front->data == 0)
	{
		QU->rear = QU->front;
	}
	return e;
}

void traverse_QU(qQueue QU)
{
	if(empty(QU))
	{
		printf("列队为空!\n");
		exit(-1);
	}
	printf("列队总长度为:%d\n",QU->front->data);
	qQNode q = QU->front->pNext;
	while(q)
	{
		printf("->%d",q->data);
		q = q->pNext;
	}
}

int length_QU(qQueue QU)
{
	return QU->front->data;
}

void clear_QU(qQueue QU)
{
	QU->rear = QU->front;
	QU->front->data = 0;
}

void destroy(qQueue QU)
{
	while(QU->front)
	{
		QU->rear = QU->front->pNext;
		free(QU->front);
		QU->front = QU->rear;
	}
}

bool empty(qQueue QU)
{
	if(QU->rear == QU->front)
	{
		return true;
	}
	else
	{
		return false;
	}
}

循环列队
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Queue
{
	int *Base;
	int front;
	int rear;
	int len;
}Queue,*qQueue;

void init_Queue(qQueue Q,int length);
void en_Queue(qQueue Q,int val);
int de_Queue(qQueue Q);
int use_Queue(qQueue Q);
void traverse_Queue(qQueue Q);
void clear_Queue(qQueue Q);
void clear_Queue(qQueue Q);
void destroy_Queue(qQueue Q);

void main()
{
	Queue Q;
	int length,en_length,de_length,en_num;
	printf("请输入列队长度:");
	scanf("%d",&length);
	init_Queue(&Q,length);

	printf("请输入入队长度:");
	scanf("%d",&en_length);

	while(1)
	{
		if((Q.len-1-use_Queue(&Q)) >= en_length && en_length >= 0)
		{
			break;
		}
		else
		{
			printf("剩余队列空间为%d\n",Q.len-1-use_Queue(&Q));
			printf("请重新输入入队长度:");
			scanf("%d",&en_length);
		}
	}
	
	for(int i=0;i<en_length;i++)
	{
		printf("请输入要入队的数字:");
		scanf("%d",&en_num);
		en_Queue(&Q,en_num);
	}

	printf("请输入要出对的长度:");
	scanf("%d",&de_length);
	
	while(1)
	{
		if(de_length >= 0 && de_length <= use_Queue(&Q))
		{
			break;
		}
		else
		{
			printf("已用队列空间为%d",use_Queue(&Q));
			printf("请重新输入队列长度:");
			scanf("%d",&de_length);
		}
	}

	for(i=0;i<de_length;i++)
	{
		printf("->%d",de_Queue(&Q));
	}

	printf("\n");

//	clear_Queue(&Q);
//	destroy_Queue(&Q);

	traverse_Queue(&Q);
}

void init_Queue(qQueue Q,int length)
{
	Q->Base = (int*)malloc(sizeof(int)*length);
	Q->front = 0;
	Q->rear = 0;
	Q->len = length;
}

void en_Queue(qQueue Q,int val)
{
	Q->Base[Q->rear] = val;
	Q->rear = (Q->rear+1)%Q->len;
}

int de_Queue(qQueue Q)
{
	int e;
	e = Q->Base[Q->front];
	Q->front = (Q->front+1)%Q->len;
	return e;
}

void clear_Queue(qQueue Q)
{
	Q->front = Q->rear = 0;

}

void destroy_Queue(qQueue Q)
{
	if(Q->Base)
		free(Q->Base);
	Q->Base = NULL;
	Q->front = Q->rear = 0;
}

int use_Queue(qQueue Q)
{
	return (Q->rear - Q->front + Q->len)%Q->len;
}

void traverse_Queue(qQueue Q)
{
	if(use_Queue(Q) == 0)
	{
		printf("队列为空!\n");
		exit(-1);
	}
	int r = Q->front;
	while(r != Q->rear)
	{
		printf("->%d",Q->Base[r]);
		r = (r+1)%Q->len;
	}
}

顺序列队
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef struct Queue
{
	int *Base;
	int front;
	int rear;
}Queue,*qQueue;

void init_Queue(qQueue Q,int length);
void en_Queue(qQueue Q,int val);
void traverse_Queue(qQueue Q);
int de_Queue(qQueue Q);
void clear_Queue(qQueue Q);
void destroy_Queue(qQueue Q);

void main()
{
	int length,en_length,de_length,en_num;
	Queue Q;
	printf("请输入队列的长度:");
	scanf("%d",&length);
	init_Queue(&Q,length);

	printf("请输入入队的长度:");
	scanf("%d",&en_length);

	while(1)
	{
		if(length-(Q.rear-Q.front) >= en_length && en_length >= 0)
		{
			break;
		}
		else
		{
			printf("剩余长度为:%d",length-(Q.rear-Q.front));
			printf("请重新输入入队长度:");
			scanf("%d",&en_length);
		}
	}

	for(int i=0;i<en_length;i++)
	{
		printf("请输入入队数:");
		scanf("%d",&en_num);
		en_Queue(&Q,en_num);
	}

	printf("请输入出队的长度:");
	scanf("%d",&de_length);

	while(1)
	{
		if(Q.rear-Q.front >= de_length && de_length >= 0)
		{
			break;
		}
		else
		{
			printf("已用长度为:%d",Q.rear-Q.front);
			printf("请重新输入出队长度:");
			scanf("%d",&de_length);
		}
	}

	for(i=0;i<de_length;i++)
	{
		printf("->%d",de_Queue(&Q));
	}

	printf("\n");
	
	traverse_Queue(&Q);
}

void init_Queue(qQueue Q,int length)
{
	Q->Base = (int*)malloc((length+1)*sizeof(int));
	if(Q->Base == NULL)
	{
		printf("空间分配失败!\n");
		exit(-1);
	}
	Q->front = 0;
	Q->rear = 0;
}

void en_Queue(qQueue Q,int val)
{
	Q->Base[Q->rear] = val;
	Q->rear++;
}

int de_Queue(qQueue Q)
{
	int e = Q->Base[Q->front];
	Q->front++;
	return e;
}

void clear_Queue(qQueue Q)
{
	Q->rear = Q->front = 0;
}

void destroy_Queue(qQueue Q)
{
	if(Q->Base)
		free(Q->Base);
	Q->Base = NULL;
	Q->front = Q->rear = 0;
}

void traverse_Queue(qQueue Q)
{
	int r = Q->front;
	while(r != Q->rear)
	{
		printf("->%d",Q->Base[r]);
		r++;
	}
}

利用非循环列表广度搜索求解迷宫问题(针对只有唯一路径到终点)
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#define M 5
#define N 5
#define D 8
#define QUEUELENGTH 100

typedef struct
{
	int x,y;
	int pre;
}QElemType,*qQElemType;

typedef struct Queue
{
	QElemType *Base;
	int front;
	int rear;
}Queue,*qQueue;

typedef struct Node
{
	struct Node *pNext;
	QElemType data;
}Node,*pNode;

typedef struct stack
{
	pNode bottom;
	pNode top;
}Stack,*pStack;

struct 
{
	int x,y;
#if	D == 8
}move[D] = {{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1}};
#endif
#if D == 4
}move[D] = {{0,1},{1,0},{0,-1},{-1,0}};
#endif

void init_Queue(qQueue Q,int length);
void en_Queue(qQueue Q,QElemType val);
QElemType de_Queue(qQueue Q);
int use_Queue(qQueue Q);

void init_Stack(pStack ST);
void push_Stack(pStack ST,QElemType push_num);
QElemType pop_Stack(pStack ST);
bool empty(pStack ST);

void main()
{
	int i,j;
	int maze[M][N];
	printf("%d行%列迷宫(不包括外墙)\n",M-2,N-2);
	for(i=0;i<N;i++)
	{
		maze[0][i] = 0;
		maze[M-1][i] = 0;
	}
	for(i=1;i<M-1;i++)
	{
		maze[i][0] = 0;
		maze[i][N-1] = 0;
	}
	printf("请按行输入迷宫结构!\n");
	for(i=1;i<M-1;i++)
	{
		for(j=1;j<N-1;j++)
		{
			printf("请输入第%d行第%d列的结构:",i,j);
			scanf("%d",&maze[i][j]);
		}
	}
	printf("迷宫结构(包括外墙):\n");
	for(i=0;i<M;i++)
	{
		for(j=0;j<N;j++)
		{
			printf(" %d ",maze[i][j]);
		}
		printf("\n");
	}

	Queue Q;
	QElemType qf,qt;
	Stack S;
	int flag=1;
	int x1,y1;
	printf("请输入入口的行,列(左上角1,1)\n");
	scanf("%d,%d",&qf.x,&qf.y);
	printf("请输入出口的行,列(右下角为%d,%d)\n",M-2,N-2);
	scanf("%d,%d",&x1,&y1);
	qf.pre = -1;
	maze[qf.x][qf.y] = -1;
	init_Queue(&Q,QUEUELENGTH);
	en_Queue(&Q,qf);
	while(use_Queue(&Q) != 0 && flag)
	{
		qf = de_Queue(&Q);
		for(i=0;i<D;i++)
		{
			qt.x = qf.x + move[i].x;
			qt.y = qf.y + move[i].y;
			if(maze[qt.x][qt.y] == 1)
			{
				maze[qt.x][qt.y] = -1;
				qt.pre = Q.front - 1;
				en_Queue(&Q,qt);
				if(qt.x == x1 && qt.y == y1)
				{
					flag = 0;
					break;
				}
			}
		}
	}
	if(flag)
	{
		printf("没用路径可以到达!\n");
		exit(-1);
	}
	else
	{
		init_Stack(&S);
		i = Q.rear - 1;
		while(i>=0)
		{
			push_Stack(&S,Q.Base[i]);
			i = Q.Base[i].pre;
		}
		i = 0;
		while(!empty(&S))
		{
			qf = pop_Stack(&S);
			i++;
			maze[qf.x][qf.y] = i;
		}
		printf("走出的迷宫的一个方案:\n");
		for(i=1;i<M-1;i++)
		{
			for(j=1;j<N-1;j++)
			{
				printf("%3d",maze[i][j]);
			}
			printf("\n");
		}
	}

}

void init_Queue(qQueue Q,int length)
{
	Q->Base = (qQElemType)malloc((length+1)*sizeof(qQElemType));
	if(Q->Base == NULL)
	{
		printf("空间分配失败!\n");
		exit(-1);
	}
	Q->front = 0;
	Q->rear = 0;
}

void en_Queue(qQueue Q,QElemType val)
{
	Q->Base[Q->rear] = val;
	Q->rear++;
}

QElemType de_Queue(qQueue Q)
{
	QElemType e = Q->Base[Q->front];
	Q->front++;
	return e;
}

int use_Queue(qQueue Q)
{
	return Q->rear - Q->front;
}

void init_Stack(pStack ST)
{
	pNode pStack_Head = (pNode)malloc(sizeof(Node));
	if(pStack_Head == NULL)
	{
		printf("分配内存失败!");
		exit(-1);
	}
	else
	{
		ST->bottom = pStack_Head;
		ST->top = pStack_Head;
		pStack_Head->pNext = NULL;
	}
}

void push_Stack(pStack ST,QElemType push_num)
{
	pNode pNew = (pNode)malloc(sizeof(Node));
	pNew->data = push_num;
	ST->top->pNext = pNew;
	pNew->pNext = NULL;
	ST->top = pNew;
}

QElemType pop_Stack(pStack ST)
{
	QElemType e;
	pNode p = ST->bottom;
	while(p->pNext != ST->top)
	{
		p = p->pNext;
	}
	e = p->pNext->data;
	free(p->pNext);
	p->pNext = NULL;
	ST->top = p;
	return e;
}

bool empty(pStack ST)
{
	if(ST->bottom == ST->top)
	{
		return true;
	}
	else
	{
		return false;
	}
}

串的表示和实现
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#define MAXSTRLEN 40

typedef char SString[MAXSTRLEN+1];

void StrAssign(SString T,char *chars);
int StrLength(SString T);
void StrPrint(SString T);
void StrCopy(SString T,SString S);
char StrCompare(SString T,SString S);
void Strconcat(SString T,SString S,SString H);			//合并两个字符串
void SubString(SString T,SString S,int i,int j);		//在主串中取子串
void StrDelete(SString T,int i,int j);					
void StrInsert(SString T,SString S,int i);
int Index(SString T,SString S,int pos);					//在串s1中找到s2对应的位置
void Strclear(SString T);
void Replace(SString T,SString S,SString H);

bool Strempty(SString T);

void main()
{
	int i,j,m;
	char k,c[MAXSTRLEN+1];
	SString s1,s2,s3;

	printf("请输入串s1:");
	gets(c);
	StrAssign(s1,c);
	StrPrint(s1);

	printf("请输入串s2:");
	gets(c);
	StrAssign(s2,c);
	StrPrint(s2);
/*
	k = StrCompare(s1,s2);
	if(k == 0)
	{
		printf("串s1=串s2");
	}
	else if(k > 0)
	{
		printf("串s1>串s2");
	}
	else
	{
		printf("串s1<串s2");
	}

	Strconcat(s1,s2,s3);
	printf("s1与s2串联的到的串s3为:");

	StrCopy(s1,s3);
	printf("s1复制的串s3为:");

//	Strclear(s3);
	printf("求串s2的子串,请输入串的起始位置,子串长度:");
	scanf("%d,%d",&i,&j);
	SubString(s3,s2,i,j);

	printf("从串s1中pos个字符起,删除len个字符,请输入pos,len:");
	scanf("%d,%d",&i,&j);
	StrDelete(s1,i,j);

	printf("在串s1的第pos个字符起,插入串s2,请输入pos:");
	scanf("%d",&i);
	StrInsert(s1,s2,i);

	printf("在主串s1第pos后找到子串s2对应的位置:");
	scanf("%d",&i);
	printf("s2在s1的第%d个匹配!\n",Index(s1,s2,i));
*/	
	SubString(s3,s2,1,1);
	StrPrint(s3);
	Replace(s1,s2,s3);
	StrPrint(s1);
}

void StrAssign(SString T,char *chars)
{
	if(strlen(chars)>MAXSTRLEN)
	{
		printf("串长超过MAXSTRLEN!\n");
		exit(-1);
	}
	else
	{
		T[0] = strlen(chars);
		for(int i=1;i<=T[0];i++)
		{
			T[i] = chars[i-1];
		}
	}
}

int StrLength(SString T)
{
	return T[0];
}

void StrPrint(SString T)
{
	for(int i=1;i<T[0]+1;i++)
	{
		printf("%c",T[i]);
	}
	printf("\n");
}

void StrCopy(SString T,SString S)
{
	for(int i=0;i<=T[0];i++)
	{
		S[i] = T[i];
	}
}

void Strconcat(SString T,SString S,SString H)
{
	int i;
	if(T[0]+S[0] > MAXSTRLEN)
	{
		for(i=1;i<=T[0];i++)
		{
			H[i] = T[i];
		}
		for(i=1;i<=MAXSTRLEN-T[0];i++)
		{
			H[T[0]+i] = S[i];
		}
		H[0] = MAXSTRLEN;
	}
	else
	{
		for(i=1;i<=T[0];i++)
		{
			H[i] = T[i];
		}
		for(i=1;i<=S[0];i++)
		{
			H[T[0]+i] = S[i];
		}
		H[0] = T[0] + S[0];
	}
}

void SubString(SString T,SString S,int i,int j)
{
	for(int k=1;k<=j;k++)
	{
		T[k] = S[k+i-1];
	}
	T[0] = j;
}

void StrDelete(SString T,int i,int j)
{
	if(j<=T[0]+1-i && j>=1 && i>=1 && i<=T[0])
	{
		for(int k=i;k+j<=T[0];k++)
		{
			T[k] = T[k+j];
		}
		T[0] = T[0] - j;
	}
	else
	{
		printf("非法删除!\n");
		exit(-1);
	}
}

void StrInsert(SString T,SString S,int i)
{
	int m = S[0];
	if(T[0]+S[0]<=MAXSTRLEN && i>0 && i<T[0])
	{
		for(int k=1;k<=T[0]+1-i;k++)
		{
			S[k+S[0]] = T[i+k-1];
		}
		S[0] = S[0] + k;
		T[0] = T[0] - k;
		for(k=1;k<=S[0];k++)
		{
			T[i+k-1] = S[k]; 
		}
		T[0] = T[0] + S[0];
		S[0] = m;
	}
	else
	{
		printf("非法插入!\n");
		exit(-1);
	}
}

int Index(SString T,SString S,int pos)
{
	int i,j;
	if(pos<=T[0] && pos>=1)
	{
		i = pos;
		j = 1;
		while(j<=S[0] && i<=T[0])
		{
			if(S[j] == T[i])
			{
				i++;
				j++;
			}
			else
			{
				i = i-j+2;
				j = 1; 
			}
		}
		if(j > S[0])
		{
			return i-S[0];
		}
		else
		{
			return 0;
		}
	}
	else
	{
		printf("位置范围错误!\n");
		exit(-1);
	}
}

void Replace(SString T,SString S,SString H)
{
	int pos,i=1;
	while((pos = Index(T,H,i)) != 0)
	{
		StrDelete(T,pos,H[0]);
		StrInsert(T,S,pos);
		i = pos + S[0];
	}
}

char StrCompare(SString T,SString S)
{
	for(int i=1;i<T[0]&&i<S[0];i++)
	{
		if(S[i] != T[i])
		{
			return T[i] - S[i];
		}
	}
	return T[0] - S[0];
}

void Strclear(SString T)
{
	T[0] = 0;
}

bool Strempty(SString T)
{
	if(T[0] == 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}

串的堆分配存储
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#define MAXSIZE 20

typedef struct HString
{
	char *ch;
	int length;
}*pHString;

void Init_String(HString *Str);
void Assign_Str(HString *Str,char *t);
void Print_Str(HString *Str);
int Compare_Str(HString *Str,HString *Str1);
void Concat_Str(HString *Str,HString *Str1,HString *Str2);
void Replace_Str(HString *Str,HString *Str1,HString *Str2);
void Clear_Str(HString *Str);
void Sub_Str(HString *Str,HString *Str1,int pos,int len);
void Copy_Str(HString *Str,HString *Str1);
void Insert_Str(HString *Str,HString *Str1,int pos);
void Delete_Str(HString *Str,int pos,int len);
int Index_Str(HString *Str,HString *Str1,int pos);

void main()
{
	int pos,len;
	char c[MAXSIZE],*p;
	HString t,s,r;
	Init_String(&t);
	Init_String(&s);
	Init_String(&r);

	printf("请输入要建立的字符串t:");
	p = gets(c);
	Assign_Str(&t,p);
	printf("字符串t为:");
	Print_Str(&t);

	printf("请输入要建立的字符串s:");
	p = gets(c);
	Assign_Str(&s,p);
	printf("字符串s为:");
	Print_Str(&s);

	if(Compare_Str(&t,&s) > 0)
	{
		printf("t串>s串\n");
	}
	else if(Compare_Str(&t,&s) == 0)
	{
		printf("t串=s串\n");
	}
	else
	{
		printf("t串<s串\n");
	}

	Concat_Str(&t,&s,&r);
	printf("将串t和串s合并为串r为:");
	Print_Str(&r);

	Clear_Str(&r);
	printf("请输入在字符串t中取得的子串的位置和长度:");
	scanf("%d,%d",&pos,&len);
	Sub_Str(&r,&t,pos,len);
	printf("字符串r为:");
	Print_Str(&r);

	Clear_Str(&r);
	printf("将字符串s复制到字符串r");
	Copy_Str(&r,&s);
	printf("字符串r为:");
	Print_Str(&r);
	
	printf("请输入在字符串t中插入字符串的位置:");
	scanf("%d",&pos);
	Insert_Str(&t,&s,pos);
	printf("字符串t为:");
	Print_Str(&t);

	printf("请输入在字符串r中删除字符串的位置和长度:");
	scanf("%d,%d",&pos,&len);
	Delete_Str(&r,pos,len);
	printf("字符串r为:");
	Print_Str(&r);

	Print_Str(&t);
	Print_Str(&s);
	printf("请输入指定位置后字符串t第一次出现字符串s的位置:");
	scanf("%d",&pos);
	printf("子串s在主串t中对应的位置为%d:\n",Index_Str(&t,&s,pos));

	fflush(stdin);
	Clear_Str(&r);
	printf("请输入要建立的字符串r:");
	p = gets(c);
	Assign_Str(&r,p);
	printf("字符串r为:");
	Print_Str(&r);
	printf("请输入在字符串s中删除字符串的位置和长度:");				//删除字符串中的一部分满足替换的字符
	scanf("%d,%d",&pos,&len);
	Delete_Str(&s,pos,len);
	printf("字符串s为:");
	Print_Str(&s);
	Replace_Str(&t,&s,&r);
	printf("被替换后的t为:");
	Print_Str(&t);
}

void Init_String(HString *Str)
{
	Str->ch = NULL;
	Str->length = 0;
}

void Assign_Str(HString* Str,char *t)
{
	int i,j;
	if(Str->ch)
	{
		free(Str->ch);
	}
	i = strlen(t);
	if(i)
	{
		Str->ch = (char*)malloc(i*sizeof(char));
		if(!Str->ch)
		{
			printf("分配空间失败!\n");
			exit(-1);
		}
		for(j=0;j<i;j++)
		{
			Str->ch[j] = t[j];
		}
		Str->length = i;
	}
	else
	{
		printf("串为空!\n");
	}
}

int Compare_Str(HString *Str,HString *Str1)
{
	for(int i=0;i<Str->length && i<Str1->length;i++)
	{
		if(Str->ch[i] != Str1->ch[i])
		{
			return Str->ch[i] - Str1->ch[i];
		}
	}
	return Str->length - Str->length;
}

void Concat_Str(HString *Str,HString *Str1,HString *Str2)
{
	Str2->ch = (char*)malloc((Str->length + Str1->length)*sizeof(char));
	if(Str2->ch == NULL)
	{
		printf("空间分配失败!\n");
		exit(-1);
	}
	else
	{
		for(int i=0;i<Str->length;i++)
		{
			Str2->ch[i] = Str->ch[i];
		}
		for(i=0;i<Str1->length;i++)
		{
			Str2->ch[i+Str->length] = Str1->ch[i];
		}
		Str2->length = Str->length + Str1->length;
	}
}

void Sub_Str(HString *Str,HString *Str1,int pos,int len)
{
	if(pos>=0 && pos<=Str1->length-1 && pos+len+1<=Str1->length)
	{
		Str->ch = (char*)malloc(len*sizeof(char));
		if(Str->ch == NULL)
		{
			printf("内存分配失败!\n");
			exit(-1);
		}
		else
		{
			for(int i=0;i<len;i++)
			{
					Str->ch[i] = Str1->ch[pos+i-1];
			}
			Str->length = len;
		}
	}
	else
	{
		printf("子串位置和长度范围错误!\n");
		exit(-1);
	}
}

void Copy_Str(HString *Str,HString *Str1)
{
	Str->ch = (char*)malloc(Str1->length*sizeof(char));
	if(Str->ch == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	else
	{
		for(int i=0;i<Str1->length;i++)
		{
			Str->ch[i] = Str1->ch[i];
		}
		Str->length = Str1->length;
	}
}

void Insert_Str(HString *Str,HString *Str1,int pos)
{
	if(pos>=0 && pos<Str->length)
	{
		for(int i=Str->length-1;i>=pos-1;i--)
		{
			Str->ch[i+Str1->length] = Str->ch[i];
		}
		for(i=0;i<Str1->length;i++)
		{
			Str->ch[pos+i-1] = Str1->ch[i];
		}
		Str->length = Str->length + Str1->length;
	}
	else
	{
		printf("插入范围错误!\n");
		exit(-1);
	}
}

void Delete_Str(HString *Str,int pos,int len)
{
	if(pos>=1 && pos<=Str->length)
	{
		for(int i=0;i<Str->length-pos+1-len;i++)
		{
			Str->ch[pos-1+i] = Str->ch[pos-1+i+len];
		}
		Str->length = Str->length - len;
	}
	else
	{
		printf("删除范围错误!\n");
		exit(-1);
	}
}

int Index_Str(HString *Str,HString *Str1,int pos)
{
	int i = pos-1,j = 0;
	while(i<Str->length && j<Str1->length)
	{
		if(Str->ch[i] == Str1->ch[j])
		{
			j++;
			i++;
		}
		else
		{
			i = i-j+1;
			j = 0;
		}
	}
	if(j>=Str1->length)
	{
		return i - Str1->length + 1;
	}
	else
	{
		return 0;
	}
}

void Replace_Str(HString *Str,HString *Str1,HString *Str2)
{
	int pos,i = 1;
	while((pos = Index_Str(Str,Str1,i-1)) != 0)
	{
		Delete_Str(Str,pos,Str1->length);
		Insert_Str(Str,Str2,pos);
		i = pos + Str1->length; 
	}
}

void Clear_Str(HString *Str)
{
	free(Str->ch);
	Str->ch = NULL;
	Str->length = 0;
}

void Print_Str(HString *Str)
{
	if(Str->length == 0)
	{
		printf("串为空!\n");
		exit(-1);
	}
	else
	{
		for(int i=0;i<Str->length;i++)
		{
			printf("%c",Str->ch[i]);
		}
		printf("\n");
	}
}

串的链块存储表示
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#define CHUNKSIZE 4
#define MAXSIZE 20

typedef struct Chunk
{
	char ch[CHUNKSIZE];
	struct Chunk *pnext;
}Chunk,*pChunk;

typedef struct LString
{
	struct Chunk *head,*tail;
	int curlen;
}LString,*pLString;

pLString Init_String();
void Assign_String(pLString Str,char *p);
void Print_String(pLString Str);
void Clear_String(pLString Str);
void Copy_String(pLString Str,pLString Str1);
void Sub_String(pLString Str,pLString Str1,int pos,int len);
void Concat_String(pLString Str,pLString Str1,pLString Str2);
int Index_String(pLString Str,pLString Str1,int pos);

bool empty(pLString Str);

void main()
{
	int pos,len;
	char c[MAXSIZE],*p;
	pLString Str,Str1,Str2;
	Str = Init_String();
	Str1 = Init_String();
	Str2 = Init_String();

	printf("请输入要分配的字符串a:");
	p = gets(c);
	Assign_String(Str,p);
	printf("字符串a为:");
	Print_String(Str);

	Copy_String(Str,Str1);
	printf("将字符串a复制到字符串b为:");
	Print_String(Str1);

	Concat_String(Str,Str1,Str2);
	printf("将字符串a与字符串b合并(不去除填充部分)c为:");
	Print_String(Str2);

	Clear_String(Str2);
	printf("求从a的第pos个字符起,长度为len的子串c,pos,len:");
	scanf("%d,%d",&pos,&len);
	Sub_String(Str,Str2,pos,len);
	printf("子串c为:");
	Print_String(Str2);

	printf("从主串a的pos后面找寻对用对应子串c位置:");
	scanf("%d",&pos);
	printf("子串c在主串a中的位置为%d:\n",Index_String(Str,Str2,pos));
}

pLString Init_String()
{
	pLString Str = (pLString)malloc(sizeof(LString));
	pChunk pHeadnext = (pChunk)malloc(sizeof(Chunk));
	if(Str == NULL || pHeadnext == NULL)
	{
		printf("内存分配失败");
		exit(-1);
	}
	Str->curlen = 0;
	Str->head = Str->tail = pHeadnext;
	pHeadnext->pnext =NULL;
	return Str;
}

void Assign_String(pLString Str,char *p)
{
	int i,j,k;
	pChunk q,ptemp = Str->tail;
	i = strlen(p);							//strlen函数是判断以'\0'结尾前的总长度 用(char*)malloc(Str->curlen*sizeof(char))不是以'\0'结尾，所以不能用strlen(char型指针)
	if(!i || strchr(p,' '))					//strche(p,' ');判断分配字符串中是否有' '
	{
		printf("输入错误!\n");
		exit(-1);
	}
	Str->curlen = i;
	j = i/CHUNKSIZE;
	if(i%CHUNKSIZE)
	{
		j++;
	}
	for(i=0;i<j;i++)
	{
		q = (pChunk)malloc(sizeof(Chunk));
		if(!q)
		{
			printf("内存分配失败!\n");
			exit(-1);
		}
		for(k=0;k<CHUNKSIZE && *p;k++)			//字符串数组未分配则是'空'   *p也可以等同于*p != ' '
		{
			q->ch[k] = *p++;
		}
		if(!*p)
		{
			Str->tail = q;
			q->pnext = NULL;
			for(;k<CHUNKSIZE;k++)
			{
				q->ch[k] = ' ';
			}
		}
		ptemp->pnext = q;
		ptemp = q;
	}
}

void Clear_String(pLString Str)
{
	pChunk p = Str->head->pnext,q;
	while(p)
	{
		q = p->pnext;
		free(p);
		p = q;
	}
	Str->curlen = 0;
	Str->head->pnext = NULL;
	Str->tail = Str->head;
}

void Copy_String(pLString Str,pLString Str1)
{
	int k;
	if(!empty(Str1))
	{
		Clear_String(Str1);
	}
	pChunk ptemp = Str1->head,p = Str->head->pnext;
	while(p)
	{
		pChunk q = (pChunk)malloc(sizeof(Chunk));
		if(!q)
		{
			printf("动态内存分配失败!\n");
			exit(-1);
		}
		for(k=0;k<CHUNKSIZE;k++)
		{
			q->ch[k] = p->ch[k];
		}
		ptemp->pnext = q;
		ptemp = q;
		p = p->pnext;
	}
	Str1->tail = ptemp;
	ptemp->pnext = NULL;
}

void Concat_String(pLString Str,pLString Str1,pLString Str2)
{
	pLString a,b;
	a = Init_String();
	b = Init_String();
	Copy_String(Str,a);
	Copy_String(Str1,b);
	a->tail->pnext = b->head->pnext;
	Str2->head->pnext = a->head->pnext;
	Str2->tail = b->tail;
	Str2->curlen = a->curlen + b->curlen;
}

void Sub_String(pLString Str,pLString Str1,int pos,int len)
{
	int i,j,k,l=0;
	char *ctemp = (char*)malloc(len*sizeof(char));
	if(empty(Str))
	{
		printf("串为空!\n");
		exit(-1);
	}
	if(pos<=0 || pos>Str->curlen || len+pos-1>Str->curlen || len<0)
	{
		printf("位置和长度范围错误!\n");
		exit(-1);
	}
	pChunk p = Str->head->pnext;
	i = pos/CHUNKSIZE;
	if((j = pos%CHUNKSIZE))
	{
		i++;
	}
	for(k=1;k<i;k++)
	{
		p = p->pnext;
	}
	for(k=j;k<CHUNKSIZE && l!=len;k++)
	{
		*(ctemp+l) = p->ch[k];
		l++;
	}
	p = p->pnext;
	while(l != len)
	{
		for(k=0;k<CHUNKSIZE && l!=len;k++)
		{
			*(ctemp+l) =  p->ch[k];
			l++;
		}
		p = p->pnext;
	}
	i = len/CHUNKSIZE;
	if(j = len%CHUNKSIZE)
	{
		i++;
	}
	pChunk ptemp = Str1->head;
	for(l=0;l<i;l++)
	{
		pChunk q = (pChunk)malloc(sizeof(Chunk));
		if(l!=i-1 || j==0 )
		{
			for(k=0;k<CHUNKSIZE;k++)
			{
				q->ch[k] = *ctemp++; 
			}
		}
		else
		{
			for(k=0;k<j;k++)
			{
				q->ch[k] = *ctemp++;
			}
			for(k=j;k<CHUNKSIZE;k++)
			{
				q->ch[k] = ' ';
			}
		}
		ptemp->pnext = q;
		ptemp = q;
	}
	Str1->tail = ptemp;
	Str1->tail->pnext = NULL;
	Str1->curlen = len;
}

int Index_String(pLString Str,pLString Str1,int pos)
{
	int i,j,k,postemp;
	if(pos<1 || pos>Str->curlen)
	{
		printf("位置范围错误!\n");
		exit(-1);
	}
	i = pos/CHUNKSIZE;
	if(j = pos%CHUNKSIZE)
	{
		i++;
	}
	pChunk p = Str->head->pnext,p1 = Str1->head->pnext,ptemp,p1temp;
	for(k=1;k<i;i++)
	{
		p = p->pnext;
	}
	p1temp = p1;
	ptemp = p;
	postemp = j;
	i = 0;
	while(1)
	{
		if(p1->ch[i] == p->ch[j])
		{
			if(p1 == Str1->tail && i == Str1->curlen%CHUNKSIZE)
				break;
			i++;
			j++;
			if(i == CHUNKSIZE && p1->pnext)
			{
				i = 0;
				p1 = p1->pnext;
			}
			if(j == CHUNKSIZE)
			{
				if(p->pnext)
				{
					j = 0;
					p = p->pnext;
				}
				else
				{
					return 0;
				}
			}
		}
		else
		{
			p = ptemp;
			p1 = p1temp; 
			postemp++;
			if(postemp == CHUNKSIZE)
			{
				if(p->pnext)
				{
					p = p->pnext;
					postemp = 0;
				}
				else
				{
					return 0;
				}
			}
			j = postemp;
		}
	}
	return postemp;
}

void Print_String(pLString Str)
{
	if(empty(Str))
	{
		printf("串为空!\n");
		exit(-1);
	}
	int i;
	pChunk p = Str->head->pnext;
	while(p)
	{
		for(i=0;i<CHUNKSIZE;i++)
		{
			printf("%c",p->ch[i]);
		}
		p = p->pnext;
	}
	printf("\n");
}

bool empty(pLString Str)
{
	if(Str->head == Str->tail)
	{
		return true;
	}
	else
	{
		return false;
	}
}

串的块链存储表示(自己写)
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#define CHUNKSIZE 4
#define MAXSIZE 20

typedef struct Chunk
{
	char ch[CHUNKSIZE];
	struct Chunk *pnext;
}Chunk,*pChunk;

typedef struct LString
{
	struct Chunk *head,*tail;
	int curlen;
}LString,*pLString;

pLString Init_String();
void Assign_String(pLString Str,char *p);
void Print_String(pLString Str);
void Clear_String(pLString Str);
void Copy_String(pLString Str,pLString Str1);
void Sub_String(pLString Str,pLString Str1,int pos,int len);
void Concat_String(pLString Str,pLString Str1,pLString Str2);
int Index_String(pLString Str,pLString Str1,int pos);
void Delete_String(pLString Str,int pos,int len);
void Zip_String(pLString Str);
void Insert_String(pLString Str,pLString Str1,int pos);
void Replace_String(pLString Str,pLString Str1,pLString Str2);

bool empty(pLString Str);

void main()
	{
	int pos,len;
	char c[MAXSIZE],*p;
	pLString Str,Str1,Str2,Str3;
	Str = Init_String();
	Str1 = Init_String();
	Str2 = Init_String();
	Str3 = Init_String();

	printf("请输入要分配的字符串a:");
	p = gets(c);
	Assign_String(Str,p);
	printf("字符串a为:");
	Print_String(Str);

	Copy_String(Str,Str1);
	printf("将字符串a复制到字符串b为:");
	Print_String(Str1);

	Concat_String(Str,Str1,Str2);
	printf("将字符串a与字符串b合并(不去除填充部分)c为:");
	Print_String(Str2);

	Clear_String(Str2);
	printf("求从a的第pos个字符起,长度为len的子串c,pos,len:");
	scanf("%d,%d",&pos,&len);
	Sub_String(Str,Str2,pos-1,len);
	printf("子串c为:");
	Print_String(Str2);

	printf("从主串a的pos后面找寻对用对应子串c位置:");
	scanf("%d",&pos);
	printf("子串c在主串a中的位置为%d:\n",Index_String(Str,Str2,pos-1));

	printf("从主串a的pos开始删除len长度:");
	scanf("%d,%d",&pos,&len);
	Delete_String(Str,pos-1,len);
	printf("删除后串a为:");
	Print_String(Str);

	fflush(stdin);
	printf("请输入要分配的字符串d:");
	p = gets(c);
	Assign_String(Str3,p);
	printf("字符串d为:");
	Print_String(Str3);
	printf("在串a的pos后插入串d:");
	scanf("%d",&pos);
	Insert_String(Str,Str3,pos-1);
	Print_String(Str);

	printf("用a代替b中的c为");
	Replace_String(Str1,Str,Str2);
	Print_String(Str1);
	
}

pLString Init_String()
{
	pLString Str = (pLString)malloc(sizeof(LString));
	pChunk pHeadnext = (pChunk)malloc(sizeof(Chunk));
	if(Str == NULL || pHeadnext == NULL)
	{
		printf("内存分配失败");
		exit(-1);
	}
	Str->curlen = 0;
	Str->head = Str->tail = pHeadnext;
	pHeadnext->pnext =NULL;
	return Str;
}

void Assign_String(pLString Str,char *p)
{
	int i,j,k;
	pChunk q,ptemp = Str->tail;
	i = strlen(p);							//strlen函数是判断以'\0'('\0'ascii为0)结尾前的总长度 用(char*)malloc(Str->curlen*sizeof(char))不是以'\0'结尾，所以不能用strlen(char型指针)
	if(!i ||strchr(p,' '))					//strche(p,' ');判断分配字符串中是否有' '
	{
		printf("输入错误!\n");
		exit(-1);
	}
	Str->curlen = i;
	j = i/CHUNKSIZE;
	if(i%CHUNKSIZE)
	{
		j++;
	}
	for(i=0;i<j;i++)
	{
		q = (pChunk)malloc(sizeof(Chunk));
		if(!q)
		{
			printf("内存分配失败!\n");
			exit(-1);
		}
		for(k=0;k<CHUNKSIZE && *p;k++)			//字符串数组未分配则是'空'   *p也可以等同于*p != ' '
		{
			q->ch[k] = *p++;
		}
		if(!*p)
		{
			Str->tail = q;
			q->pnext = NULL;
			for(;k<CHUNKSIZE;k++)
			{
				q->ch[k] = ' ';
			}
		}
		ptemp->pnext = q;
		ptemp = q;
	}
}

void Clear_String(pLString Str)
{
	pChunk p = Str->head->pnext,q;
	while(p)
	{
		q = p->pnext;
		free(p);
		p = q;
	}
	Str->curlen = 0;
	Str->head->pnext = NULL;
	Str->tail = Str->head;
}

void Copy_String(pLString Str,pLString Str1)
{
	int k;
	if(!empty(Str1))
	{
		Clear_String(Str1);
	}
	pChunk ptemp = Str1->head,p = Str->head->pnext;
	while(p)
	{
		pChunk q = (pChunk)malloc(sizeof(Chunk));
		if(!q)
		{
			printf("动态内存分配失败!\n");
			exit(-1);
		}
		for(k=0;k<CHUNKSIZE;k++)
		{
			q->ch[k] = p->ch[k];
		}
		ptemp->pnext = q;
		ptemp = q;
		p = p->pnext;
	}
	Str1->tail = ptemp;
	ptemp->pnext = NULL;
	Str1->curlen = Str->curlen;
}

void Concat_String(pLString Str,pLString Str1,pLString Str2)
{
	pLString a,b;
	a = Init_String();
	b = Init_String();
	Copy_String(Str,a);
	Copy_String(Str1,b);
	a->tail->pnext = b->head->pnext;
	Str2->head->pnext = a->head->pnext;
	Str2->tail = b->tail;
//	Zip_String(Str2);
	Str2->curlen = a->curlen + b->curlen;
}

void Sub_String(pLString Str,pLString Str1,int pos,int len)
{
	int i,j,k,l=0;
	char *ctemp = (char*)malloc(len*sizeof(char));
	if(empty(Str))
	{
		printf("串为空!\n");
		exit(-1);
	}
	if(pos<=0 || pos>Str->curlen || len+pos-1>Str->curlen || len<0)
	{
		printf("位置和长度范围错误(1)!\n");
		exit(-1);
	}
	pChunk p = Str->head->pnext;
	i = pos/CHUNKSIZE+1;
	j = pos%CHUNKSIZE;
	for(k=1;k<i;k++)
	{
		p = p->pnext;
	}
	for(k=j;k<CHUNKSIZE && l!=len;k++)
	{
		*(ctemp+l) = p->ch[k];
		l++;
	}
	p = p->pnext;
	while(l != len)
	{
		for(k=0;k<CHUNKSIZE && l!=len;k++)
		{
			*(ctemp+l) =  p->ch[k];
			l++;
		}
		p = p->pnext;
	}
	i = len/CHUNKSIZE;
	if(j = len%CHUNKSIZE)
	{
		i++;
	}
	pChunk ptemp = Str1->head;
	for(l=0;l<i;l++)
	{
		pChunk q = (pChunk)malloc(sizeof(Chunk));
		if(l!=i-1 || j==0 )
		{
			for(k=0;k<CHUNKSIZE;k++)
			{
				q->ch[k] = *ctemp++; 
			}
		}
		else
		{
			for(k=0;k<j;k++)
			{
				q->ch[k] = *ctemp++;
			}
			for(k=j;k<CHUNKSIZE;k++)
			{
				q->ch[k] = ' ';
			}
		}
		ptemp->pnext = q;
		ptemp = q;
	}
	Str1->tail = ptemp;
	Str1->tail->pnext = NULL;
	Str1->curlen = len;
}

int Index_String(pLString Str,pLString Str1,int pos)
{
	int i,j,k,postemp;
	if(pos<0 || pos>Str->curlen)
	{
		printf("位置范围错误(2)!\n");
		exit(-1);
	}
	i = pos/CHUNKSIZE+1;
	j = pos%CHUNKSIZE;
	pChunk p = Str->head->pnext,p1 = Str1->head->pnext,ptemp,p1temp;
	for(k=1;k<i;k++)
	{
		p = p->pnext;
	}
	p1temp = p1;
	ptemp = p;
	postemp = j;
	i = 0;
	k--;
	while(1)
	{
		if(p1 == Str1->tail && i == Str1->curlen%CHUNKSIZE)
				break;
		if(p1->ch[i] == p->ch[j])
		{
			i++;
			j++;
			if(i == CHUNKSIZE && p1->pnext)
			{
				i = 0;
				p1 = p1->pnext;
			}
			if(j == CHUNKSIZE)
			{
				if(p->pnext)
				{
					j = 0;
					p = p->pnext;
				}
				else
				{
					return 0;
				}
			}
		}
		else
		{
			p = ptemp;
			p1 = p1temp; 
			postemp++;
			if(postemp == CHUNKSIZE)
			{
				if(p->pnext)
				{
					p = p->pnext;
					postemp = 0;
					ptemp = p;
					k++;
				}
				else
				{
					return 0;
				}
			}
			j = postemp;
			i = 0;
		}
	}
	return k*4+postemp+1;
}

void Delete_String(pLString Str,int pos,int len)
{
	int i,j,k,l;
	if(pos<0 || pos>Str->curlen-1 || len<0 || len+pos>Str->curlen)
	{
		printf("位置和长度范围错误(3)!\n");
		exit(-1);
	}
	else
	{
		i = pos/CHUNKSIZE+1;
		j = pos%CHUNKSIZE;
		pChunk p = Str->head->pnext;
		for(k=1;k<i;k++)
		{
			p = p->pnext;
		}
		for(l=0;l<len;l++)
		{
			p->ch[j] = ' ';
			if(j<CHUNKSIZE-1)
			{
				j++;
			}
			else
			{
				p = p->pnext;
				j = 0;	
			}
		}
		Zip_String(Str);
	}
}

void Zip_String(pLString Str)
{
	int j,i=0;
	pChunk p = Str->head->pnext;
	char *q = (char*)malloc((Str->curlen+1)*sizeof(char));
	while(p)
	{
		for(j=0;j<CHUNKSIZE;j++)
		{
			if(p->ch[j] != ' ')
			{
				*(q+i) = p->ch[j];
				i++;
			}
		}
		p = p->pnext;
	}
	*(q+i) = 0;						//结束符号 *(q+i) = '\0';
	Clear_String(Str);
	Assign_String(Str,q);
}

void Insert_String(pLString Str,pLString Str1,int pos)
{
	if(pos<0 || pos>Str->curlen)
	{
		printf("位置范围错误(4)!\n");
		exit(-1);
	}
	else
	{
		int i,j,l,k,n=0;
		char *q = (char*)malloc((Str->curlen+Str1->curlen+1)*sizeof(char));
		pChunk p = Str->head;
		i = pos/CHUNKSIZE+1;
		j = pos%CHUNKSIZE;
		for(k=0;k<i;k++)
		{
			p = p->pnext;
			for(l=0;l<CHUNKSIZE;l++)
			{
				*(q+n) = p->ch[l];
				n++;
				if(l+1==j && k==i-1)
				{
					break;
				}
			}
			l = 0;
		}
		pChunk p1 = Str1->head->pnext;
		while(p1)
		{
			for(l=0;l<CHUNKSIZE;l++)
			{
				*(q+n) = p1->ch[l];
				n++;
				if(p1==Str1->tail && l+1==Str1->curlen%CHUNKSIZE)
				{
					break;
				}
			}
			l = 0;
			p1 = p1->pnext;
		} 
		while(p && n != Str->curlen+Str1->curlen)				//这里n != Str->curlen+Str1->curlen排除在结尾插入的情况(结尾插入提前判断if(p==Str->tail && j+1==Str->curlen%CHUNKSIZE))
		{
			for(;j<CHUNKSIZE;j++)
			{
				*(q+n) = p->ch[j];
				n++;
				if(p==Str->tail && j+1==Str->curlen%CHUNKSIZE)
				{
					break;
				}
			}
			j = 0;
			p = p->pnext;
		}
		*(q+n) = 0;	
		Clear_String(Str);
		Assign_String(Str,q);
	}
}


void Replace_String(pLString Str,pLString Str1,pLString Str2)
{
	int pos,i = 1;
	while((pos=Index_String(Str,Str2,i-1)) != 0)
	{
		Delete_String(Str,pos-1,Str2->curlen);
		Insert_String(Str,Str1,pos-1);
		i = pos + Str1->curlen;
	}
}

void Print_String(pLString Str)
{
	if(empty(Str))
	{
		printf("串为空!\n");
		exit(-1);
	}
	int i;
	pChunk p = Str->head->pnext;
	while(p)
	{
		for(i=0;i<CHUNKSIZE;i++)
		{
			printf("%c",p->ch[i]);
		}
		p = p->pnext;
	}
	printf("\n");
}

bool empty(pLString Str)
{
	if(Str->head == Str->tail)
	{
		return true;
	}
	else
	{
		return false;
	}
}

串的匹配算法
、#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define MAXSTRLEN 40

typedef char SString[MAXSTRLEN+1];

void StrAssign(SString T,char *chars);
void Get_next(SString T,int next[]);
int Index_KMP(SString S,SString T,int pos,int next[]);
int StrLength(SString T);
void StrPrint(SString T); 

void main()
{
	int i,j,*p,pos;
	char c[MAXSTRLEN+1];
	SString s1,s2;

	printf("请输主串s1:");
	gets(c);
	StrAssign(s1,c);
	StrPrint(s1);

	printf("请输子串s2:");
	gets(c);
	StrAssign(s2,c);
	StrPrint(s2);

	i = StrLength(s2);
	p = (int*)malloc(i*sizeof(int));
	Get_next(s2,p);
	for(j=1;j<=i;j++)
	{
		printf("%d ",*(p+j));
	}
	printf("\n");

	printf("请输入搜索开始的位置:");
	scanf("%d",&pos);
	i = Index_KMP(s1,s2,pos,p);
	if(i)
	{
		printf("主串和子串在第%d个字符串处首次匹配\n",i);
	}
	else
	{
		printf("主串和子串匹配不\n");
	}
}

void StrAssign(SString T,char *chars)
{
	if(strlen(chars)>MAXSTRLEN)
	{
		printf("串长超过MAXSTRLEN!\n");
		exit(-1);
	}
	else
	{
		T[0] = strlen(chars);
		for(int i=1;i<=T[0];i++)
		{
			T[i] = chars[i-1];
		}
	}
}

int StrLength(SString T)
{
	return T[0];
}

void StrPrint(SString T)
{
	for(int i=1;i<T[0]+1;i++)
	{
		printf("%c",T[i]);
	}
	printf("\n");
}

void Get_next(SString T,int next[])
{
	int i=1,j=0;
	next[1]=0;
	while(i<T[0])
	{
		if(j==0||T[i]==T[j])
		{
			i++;
			j++;
			next[i]=j;					//T[i]表示后缀的单个字符，T[j]表示前缀的单个字符
		}
		else
		{
			j=next[j];					//若字符不相同，则j值回溯
		}
	}
}
/*
当next重复出现一个数次时，相当于某个字母在重复出现，如s2：aabaaaabaa 3出现三次（为6、7、8三个位置）
在第一轮数字出排列完成之前，都是出现1 如s2：abcdabcd 1出现4次 （为2、3、4、5位置）

		{ 0 当j=1时
next[j] | MAX {K|1<k<j,且'P1......pk-1'='Pj-k+1......Pj-1'}当此集合不空时
		{ 1,其他情况

1.T="abcdex"
		j	123456
	模式串T abcdex
	next[j] 011111
1)当j=1时,next[1]=0;
2)当j=2时,j由1到j-1就只有字符"a",属于其他情况next[2]=1;
3)当j=3时,j由1到j-1串是"ab",显然"a"与"b"不相等,属其他情况,next[3]=1;
4)以后同理,所以最终此T串的next[j]为011111
2.T="abcabx"
		j	123456
	模式串T abcabx
	next[j] 011123
1)当j=1时,next[1]=0;
2)当j=2时,j由1到j-1就只有字符"a",属于其他情况next[2]=1;
3)当j=3时,j由1到j-1串是"ab",显然"a"与"b"不相等,属其他情况,next[3]=1;
4)当j=4时,同上,next[4]=1;
5)当j=5时,此时j由1到j-1的串是"abca",前缀字符"a"与后缀字符"a"相等,因此可以推算出k值为2（由'P1......pk-1'='Pj-k+1......Pj-1',得到p1=p4）因此next[5]=2;
6)当j=6时,j由1到j-1的串是"abcab",由于前缀字符"ab"与后缀"ab"相等,所以next[6]=3
*/

int Index_KMP(SString S,SString T,int pos,int next[])
{
	int i=pos,j=1;
	while(i<=S[0] && j<T[0])
	{
		if(j==0 || S[i]==T[j])
		{
			i++;
			j++;
		}
		else
		{
			j = next[j];			//j退回合适的位置,i的值不变
		}
	}
	if(j>T[0])
	{
		return i-j+1;
	}
	else
	{
		return 0;
	}
}

串的匹配改进算法
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define MAXSTRLEN 40

typedef char SString[MAXSTRLEN+1];

void StrAssign(SString T,char *chars);
void Get_next(SString T,int nextval[]);
int Index_KMP(SString S,SString T,int pos,int next[]);
int StrLength(SString T);
void StrPrint(SString T); 

void main()
{
	int i,j,*p,pos;
	char c[MAXSTRLEN+1];
	SString s1,s2;

	printf("请输主串s1:");
	gets(c);
	StrAssign(s1,c);
	StrPrint(s1);

	printf("请输子串s2:");
	gets(c);
	StrAssign(s2,c);
	StrPrint(s2);

	i = StrLength(s2);
	p = (int*)malloc(i*sizeof(int));
	Get_next(s2,p);
	for(j=1;j<=i;j++)
	{
		printf("%d ",*(p+j));
	}
	printf("\n");

	printf("请输入搜索开始的位置:");
	scanf("%d",&pos);
	i = Index_KMP(s1,s2,pos,p);
	if(i)
	{
		printf("主串和子串在第%d个字符串处首次匹配\n",i);
	}
	else
	{
		printf("主串和子串匹配不\n");
	}
}

void StrAssign(SString T,char *chars)
{
	if(strlen(chars)>MAXSTRLEN)
	{
		printf("串长超过MAXSTRLEN!\n");
		exit(-1);
	}
	else
	{
		T[0] = strlen(chars);
		for(int i=1;i<=T[0];i++)
		{
			T[i] = chars[i-1];
		}
	}
}

int StrLength(SString T)
{
	return T[0];
}

void StrPrint(SString T)
{
	for(int i=1;i<T[0]+1;i++)
	{
		printf("%c",T[i]);
	}
	printf("\n");
}

void Get_next(SString T,int nextval[])
{
	int i=1,j=0;
	nextval[1]=0;
	while(i<T[0])
	{
		if(j==0||T[i]==T[j])
		{
			i++;
			j++;
			if(T[i]!=T[j])
			{
				nextval[i]=j;
			}
			else
			{
				nextval[i]=nextval[j];
			}
		}
		else
		{
			j=nextval[j];
		}
	}
}
/*
1.T="ababaaaba"
			j	123456789			
		模式串T ababaaaba			aaaaax  看起来比较明显直接将重复的a的步骤直接去掉(ababaaaba中可以将"ab"看成一个整体"01"绑起来)
	    next[j] 011234223			000005	
	 nextval[j] 010104210
1)当j=1时,next[1]=0;
2)当j=2时,因为第二位字符"b"的next值是1,而第一位就是"a",他们不相等,所以nextval[2]=next[2]=1;
3)当j=3时,因为第三位字符"a"的next值为1,所以与第一位的"a"比较得知他们相等,所以nextval[3]=nextval[1]=0;如图
			j   123
			T   aba
	  next[j]   011---->次数是1,因此查看T[1]与本位置的T[3]是否相等
   nextval[j]   010---->因此T[1]=T[3],所以nextval[3]=nextval[1]=0
4)j=4时,第四位的字符"b"next值为2,所以与第二位的"b"相比较得到结果是相等,因此nextvak[4]=nextval[2]=1;如图
			j   1234
			T   abab
	  next[j]   0112--->次数是2,因此查看T[2]与本位置的T[4]是否相等
   nextval[j]   0101--->因为T[2]=T[4],所以nextval[4]=next[2]=1
5)当j=5时,next值为3,第五个字符"a"与第三个字符"a"相等,因此nextval[5]=nextval[3]=0;
6)当j=6时,next值为4,第六个字符"a"与第四个字符"b"不相等,因此nextval[6]=j=4(j当前的数值为4);
7)当j=7时,next值为2,第七个字符"a"与第二个字符"b"不相等,因此nextval[7]=j=2;
8)当j=8时,next值为2,第九个字符"b"与第三个字符"b"相等,因此nextval[8]=nextval[2]=1;
9)当j=9时,next值为3,第九个字符"a"与第三个字符"a"相等,因此nextval[9]=nextval[3]=1。
总结:改进过的KMP算法，他是在计算next值的同时，如果a位字符与他next值指向的b位字符相等,则该a位的nextval就指向b位的nextval值,如果不等,则
该a位的nextval值就是他自己a位的next的值
*/

int Index_KMP(SString S,SString T,int pos,int next[])
{
	int i=pos,j=1;
	while(i<=S[0] && j<T[0])
	{
		if(j==0 || S[i]==T[j])
		{
			i++;
			j++;
		}
		else
		{
			j = next[j];
		}
	}
	if(j>T[0])
	{
		return i-j+1;
	}
	else
	{
		return 0;
	}
}

串应用 文本编辑
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

#define MAX_LEN 25		//文件最大行数
#define LINE_LEN 75		//每行字符最大值+1
#define NAME_LEN 50		//文件名最大长度(包括盘符、路径)+1				//文件名数字数一定要确定够大 保证数组不溢出

typedef struct HString
{
	char *ch;
	int length;
}*pHString;

//全局变量
HString T[MAX_LEN];		//数组结构体变量
char str[LINE_LEN],filename[NAME_LEN];		//str[LINE_LEN]代表一个字符串长度
FILE *fp;
int N=0;		//文件行数

void Init_String(HString *Str);
void Assign_Str(HString *Str,char *t);
void Copy_Str(HString *Str,HString *Str1);
int Index_Str(HString *Str,HString *Str1,int pos);
void Delete_Str(HString *Str,int pos,int len);
void Insert_Str(HString *Str,HString *Str1,int pos);
void Print_Str(HString *Str);
void Input();
void Open();
void Insert();
void Delete();
void Copy();
void Modify();
void search();
void Replase();
void save();
void List();

void main()
{
	int s=1,i,k;
	for(i=0;i<MAX_LEN;i++)
	{
		Init_String(&T[i]);
	}
	while(s)
	{
		printf("请选择:    0.创建文件并且输入文本内容\n");
		printf("	   1.打开文件(新或旧) 2.显示文件内容\n");
		printf("	   3.插入行 4.删除行 5.拷贝行 6修改行\n");
		printf("	   7.查找字符串 8.替换字符串\n");
		printf("	   9.存盘退出 10.放弃编辑\n");	
		scanf("%d",&k);
		switch(k)
		{
		case 0:Input();break;
		case 1:Open();break;
		case 2:List();break;
		case 3:Insert();break;
		case 4:Delete();break;
		case 5:Copy();break;
		case 6:Modify();break;
		case 7:search();break;
		case 8:Replase();break;
		case 9:save();break;
		case 10:s=0;break;
		}
	}
} 

void Input()
{
	printf("请输入要打开:");
	scanf("%s%*c",filename);
	if((fp = fopen(filename,"r+")) == NULL)
	{
		fprintf(stderr,"file open err!\n");
		return;
	}
	else
	{
		printf("请输入要存储的数据!\n");
		do{
			scanf("%s%*c",str);		//这里的字符串str从赋值开始就以'\0'
			fputs(str,fp);
			fprintf(fp,"\n");		//文件中换行
			printf("单回车换行继续输入(输入其他字符回车自动结束)");
		}while(getchar() == '\n');
	}
	memset(filename, 0, sizeof(filename));		//初始化数组为'0'
	memset(str,0,sizeof(str));
	fclose(fp);
}

void Open()			
{
	if(filename[0])			//这里要求文件的首字符不为"0"(存在于文件夹中文件的首字符一定不为"0")
	{
		printf("已存在打开的文件!\n");
	}
	else
	{
		printf("请输入要打开的文件名(可包括盘符、路径、不超过%d个字符):",NAME_LEN-1);		//NAME_LEN-1原因为字符串末尾有结束符号
		scanf("%s%*c",filename);		//%*c是为了去除字符串结尾的结束符，确保下次输入不被直接跳过
		if(fp = fopen(filename,"r"))
		{
			printf("文件打开成功!\n");
			while (!feof(fp) && !ferror(fp))			//feof(fp)判断文件是否到达结尾 ferror(fp)判断文件是否出错
			{
				strcpy(str,"\n");						//详细见fgets函数详解
				fgets(str,LINE_LEN,fp);										
				Assign_Str(&T[N],str);
				N++;
				if(N>=MAX_LEN)
				{
					printf("文件太大!\n");
					return;
				}
			}
			fclose(fp);
		}
		else
		{
			printf("文件打开失败，请重输入文件名!\n");
		}
	}
	memset(filename, 0, sizeof(filename));
	memset(str,0,sizeof(str));
	fclose(fp);						//关闭文件完成文件名初始化
}

void Insert()
{
	int x,y,k;
	printf("请在第X行前插入Y行，请输入X.Y:");
	scanf("%d,%d",&x,&y);
	if(y+N>NAME_LEN)
	{
		printf("插入行数太多!\n");
		return;
	}
	if(x>1 && x<N-1)
	{
		for(int i=N-1;i>=x-1;i--)
		{
			T[i+y] = T[i];
		}
		N+=y;
		fflush(stdin);
		printf("请输入要插入的内容:\n");
		for(i=x-1;i<x-1+y;i++)
		{
			gets(str);
			k = strlen(str);
			str[k] = '\n';
			Init_String(&T[i]);
			Assign_Str(&T[i],str);
		}
	}
	else
	{
		printf("插入行超过范围!\n");
	}
	memset(str,0,sizeof(str));
}

void Delete()
{
	int x,y,i;
	printf("从第X行开始删除Y行，请输入X.Y:");
	scanf("%d,%d",&x,&y);
	if(x>0 && x+y-1<N)
	{
		for(i=y+x-1;i<=N;i++)
		{
			T[i-y] = T[i];
		}
		for(i=N-y;i<N;i++)
		{
			Init_String(&T[i]);
		}
		N-=y;
	}
	else
	{
		printf("删除行超过范围!\n");
		return;
	}
}

void Copy()
{
	int x,y,z,i;
	printf("从第X行起复制Y行插入在原Z行之前:请输入下x.y.z:");
	scanf("%d,%d,%d",&x,&y,&z);
	if(x+y-1<N && (x>0&&x<N-1) && (z>0&&z<N-1) && z+y<MAX_LEN)
	{
		HString Q[MAX_LEN];		//结构体数组(归结到数组中，函数结束后自动释放)
		for(i=0;i<y;i++)
		{
			Init_String(&Q[i]);
			Copy_Str(&Q[i],&T[x-1+i]);
		}
		for(i=N-1;i>=z-1;i--)
		{
			T[i+y] = T[i];
		}
		for(i=0;i<y;i++)
		{
			T[i+z-1] = Q[i]; 
		}
	}
	else
	{
		printf("复制错误!\n");
		return;
	}
}

void Modify()
{
	int x,k;
	printf("请输入待修改的行号X:");
	scanf("%d",&x);
	if(x>0 && x<N)
	{
		printf("第X行的内容为:");
		Print_Str(&T[x-1]);
		fflush(stdin);
		printf("请输入修改的内容:");
		gets(str);
		k = strlen(str);
		str[k] = '\n';
		Assign_Str(&T[x-1],str);
	}
	else
	{
		printf("行号超出范围!\n");
	}
}

void search()
{
	int i,k;
	char b;
	printf("请输入要查找的字符串:");
	scanf("%s%*c",str);
	HString s;
	Init_String(&s);
	Assign_Str(&s,str);
	for(i=0;i<N;i++)
	{
		k = 1;
		while(k)
		{
			k = Index_Str(&T[i],&s,k);
			if(k)
			{
				printf("第%d行:",i+1);
				Print_Str(&T[i]);
				printf("第%d个字符处找到,是否继续(Y/N)?:",k);
				scanf("%c%*c",&b);
				if(b=='Y' || b=='y')
				{
					k++;
				}
				else
				{
					i = N+i;
					break;
				}
			}
		}
	}
}

void Replase()
{
	int i,k;
	char b;
	HString s,t;
	printf("请输入待代替的字符串:");
	scanf("%s%*c",str);
	Init_String(&s);
	Assign_Str(&s,str);
	printf("请输入替换字符:");
	scanf("%s%*c",str);
	Init_String(&t);
	Assign_Str(&t,str);
	for(i=0;i<N;i++)
	{
		k = 1;
		while(k)
		{
			k = Index_Str(&T[i],&s,k);
			if(k)
			{
				printf("第%d行:",i+1);
				Print_Str(&T[i]);
				printf("第%d个字符处找到,是否替换(Y/N)?:",k);
				scanf("%c%*c",&b);
				if(b=='Y' || b=='y')
				{
					Delete_Str(&T[i],k,s.length);
					Insert_Str(&T[i],&t,k);
				}
				printf("是否继续替换(Y/N)?:");
				scanf("%c%*c",&b);
				if(b=='Y' || b=='y')
				{
					k = s.length+k;
				}
				else
				{
					i = N+i;
					break;
				}
			}
		}
	}
}

void save()
{
	int i;
	printf("请输入要打开:");
	scanf("%s%*c",filename);
	if((fp = fopen(filename,"w")) == NULL)
	{
		fprintf(stderr,"file open err!\n");
		return;
	}
	else
	{
		for(i=0;i<N;i++)
		{
			T[i].ch[T[i].length] = '\0';
			fputs(T[i].ch,fp);			//fputs以'\0'为结尾 这里T[i]字段结尾没有'\0'
		}
	}
	memset(filename, 0, sizeof(filename));
	fclose(fp);

}

void List()
{
	int i;
	for(i=0;i<N;i++)
	{
		printf("%d: ",i+1);
		Print_Str(&T[i]);
	}
}

void Init_String(HString *Str)
{
	Str->ch = NULL;
	Str->length = 0;
}

void Assign_Str(HString* Str,char *t)
{
	int i,j;
	if(Str->ch)
	{
		free(Str->ch);
	}
	i = strlen(t);
	if(i)
	{
		Str->ch = (char*)malloc(i*sizeof(char));
		if(!Str->ch)
		{
			printf("分配空间失败!\n");
			exit(-1);
		}
		for(j=0;j<i;j++)
		{
			Str->ch[j] = t[j];
		}
		Str->length = i;
	}
	else
	{
		printf("串为空!\n");
	}
}

void Copy_Str(HString *Str,HString *Str1)
{
	Str->ch = (char*)malloc(Str1->length*sizeof(char));
	if(Str->ch == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	else
	{
		for(int i=0;i<Str1->length;i++)
		{
			Str->ch[i] = Str1->ch[i];
		}
		Str->length = Str1->length;
	}
}

void Delete_Str(HString *Str,int pos,int len)
{
	if(pos>=1 && pos<=Str->length)
	{
		for(int i=0;i<Str->length-pos+1-len;i++)
		{
			Str->ch[pos-1+i] = Str->ch[pos-1+i+len];
		}
		Str->length = Str->length - len;
	}
	else
	{
		printf("删除范围错误!\n");
		exit(-1);
	}
}

void Insert_Str(HString *Str,HString *Str1,int pos)
{
	if(pos>=0 && pos<Str->length)
	{
		for(int i=Str->length-1;i>=pos-1;i--)
		{
			Str->ch[i+Str1->length] = Str->ch[i];
		}
		for(i=0;i<Str1->length;i++)
		{
			Str->ch[pos+i-1] = Str1->ch[i];
		}
		Str->length = Str->length + Str1->length;
	}
	else
	{
		printf("插入范围错误!\n");
		exit(-1);
	}
}

int Index_Str(HString *Str,HString *Str1,int pos)
{
	int i = pos-1,j = 0;
	while(i<Str->length && j<Str1->length)
	{
		if(Str->ch[i] == Str1->ch[j])
		{
			j++;
			i++;
		}
		else
		{
			i = i-j+1;
			j = 0;
		}
	}
	if(j>=Str1->length)
	{
		return i - Str1->length + 1;
	}
	else
	{
		return 0;
	}
}

void Print_Str(HString *Str)
{
	if(Str->length == 0)
	{
		printf("串为空!\n");
		exit(-1);
	}
	else
	{
		for(int i=0;i<Str->length;i++)
		{
			printf("%c",Str->ch[i]);
		}
	}
}

串的应用 搜索引擎
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

#define MaxKeyNum 25	//索引表的最大容量(关键词的最大数)
#define MaxLineLen 51	//书目申(书名+书号)buf的最大长度
#define	MaxWordNum 10	//词表(一本书的关键词)的最大容量
#define MaxNoIdx 10		//常用词(仅指大写)的数量

//堆分配类型
typedef struct HString	
{
	char *ch;
	int length;
}*pHString;

//重定义线性链表
typedef struct Node
{
	int data;
	struct Node* pNext;
}Node,*pNode;

struct LinkList
{
	int len;
	struct Node* pNodeHead;
	struct Node* pNodeTail;
};

//搜索主要结构体
typedef struct WordListType		
{
	char *item[MaxWordNum];							//词表(字符串)指针数组	一个数组单元里面存放一个字符串地址
	int wornum;										//词的数量
}*pWordListType;

typedef struct NoIdxType
{
	char *item[MaxNoIdx];							//常用词表指针数组
	int wornum;										//词的数量
}*pNoIdxType;

typedef struct IdxTermType
{
	HString keyword;								//关键词(堆分配类型)
	LinkList* booklist;								//存放书号索引的链表
}*pIdxTermType;

typedef struct IdxListType
{
	IdxTermType item[MaxKeyNum+1];
	int wornum;										//关键词个数
}*pIdxListType;

//全局变量
char buf[MaxLineLen];								//当前书目串(包括'\0')
WordListType WDLIST;								//暂存一本书的词表
NoIdxType NOIDX;									//常用词表

//重新定义线性表函数
struct LinkList* init_struct();		//函数初始化
struct Node* Init_Node();					//线性链初始化
int MakeNode(pNode,int);				//线性链数值分配
void Append(LinkList*,pNode);			//线性链尾添加子链
//堆串的函数
void Init_String(HString*);				//串初始化
void Assign_Str(HString*,char*);		//串分配
int Compare_Str(HString*,HString*);		//两串大小比较
void Copy_Str(HString*,HString*);		//串的复制
//搜索主体函数
void InitIdxList(IdxListType*);
void ExtractKeyWord(int*);							//分配单行书目录到WDLIST
void InsIdxList(IdxListType*,int);					//将书号和关键词加入到IDXLIST
void GetWord(int,HString*);							//分配关键字到WD中
int Locate(IdxListType*,HString,int*);				//
void InsertNewKey(IdxListType*,int,HString);		//向Bookid.txt中插入关键词
void InsertBook(IdxListType*,int,int);				//向Bookid.txt中插入书目录
void PutText(FILE*,IdxListType*);

void main()
{
	FILE *fp;
	IdxListType IDXLIST;	//关键词表
	int BookNo;
	int k,i;

//将常用词语存储到NOIDX结构体文件中
	if((fp=fopen("NoIdx.txt","r")) == NULL)
	{
		exit(-1);
	}
	fscanf(fp,"%d",&NOIDX.wornum);
	for(k=0;k<NOIDX.wornum;k++)
	{
		fscanf(fp,"%s",buf);
		i = strlen(buf);
		NOIDX.item[k] = (char*)malloc(i*sizeof(char));
		strcpy(NOIDX.item[k],buf);
	}
	fclose(fp);

//初始化搜索表idxlist为空
	if((fp=fopen("BookInfo.txt","r")) == NULL)
	{
		exit(-1);
	}
	InitIdxList(&IDXLIST);

//分配数据到IDXLIST
	while (!feof(fp) && !ferror(fp))			
	{
		fgets(buf,MaxLineLen,fp);
		ExtractKeyWord(&BookNo);
		InsIdxList(&IDXLIST,BookNo);
	}
	fclose(fp);

//将IDXLIST中的数据分配到BookIdx.txt文件中
	fp = fopen("BookIdx.txt","w");
	if(!fp)
	{
		exit(-1);
	}
	PutText(fp,&IDXLIST);
	fclose(fp);
}

//搜索函数
void InitIdxList(IdxListType *TemList)
{
	int i;
	for(i=0;i<MaxKeyNum+1;i++)
	{
		TemList->item[i].booklist = init_struct();
		Init_String(&TemList->item[i].keyword);
		TemList->wornum = 0;
	}
}

void ExtractKeyWord(int *BookNo)		//提取书名
{
	int i,k,f=1;
	char *s1,*s2;
	for(i=0;i<WDLIST.wornum;i++)
	{
		free(WDLIST.item[i]);		//这里出现DAMAGE: after Normal block错误原因是因为free()释放了未被赋值的数组，比如（a[5]=5。使用c++的同学都知道，一个5维的动态数组，调用时应该是0~4，但是这里给a[5]赋值并没有出错，反而是delete时才会出错）
		WDLIST.item[i] = NULL;
	}
	WDLIST.wornum = 0;				//初始化词表长度为0(方便将待搜索词表存放进来)
	*BookNo = 100*(buf[0]-'0')+10*(buf[1]-'0')+(buf[2]-'0');
	s2 = &buf[2];
	do								//提取书名的字母字符(算法)
	{
		s1 = s2+1;					//s1向后移动一个单词
		s2 = strchr(s1,' ');		//s2指向s1的第一个空格，如没有，返回NULL
		if(!s2)
		{
			s2 = strchr(s1,'\n');		//s2指向buf的最后一个字符('\n')
			if(!s2)
			{
				s2 = strchr(s1,'\0');
			}
			f = 0;
		}
		k = s2-s1;
		if(s1[0]>='A'&& s1[0]<='Z')	//单词首字母为大写
		{
			WDLIST.item[WDLIST.wornum] = (char*)malloc((k+1)*sizeof(char));
			for(i=0;i<k;i++)
			{
				WDLIST.item[WDLIST.wornum][i] = s1[i];
			}
			WDLIST.item[WDLIST.wornum][k] = '\0';
			for(i=0;i<NOIDX.wornum;i++)
			{
				if(!strcmp(WDLIST.item[WDLIST.wornum],NOIDX.item[i]))
				{
					printf("单词为常用词!\n");
					break;
				}
			}
			if(i != NOIDX.wornum)
			{
				free(WDLIST.item[WDLIST.wornum]);
				WDLIST.item[WDLIST.wornum] = NULL;
			}
			else
			{
				WDLIST.wornum++;	
			}
		}
	}while(f);
}

void InsIdxList(IdxListType *IDXLIST,int BookNo)
{
	int i,b,j;
	HString WD;
	Init_String(&WD);
	for(i=0;i<WDLIST.wornum;i++)
	{
		GetWord(i,&WD);
		j = Locate(IDXLIST,WD,&b);
		if(!b)
		{
			InsertNewKey(IDXLIST,j,WD);
		}
		InsertBook(IDXLIST,j,BookNo);
	}
}

void GetWord(int i,HString* WD)		//分配关键字到WD中
{
	Assign_Str(WD,WDLIST.item[i]);
}

int Locate(IdxListType *IDXLIST,HString WD,int *b)
{
	int i,m=0;
	for(i=IDXLIST->wornum;(m = Compare_Str(&IDXLIST->item[i].keyword,&WD))>0;--i);		//这里StrCompare()函数的目的是为了确定IDXLIST.item[i].keyword为空，方便下一步的Bookid表的存储
	if(m == 0)
	{
		*b = 1;
		return i;
	}
	else
	{
		*b = 0;
		return i+1;
	}
}

void InsertNewKey(IdxListType *IDXLIST,int i,HString WD)		
{
	int j;
	IDXLIST->item[IDXLIST->wornum+1].booklist = init_struct();	//IDXLIST.wornum留下来当成关键词个数
	for(j=IDXLIST->wornum;j>=i;--j)								
	{
		IDXLIST->item[j+1] = IDXLIST->item[j];
	}
	Init_String(&IDXLIST->item[i].keyword);
	Copy_Str(&IDXLIST->item[i].keyword,&WD);
	IDXLIST->item[i].booklist = init_struct();
	IDXLIST->wornum++;
}

void InsertBook(IdxListType *IDXLIST,int j,int BookNo)
{
	 pNode p;											
	 p = Init_Node();
	 if(!MakeNode(p,BookNo))
	 {
		 exit(-1);
	 }
	 Append(IDXLIST->item[j].booklist,p);
}

void PutText(FILE *fp,IdxListType *IDXLIST)
{
	pNode p;
	fprintf(fp,"%d\n",IDXLIST->wornum);
	for(int i=1;i<=IDXLIST->wornum;i++)
	{
		p = IDXLIST->item[i].booklist->pNodeHead->pNext;
		fprintf(fp,"%d\n",IDXLIST->item[i].booklist->len);
		for(int j=0;j<IDXLIST->item[i].booklist->len;j++)
		{
			fprintf(fp,"%d ",p->data);
			p = p->pNext;	
		}
		for(j=0;j<IDXLIST->item[i].keyword.length;j++)
		{
			fprintf(fp,"%c",IDXLIST->item[i].keyword.ch[j]);
		}
		fprintf(fp,"\n");
	}
}

//堆串的函数
void Init_String(HString *Str)						//函数初始化
{
	Str->ch = NULL;
	Str->length = 0;
}

void Assign_Str(HString* Str,char *t)				//分配字符
{
	int i,j;
	if(Str->ch)
	{
		free(Str->ch);
	}
	i = strlen(t);
	if(i)
	{
		Str->ch = (char*)malloc(i*sizeof(char));
		if(!Str->ch)
		{
			printf("分配空间失败!\n");
			exit(-1);
		}
		for(j=0;j<i;j++)
		{
			Str->ch[j] = t[j];
		}
		Str->length = i;
	}
	else
	{
		printf("串为空!\n");
	}
}

int Compare_Str(HString *Str,HString *Str1)			//比较字符串大小
{
	for(int i=0;i<Str->length && i<Str1->length;i++)
	{
		if(Str->ch[i] != Str1->ch[i])
		{
			return Str->ch[i] - Str1->ch[i];
		}
	}
	return Str->length - Str1->length;
}

void Copy_Str(HString *Str,HString *Str1)			//串复制
{
	Str->ch = (char*)malloc(Str1->length*sizeof(char));
	if(Str->ch == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	else
	{
		for(int i=0;i<Str1->length;i++)
		{
			Str->ch[i] = Str1->ch[i];
		}
		Str->length = Str1->length;
	}
}

//重新定义线性表函数
struct LinkList* init_struct()						//函数初始化
{
	LinkList* TempPhead = (LinkList*)malloc(sizeof(LinkList));
	pNode pfirst = (pNode)malloc(sizeof(Node));
	if(TempPhead == NULL || pfirst == NULL)
	{
		printf("表头类型失败!\n");
		exit(-1);
	}
	else
	{
		TempPhead->pNodeHead = pfirst;
		TempPhead->pNodeTail = pfirst;
		TempPhead->len = 0;
		pfirst->pNext = NULL;
	}
	return TempPhead;
}

struct Node* Init_Node()
{
	pNode p = (pNode)malloc(sizeof(Node));
	if(!p)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	p->data = NULL;
	p->pNext = NULL;
	return p;
}

int MakeNode(pNode p,int e)
{
	if(!p)
	{
		return -1;
	}
	p->data = e;
	return 1;
}

void Append(LinkList* L, pNode p)
{
	L->pNodeTail->pNext = p;
	L->pNodeTail = p;
	L->len = L->len+1;
}

/*
正确答案:
void InsertBook(IdxListType *IDXLIST,int j,int BookNo)
{
	 pNode p;											
	 p = Init_Node();
	 if(!MakeNode(p,BookNo))
	 {
		 exit(-1);
	 }
	 Append(IDXLIST->item[j].booklist,p);
}
错误答案:
void InsertBook(IdxListType *IDXLIST,int j,int BookNo)
{
	 Node p;											
	 Init_Node(&p);
	 if(!MakeNode(&p,BookNo))
	 {
		 exit(-1);
	 }
	 Append(IDXLIST->item[j].booklist,&p);
}
错误答案解析:在子函数中Nope p在子函数结束的时候会被释放连带这malloc也自动释放，所以数据丢失，而用pNode p在子函数结束的时候p地址被释放malloc未被释放，数据不会丢失
*/

/*
关于子函数赋值与调用问题细解
方法一:(错误方法)
void init_struct(struct LinkList*);	

void main
{
	LinkList *phead;
	init_struct(phead);
	
}

void init_struct(struct LinkList* TempPhead)		//函数初始化
{
	TempPhead = (LinkList*)malloc(sizeof(LinkList));
	pNode pfirst = (pNode)malloc(sizeof(Node));
	if(TempPhead == NULL || pfirst == NULL)
	{
		printf("表头类型失败!\n");
		exit(-1);
	}
	else
	{
		TempPhead->pNodeHead = pfirst;
		TempPhead->pNodeTail = pfirst;
		TempPhead->len = 0;
		pfirst->pNext = NULL;
	}
}
原因:主函数LinkList *phead;赋予的是一个头文件的地址
	 子函数void init_struct(struct LinkList* TempPhead)中形参TempPhead在文件结束的时候自动释放
改正:在子函数中设定一个struct LinkList*结构的返回地址,让主函数的pHead指向返回地址
	(返回地址在子函数运行时已经分配空间,子函数运行完成后临时参数地址TempPhead被释放,但分配的内存空间并不会被释放),
	pHead指向分配的内存空间
struct LinkList init_struct(struct LinkList*);	

void main
{
	LinkList *phead;
	init_struct(phead);
	
}

struct LinkList init_struct(struct LinkList* TempPhead)		//函数初始化
{
	TempPhead = (LinkList*)malloc(sizeof(LinkList));
	pNode pfirst = (pNode)malloc(sizeof(Node));
	if(TempPhead == NULL || pfirst == NULL)
	{
		printf("表头类型失败!\n");
		exit(-1);
	}
	else
	{
		TempPhead->pNodeHead = pfirst;
		TempPhead->pNodeTail = pfirst;
		TempPhead->len = 0;
		pfirst->pNext = NULL;
	}
	return TempPhead;
}
方法二:(正确方法)
void init_struct(struct LinkList*);	

void main
{
	LinkList phead;
	init_struct(&phead);
	
}

void init_struct(struct LinkList* TempPhead)		//函数初始化
{
	TempPhead = (LinkList*)malloc(sizeof(LinkList));
	pNode pfirst = (pNode)malloc(sizeof(Node));
	if(TempPhead == NULL || pfirst == NULL)
	{
		printf("表头类型失败!\n");
		exit(-1);
	}
	else
	{
		TempPhead->pNodeHead = pfirst;
		TempPhead->pNodeTail = pfirst;
		TempPhead->len = 0;
		pfirst->pNext = NULL;
	}
}
这种方法是主函数直接LinkList phead,子函数调用pHead地址,这样不存在地址丢失问题而初始化失败
*/

数组的顺序表示和实现
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdarg.h>
#define DIM 8

typedef struct Array
{
	int *base;			//数组元素地址
	int dim;			//数组维数
	int *bounds;		//数组维界地址
	int *constans;		//数组映像函数常量地址
}*pArray;
/*
假设Array = Arr[2][3][4] 则bounds中存放(2,3,4);
对于二维数组来说，Arr.constans[1]是每个元素所占的长度，Arr.constans[0]是每行元素所占的长度，故对于第i行j列的元素，在数组的位置为
(i*Arr.constans[0]+j*Arr.constans[1]),多维数组可以一次类推。对于每维确定的数组，若提前计算好(初始化数组时)constans的各个值，在求
基址时带入公式计算
*/

struct Array* Init_Arr(int,...);
void Assign(pArray,int,...);
int Value(pArray,...);
void Locate(pArray,va_list,int*);

void main()
{
	int i,j,k,e,dim=3,bounds1=2,bounds2=3,bounds3=4;
	pArray Arr;
	Arr = Init_Arr(dim,bounds1,bounds2,bounds3);
	printf("Arr->bounds = ");
	for(i=0;i<Arr->dim;i++)
	{
		printf("%d ",Arr->bounds[i]);
	}
	printf("\nArr->constans = ");
	for(i=0;i<Arr->dim;i++)
	{
		printf("%d ",Arr->constans[i]);
	}
	printf("\n");
	for(i=0;i<bounds1;i++)
	{
		for(j=0;j<bounds2;j++)
		{
			for(k=0;k<bounds3;k++)
			{
				Assign(Arr,i*100+j*10+k,i,j,k);
				e = Value(Arr,i,j,k);
				printf("Arr[%d][%d][%d] = %d ",i,j,k,e);
			}
			printf("\n");
		}
		printf("\n");
	}
}

struct Array* Init_Arr(int dim,...)
{
	int elemtotal=1;
	va_list ap;
	va_start(ap,dim);								//va_start();自动采集传给本函数的可变参数，并连带他的数目
	if(dim<1 || dim>DIM)
	{
		printf("数组维数超过范围!\n");
		exit(-1);
	}
	pArray Arr = (pArray)malloc(sizeof(Array)*1);
	Arr->dim = dim;
	if(!(Arr->bounds = (int*)malloc(sizeof(int)*dim)))
	{
		printf("数组维界地址分配失败!\n");
		exit(-1);
	}
	for(int i=0;i<dim;i++)
	{
		Arr->bounds[i] = va_arg(ap,int);
		if(Arr->bounds[i]<0)
		{
			exit(-1);
		}
		elemtotal *= Arr->bounds[i];				//元素的总数
	}
	va_end(ap);
	if(!(Arr->base = (int*)malloc(sizeof(int)*elemtotal)))
	{
		printf("数组元素分配失败!\n");
		exit(-1);
	}
	if(!(Arr->constans = (int*)malloc(sizeof(int*)*dim)))
	{
		printf("数组映像函数常量分配失败!\n");
		exit(-1);
	}
	Arr->constans[dim-1] = 1;
	for(i=dim-2;i>=0;--i)
	{
		Arr->constans[i] = Arr->constans[i+1] * Arr->bounds[i+1];
	}
	return Arr;
}

void Assign(pArray Arr,int e,...)
{
	int pos;
	va_list ap;
	va_start(ap,e);
	Locate(Arr,ap,&pos);
	*(Arr->base+pos) = e;
}

int Value(pArray Arr,...)
{
	int pos;
	va_list ap;
	va_start(ap,Arr);
	Locate(Arr,ap,&pos);
	return *(Arr->base+pos);
}

void Locate(pArray Arr,va_list ap,int* pos)
{
	int i,ind;
	*pos = 0;
	for(i=0;i<Arr->dim;i++)
	{
		ind = va_arg(ap,int);
		if(ind<0 || ind>=Arr->bounds[i])
		{
			exit(-1);
		}
		*pos += Arr->constans[i]*ind;
	}
}

/*
#include <stdarg.h>
#include <stdio.h>

void print(int arg,...)
{
	va_list ap;
	va_start(ap,arg);
	for(int i=0;i<arg;i++)
	{
		printf("%d ",va_arg(ap,int));
	}
	va_end(ap);
}

void main()
{
	print(4,1,2,3,4);
}
*/

稀疏矩阵
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdarg.h>

#define MAXSIZE 100

//二元矩阵单元
struct Triple
{
	int i,j;						
	int e;
}*pTriple;

//二元矩阵
typedef struct TSMatrix
{
	Triple data[MAXSIZE];			//data[i]代表矩阵中的单元
	int i,j,tu;						//行、列(限制二元矩阵的行、列数)、非零元素个数(规定二元矩阵中的元素)
}*pTSMatrix;

void CreateSMatrix(pTSMatrix);
void printSMatrix(pTSMatrix);
void CopySMatrix(TSMatrix,pTSMatrix);
void DestroySMatrix(pTSMatrix);
void AddSMatrix(pTSMatrix,pTSMatrix,pTSMatrix);
//int comp(int c1,int c2);
void SubtSMatrix(pTSMatrix,pTSMatrix,pTSMatrix);
void MultSMatrix(pTSMatrix,pTSMatrix,pTSMatrix);
void TransposeSMatrix(pTSMatrix,pTSMatrix);

void main()
{
	TSMatrix A,B,C;
	printf("创造矩阵A!\n");
	CreateSMatrix(&A);
	printSMatrix(&A);
	printf("由矩阵A复制矩阵B:\n");
	CopySMatrix(A,&B);
	printSMatrix(&B);
	DestroySMatrix(&B);
	printf("销毁矩阵后:\n");
	printSMatrix(&B);
	printf("创建矩阵B2:(与矩阵A的行、列数相同，行、列分别为%d,%d)\n",A.i,A.j);
	CreateSMatrix(&B);
	printSMatrix(&B);
/*	printf("矩阵C(A+B):\n");
	AddSMatrix(&A,&B,&C);
	printSMatrix(&C);
	DestroySMatrix(&C);
	printf("矩阵C2(A-B):\n");
	SubtSMatrix(&A,&B,&C);
	printSMatrix(&C);
	DestroySMatrix(&C);
	printf("矩阵C3(A的转置矩阵)\n");
	TransposeSMatrix(&A,&C);
	printSMatrix(&C);
	DestroySMatrix(&C);
	DestroySMatrix(&A);
	DestroySMatrix(&B);
	printf("创建矩阵A2:\n");
	CreateSMatrix(&A);
	printSMatrix(&A);
	printf("创建矩阵B3:(行数应与矩阵的A2的列数相同=%d)\n",A.j);
	CreateSMatrix(&B);
	printSMatrix(&B);
	printf("矩阵C5(A*B):\n");
*/	MultSMatrix(&A,&B,&C);
	printSMatrix(&C);
	DestroySMatrix(&C);
	DestroySMatrix(&A);
	DestroySMatrix(&B);
}

void CreateSMatrix(pTSMatrix TSM)
{
	int i,m,n,e,k;
	printf("请输入矩阵的行、列、非零元素个数:");
	scanf("%d,%d,%d",&TSM->i,&TSM->j,&TSM->tu);
	TSM->data[0].i = 0;
	for(i=1;i<=TSM->tu;i++)
	{
		do
		{
			printf("请按行顺序输入第%d个非零元素所在的行(1~%d),列(1~%d),元素值",i,TSM->i,TSM->j);
			scanf("%d,%d,%d",&m,&n,&e);
			k = 0;
			if(m<1 || m>TSM->i || n<1 || n>TSM->j)										//行或列超出范围
			{
				k = 1;
			}
			if(m<TSM->data[i-1].i ||(m == TSM->data[i-1].i&&n<=TSM->data[i-1].j))		//新输入的矩阵单元必须满足在此行不小于之前的数，或者不小于此行
			{
				k = 1;
			}
		}while(k);
		TSM->data[i].i = m;
		TSM->data[i].j = n;
		TSM->data[i].e = e;
	}
}

void CopySMatrix(TSMatrix A,pTSMatrix B)
{
	*B = A;								//这里是将里面的值copy,就算子函数结束了形参A,B都释放了也不影响
}

/*
TSMatrix A,B;
初始化是个结构体用
方法一:
void CopySMatrix(TSMatrix A,pTSMatrix B)
{
	*B = A;								
}
pTSMatrix A,B;
初始化是个结构体地址
方法二:
pTSMatrix CopySMatrix(pTSMatrix A,pTSMatrix B)
{
	B = A;
	return B;
}
*/

void AddSMatrix(pTSMatrix A,pTSMatrix B,pTSMatrix C)
{
	int i,j,x,y,k=1;
	for(i=1;i<=A->i;i++)
	{
		for(j=1;j<=A->j;j++)
		{
			x=1,y=1;
			while(x<=A->tu)
			{
				if(i==A->data[x].i && j==A->data[x].j)
				{
					break;	
				}
				x++;
			}
			while(y<=B->tu)
			{
				if(i==B->data[y].i && j==B->data[y].j)
				{
					break;	
				}
				y++;
			}
			if(x<=A->tu && y==B->tu+1)
			{
				C->data[k] = A->data[x];
				k++;
			}
			else if(x==A->tu+1 && y<=B->tu)
			{
				C->data[k] = B->data[y];
				k++;
			}
			else if(x<A->tu && y<B->tu)
			{
				if((C->data[k].e = A->data[x].e+B->data[y].e) != 0)
				{
					C->data[k].i = i;
					C->data[k].j = j;
					k++;
				}
			}
		}
	}
	C->i = A->i;
	C->j = A->j;
	C->tu = k;
}

/*
书本答案:
void AddSMatrix(pTSMatrix M,pTSMatrix N,pTSMatrix Q)
{
	Triple *Mp,*Me,*Np,*Ne,*Qh,*Qe;
	if(M->i != M->i)
	{
		return exit(-1);
	}
	if(M->j != M->i)
	{
		return exit(-1);
	}
	Q->i = M->i;
	Q->j = M->j;
	Mp = &M->data[1];		//Mp的初值指向矩阵M的非零元素首地址
	Np = &N->data[1];		//Np的初值指向矩阵N的非零元素首地址
	Me = &M->data[M->tu];	//Me指向矩阵M的非零元素尾地址
	Ne = &N->data[N->tu];	//Ne指向矩阵N的非零元素尾地址
	Qh = Qe = Q->data;		//Qh、Qe的初值指向矩阵Q的非零元素首地址的前一地址
	while(Mp<=Me && Np<=Ne)
	{
		Qe++;
		switch(comp(Mp->i,Np->i))
		{
		case 1:*Qe = *Mp;
				Mp++;
				break;
		case 0:switch(comp(Mp->j,Np->j))	//M、N矩阵当前非零元素的行相等，继续比较列
			   {
				case 1:*Qe = *Mp;
						Mp++;
						break;
				case 0:*Qe = *Mp;
						Qe->e += Np->e;
						if(!Qe->e)			//元素值为0，不存入压缩矩阵
						{
							Qe--;
						}
						Mp++;
						Np++;
						break;
				case -1:*Qe = *Np;
						Np++;
						break;
			   }
				break;
		case -1:*Qe = *Np;
				break;
		}
	}
	if(Mp>Me)		//矩阵M的元素全部处理完毕
	{
		while(Np<=Ne)
		{
			Qe++;
			*Qe = *Np;
			Np++;
		}
	}
	if(Np>Ne)
	{
		while(Mp<=Me)
		{
			Qe++;
			*Qe = *Mp;
			Mp++;
		}
	}
	Q->tu = Qe-Qh;	//矩阵Q的非零元素个数
}

int comp(int c1,int c2)
{
	int i;
	if(c1<c2)
	{
		i = 1;
	}
	else if(c1==c2)
	{
		i = 0;
	}
	else
	{
		i = -1;
	}
	return i;
}
*/

void SubtSMatrix(pTSMatrix A,pTSMatrix B,pTSMatrix C)
{
	int i;
	for(i=1;i<=B->tu;i++)
	{
		B->data[i].e *= -1; 
	}
	AddSMatrix(A,B,C);
}

void TransposeSMatrix(pTSMatrix A,pTSMatrix C)
{
	int q,p,col;
	C->i = A->j;
	C->j = A->i;
	C->tu = A->tu;
	if(C->tu)
	{
		q = 1;
		for(col=1;col<=A->j;col++)
		{
			for(p=1;p<=A->tu;p++)
			{
				if(A->data[p].j == col)					//按照data.j的数来排列行(这样就可以按CreateSMatrix函数中建立矩阵的顺序)
				{
					C->data[q].i = A->data[p].j;
					C->data[q].j = A->data[p].i;
					C->data[q].e = A->data[p].e;
					q++;
				}
			}
		}
	}
}

void MultSMatrix(pTSMatrix A,pTSMatrix B,pTSMatrix C)
{
	int i,j,l,sum,x,y,k=1;
	for(i=1;i<=A->i;i++)
	{
		for(l=1;l<=B->j;l++)
		{
			sum = 0;
			for(j=1;j<=A->j;j++)
			{
				x=1,y=1;
				while(x<=A->tu)
				{
					if(i==A->data[x].i && j==A->data[x].j)
					{
						break;	
					}
					x++;
				}
				if(x<=A->tu)
				{
					while(y<=B->tu)
					{
						if(l==B->data[y].j && j==B->data[y].i)
						{
							break;
						}
						y++;
					}
				}
				if(x<=A->tu && y<=B->tu)
				{
					sum = sum + A->data[x].e*B->data[y].e;
				}
			}
			if(sum != 0)
			{
				C->data[k].i = i;
				C->data[k].j = l;
				C->data[k].e = sum;
				k++;
			}
		}
	}
	C->i = C->j = A->i;
	C->tu = k;
}

/*
void MultSMatrix(pTSMatrix A,pTSMatrix B,pTSMatrix C)
{
	int i,j,h=A->i,l=B->j,Qn=0;				//h,l分别为矩阵Q的行、列值,Qn为矩阵Q的非零元素个数,初值为0
	int *Qe;
	if(A->j != B->i)
	{
		exit(-1);
	}
	C->i = A->i;
	C->j = B->j;
	Qe = (int *)malloc(h*l*sizeof(int));	//Qe为矩阵Q的临时数组
	//矩阵Q的第i行j列的元素值存于*(Qe+(i-1)*l+j-1)中，处值为0			数组Qe[0]代表第一行*第一列 Qe[1]代表第一行*第二列 Qe[2]、Qe[3]一次类推
	for(i=0;i<h*l;i++)
	{
		*(Qe+i) = 0;					//赋初值0
	}
	for(i=1;i<=A->tu;i++)				//矩阵元素相乘，结果累加到Qe
	{
		for(j=1;j<B->tu;j++)
		{
			if(A->data[i].j==B->data[j].i)							//A->data[i].j==B->data[j].i确定数组行列能相乘的关系
			{
				*(Qe+(A->data[i].i-1)*l+B->data[j].j-1) += A->data[i].e*B->data[j].e;		//A->data[i].i-1)*l+B->data[j].j-1确定对应行列相乘在数组Qe中的位置
			}
		}
	}
	for(i=1;i<=A->i;i++)
	{
		for(j=1;j<B->j;j++)
		{
			if(*(Qe+(i-1)*l+j-1)!=0)
			{
				Qn++;
				C->data[Qn].e = *(Qe+(i-1)*l+j-1);
				C->data[Qn].i = i;
				C->data[Qn].j = j;
			}
		}
	}
	free(Qe);
	C->tu = Qn;
}
*/

void printSMatrix(pTSMatrix TSM)
{
	int i,j,k;
	for(i=1;i<=TSM->i;i++)
	{
		for(j=1;j<=TSM->j;j++)
		{
			k=1;
			while(k<=TSM->tu)
			{
				if(i==TSM->data[k].i && j==TSM->data[k].j)
				{
					printf("%d ",TSM->data[k].e);
					break;
				}
				k++;
			}
			if(k>TSM->tu)
			{
				printf("0 ");
			}
		}
		printf("\n");
	}
	printf("\n");
}

/*
书本答案:
void printSMatrix(pTSMatrix TSM)
{
	int i;
	printf("%d行%d列%d个非零元素。\n",TSM->i,TSM->j,TSM->tu);
	printf("行 列 元素值\n");
	for(i=1;i<=TSM->tu)
	{
		printf("%2d%4d%8d\n",TSM->data[i].i,TSM->data[i].j,TSM->data[i].e);
	}
}
*/

void DestroySMatrix(pTSMatrix MS)
{
	MS->i = 0;
	MS->j = 0;
	MS->tu = 0;
}

快速求稀疏矩阵的转置矩阵
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdarg.h>

#define MAXSIZE 100

//二元矩阵单元
struct Triple
{
	int i,j;						
	int e;
}*pTriple;

//二元矩阵
typedef struct TSMatrix
{
	Triple data[MAXSIZE];			//data[i]代表矩阵中的单元
	int i,j,tu;						//行、列(限制二元矩阵的行、列数)、非零元素个数(规定二元矩阵中的元素)
}*pTSMatrix;

void CreateSMatrix(pTSMatrix);
void printSMatrix(pTSMatrix);
void FastTransposeSMatrix(pTSMatrix,pTSMatrix);
void DestroySMatrix(pTSMatrix);

void main()
{
	TSMatrix A,B;
	printf("创建矩阵A:");
	CreateSMatrix(&A);
	printSMatrix(&A);
	FastTransposeSMatrix(&A,&B);
	printf("矩阵B(A的快速转置):");
	printSMatrix(&B);
	DestroySMatrix(&A);
	DestroySMatrix(&B);

}

void CreateSMatrix(pTSMatrix TSM)
{
	int i,m,n,e,k;
	printf("请输入矩阵的行、列、非零元素个数:");
	scanf("%d,%d,%d",&TSM->i,&TSM->j,&TSM->tu);
	TSM->data[0].i = 0;
	for(i=1;i<=TSM->tu;i++)
	{
		do
		{
			printf("请按行顺序输入第%d个非零元素所在的行(1~%d),列(1~%d),元素值",i,TSM->i,TSM->j);
			scanf("%d,%d,%d",&m,&n,&e);
			k = 0;
			if(m<1 || m>TSM->i || n<1 || n>TSM->j)										//行或列超出范围
			{
				k = 1;
			}
			if(m<TSM->data[i-1].i ||(m == TSM->data[i-1].i&&n<=TSM->data[i-1].j))		//新输入的矩阵单元必须满足在此行不小于之前的数，或者不小于此行
			{
				k = 1;
			}
		}while(k);
		TSM->data[i].i = m;
		TSM->data[i].j = n;
		TSM->data[i].e = e;
	}
}

void FastTransposeSMatrix(pTSMatrix A,pTSMatrix B)
{
	int p,q,t,col,*num,*cpot;
	num = (int*)malloc((A->j+1)*sizeof(int));	//生成数组 记录三元数组非零元素列序号
	cpot = (int*)malloc((B->j+1)*sizeof(int));	//生成数组 记录转换后三元数组元素的位置(tu)
	B->i = A->j;
	B->j = A->i;
	B->tu = A->tu;
	if(B->tu)
	{
		for(col=1;col<=A->j;col++)
		{
			num[col] = 0;
		}
		for(t=1;t<=A->tu;j++)			//记录每一列非零元素的个数
		{
			++num[A->data[t].j]
		}
		cpot[1] = 1;
		for(col=2;col<=A->j;col++)
		{
			cpot[col] = cpot[col-1] + num[col-1];		//第col列中第一个非零元素在C->data中的序号
		}
		for(p=1;p<=A->tu;p++)
		{
			col = A->data[p].j;
			q = cpot[col];
			B->data[q].i = B->data[p].j;
			B->data[q].j = B->data[p].i;
			B->data[q].e = B->data[p].e;
			++cpot[col];
		}
	}
	free(num);
	free(cpot);
}

/*
原三元矩阵
i   j   v			i	j	v
1	2	12			1	3	-3
1	3	9			1	6	15
3	1	-3			2	1	12
3	6	14			2	5	18
4	3	24			3	1	9
5	2	18			3	4	24
6	1	15			4	6	-7
6	4	-7			6	3	14
1.++sum[A->data[t].j]代表矩阵列非零元素的个数的叠加 比如sum[1]=2 sum[2]=2 sum[3]=2 sum[4]=1 sum[6]=1
2.cpot数组代表新矩阵每列的的首个非零元素的位置(tu)
3.col = A->data[p].j;
q = cpot[col];找到新矩阵列的首位置(其他位置)的地址(tu)
++cpot[col];找到首地址(其他位置)后地址copt[col]自动加一，对应列的后一个地址，直到结束
(这里根据原三元矩阵可以看出按原顺序的i依次递增，这里可以不用考虑转换后顺序问题)
*/

void printSMatrix(pTSMatrix TSM)
{
	int i,j,k;
	for(i=1;i<=TSM->i;i++)
	{
		for(j=1;j<=TSM->j;j++)
		{
			k=1;
			while(k<=TSM->tu)
			{
				if(i==TSM->data[k].i && j==TSM->data[k].j)
				{
					printf("%d ",TSM->data[k].e);
					break;
				}
				k++;
			}
			if(k>TSM->tu)
			{
				printf("0 ");
			}
		}
		printf("\n");
	}
	printf("\n");
}

void DestroySMatrix(pTSMatrix MS)
{
	MS->i = 0;
	MS->j = 0;
	MS->tu = 0;
}

稀疏矩阵的三元组行逻辑链接的顺序存储表示
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdarg.h>

#define MAXSIZE 100		//非零元个数的最大值
#define MAXRC 20		//最大行列数

typedef struct Triple
{
	int i,j;			//行下标、列下标
	int e;				//非零元素值
}*pTriple;

typedef struct RLSMatrix
{
	Triple data[MAXSIZE+1];		//非零元三元组表，data[0]未用
	int rpos[MAXRC+1];			//各行第一个非零元素的位置表
	int mu,nu,tu;				//矩阵的行数、列数和非零元个数
}*pRLSMatrix;

void CreateSMatrix(pRLSMatrix);
void PrintSMatrix(pRLSMatrix);
void CopySMatrix(pRLSMatrix,pRLSMatrix);
void AddSMatrix(pRLSMatrix,pRLSMatrix,pRLSMatrix);
void DestroySMatrix(pRLSMatrix);
void SubtSMatrix(pRLSMatrix,pRLSMatrix,pRLSMatrix);
void TransposeSMatrix(pRLSMatrix,pRLSMatrix);
void MultSMatrix(pRLSMatrix,pRLSMatrix,pRLSMatrix);

void main()
{
	RLSMatrix A,B,C;
/*	printf("创建矩阵A:\n");
	CreateSMatrix(&A);
	PrintSMatrix(&A);
	printf("由矩阵A复制矩阵B:\n");
	CopySMatrix(&A,&B);
	PrintSMatrix(&B);
	DestroySMatrix(&B);
	printf("销毁矩阵B后:\n");
	PrintSMatrix(&B);
	printf("创建矩阵B2:(与矩阵A的行、列数相同，行列分别为%d,%d)\n",A.mu,A.nu);
	CreateSMatrix(&B);
	PrintSMatrix(&B);
	printf("矩阵C1(A+B):\n");
	AddSMatrix(&A,&B,&C);
	PrintSMatrix(&C);
	DestroySMatrix(&C);
	printf("矩阵C2(A+B):\n");
	SubtSMatrix(&A,&B,&C);
	PrintSMatrix(&C);
	DestroySMatrix(&C);
	printf("矩阵C3(A的转置):\n");
	TransposeSMatrix(&A,&C);
	PrintSMatrix(&C);
	DestroySMatrix(&C);
	DestroySMatrix(&B);
	DestroySMatrix(&A);
*/	printf("创建矩阵A2:\n");
	CreateSMatrix(&A);
	PrintSMatrix(&A);
	printf("创建矩阵B3:\n");
	CreateSMatrix(&B);
	PrintSMatrix(&B);
	printf("矩阵C5(A*B):\n");
	MultSMatrix(&A,&B,&C);
	PrintSMatrix(&C);
	DestroySMatrix(&C);
	DestroySMatrix(&B);
	DestroySMatrix(&A);
}

void CreateSMatrix(pRLSMatrix A)
{
	int k,i;
	Triple T;
	printf("请输入矩阵的行数，列数，非零元素数");
	scanf("%d,%d,%d",&A->mu,&A->nu,&A->tu);
	A->data[0].i = 0;		//为以下比较做准备
	for(i=1;i<=A->tu;i++)
	{
		do
		{
			printf("请按行顺序输入第%d个非零元素所在的行(1~%d),列(1~%d),元素值:",i,A->mu,A->nu);
			scanf("%d,%d,%d",&T.i,&T.j,&T.e);
			k = 0;
			if(T.i<1 || T.i>A->mu || T.j<1 || T.j>A->nu)
			{
				k = 1;
			}
			if(T.i<A->data[i-1].i || (T.i==A->data[i-1].i&&T.j<=A->data[i-1].j))
			{
				k = 1;
			}
		}while(k);
		A->data[i] = T;
	}
	for(i=1;i<=A->tu;i++)
	{
		if(A->data[i].i>A->data[i-1].i)
		{
			for(T.i=0;T.i<A->data[i].i-A->data[i-1].i;T.i++)
			{
				A->rpos[A->data[i].i - T.i] = i;
			}
		}
	}
	for(i=A->data[A->tu].i+1;i<=A->mu;i++)
	{
		A->rpos[i] = A->tu+1; 
	}
}
/*
矩阵A:
0 1 2 3
0 0 0 0
6 8 0 0
0 0 0 0
分析1.A->tu=1时,A->data[1].i=1,A->data[0]=0,所以A->data[1].i>A->data[0].i
	  for(T.i=0,T.i<A->data[1].i-A->data[0].i=1;T.i++)
	  A->rpos[A->data[i].i-T.i=1-0=1] = 1;
	  得出第一行第一个非零地址为A->rpos[1] = 1
	2.A->tu=2时,A->data[2].i=1,A->data[1]=1,所以A->data[2].i==A->data[1].i结束程序
	3.A->tu=3时同上
	4.A->tu=4时,A->data[4].i=3,A->data[3]=1,所以A->data[4].i>A->data[3].i
	  for(T.i=0,T.i<A->data[4].i-A->data[3].i=2;T.i++)
	  A->rpos[A->data[i].i-T.i=3-0=3] = 4;
	  得出第三行第一个非零地址为A->rpos[3] = 4;
	  T.i++;
	  A->rpos[A->data[i].i-T.i=3-1=2] = 4;
	  所以得出第二行首地址为A->rpos[2] = 4;
*/

void CopySMatrix(pRLSMatrix A,pRLSMatrix B)
{
	*B = *A;
}

void AddSMatrix(pRLSMatrix A,pRLSMatrix B,pRLSMatrix C)
{
	int k,p,q;
	if(A->mu!=B->mu || A->mu!=B->mu)
	{
		exit(-1);
	}
	C->mu = A->mu;
	C->nu = A->nu;
	C->tu = 0;
	A->rpos[A->mu+1] = A->tu+1;							//为方便后面的while循环临时设置
	B->rpos[B->mu+1] = B->tu+1;
	for(k=1;k<=A->mu;k++)								//对于每一行,k指示行号
	{
		C->rpos[k] = C->tu+1;
		p = A->rpos[k];									//p指出示M矩阵第k行当前元素的序号
		q = B->rpos[k];									//q指出示N矩阵第k行当前元素的序号
		while(p<A->rpos[k+1] && q<B->rpos[k+1])			//A,B矩阵均有第k行元素未处理
		{
			if(A->data[p].j == B->data[q].j)			//A矩阵当前元素和B矩阵当前元素的列相同
			{
				C->data[C->tu+1].e = A->data[p].e+B->data[q].e;
				if(C->data[C->tu+1].e!=0)
				{
					C->tu++;
					C->data[C->tu].i = k;
					C->data[C->tu].j = A->data[p].j;
				}
				p++;
				q++;
			}
			else if(A->data[p].j<B->data[q].j)			//A矩阵当前元素的列<B矩阵当前元素的列
			{
				C->tu++;
				C->data[C->tu].e = A->data[p].e;
				C->data[C->tu].i = k;
				C->data[C->tu].j = A->data[p].j;
				p++;
			}
			else										//A矩阵当前元素的列>B矩阵当前元素的列
			{
				C->tu++;
				C->data[C->tu].e = B->data[q].e;
				C->data[C->tu].i = k;
				C->data[C->tu].j = B->data[q].j;
				q++;
			}
		}
		while(p<A->rpos[k+1])							//处理A矩阵k行未处理的元素
		{
			C->tu++;
			C->data[C->tu].e = A->data[p].e;
			C->data[C->tu].i = k;
			C->data[C->tu].j = A->data[p].j;
			p++;
		}
		while(q<B->rpos[k+1])							//处理B矩阵k行未处理的元素
		{
			C->tu++;
			C->data[C->tu].e = B->data[q].e;
			C->data[C->tu].i = k;
			C->data[C->tu].j = B->data[q].j;
			q++;
		}
	}
}

void SubtSMatrix(pRLSMatrix A,pRLSMatrix B,pRLSMatrix C)
{
	int i;
	if(A->mu!=B->mu || A->nu!=B->nu)
	{
		exit(-1);
	}
	for(i=1;i<B->tu;i++)
	{
		B->data[i].e *= -1;
	}
	AddSMatrix(A,B,C);
}

void TransposeSMatrix(pRLSMatrix A,pRLSMatrix C)
{
	int i,k;
	C->tu = 0;
	for(k=1;k<=A->nu;k++)
	{
		C->rpos[k] = C->tu+1;		
		for(i=1;i<=A->tu;i++)
		{
			if(A->data[i].j == k)
			{
				C->data[C->tu+1].e = A->data[i].e;
				C->data[C->tu+1].j = A->data[i].i;
				C->data[C->tu+1].i = k;
				C->tu++;
			}
		}
	}
	C->mu = A->nu;
	C->nu = A->mu;
}

/*
void TransposeSMatrix(pRLSMatrix A,pRLSMatrix C)
{
	int p,q,t,col,*num;
	num = (int*)malloc(sizeof(int)*(A->nu+1));
	C->mu = A->nu;
	C->nu = A->mu;
	C->tu = A->tu;
	if(C->tu)
	{
		for(col=1;col<=A->nu;col++)
		{
			num[col] = 0;
		}
		for(t=1;t<=A->tu;t++)
		{
			num[A->data[t].j]++;							//求A中每一列非非零元素个数
		}
		C->rpos[1] = 1;
		for(col=2;col<=A->nu;col++)
		{
			C->rpos[col] = C->rpos[col-1]+num[col-1];	//求A中第col中的第一个非零元素C->data中的序号
		}
		for(col=1;col<=A->nu;col++)
		{
			num[col] = C->rpos[col];					//这个跟快速转置想法相同不同的是rpos这里作为结构体变量不能乱变，所以添加一步
		}
		for(p=1;p<=A->nu;p++)
		{
			col = A->data[p].j;
			q = num[col];
			C->data[q].i = A->data[p].j;
			C->data[q].j = A->data[p].i;
			C->data[q].e = A->data[p].e;
			num[col]++;
		}
	}
	free(num);
}
*/

void MultSMatrix(pRLSMatrix A,pRLSMatrix B,pRLSMatrix C)
{
	int arow,brow,p,q,ccol,ctemp[MAXRC+1];
	if(A->nu != B->mu)									//矩阵A的列数应和矩阵B的行数相等
	{
		exit(-1);
	}
	C->mu = A->mu;
	C->nu = B->nu;
	C->tu = 0;
	A->rpos[A->mu+1] = A->tu+1;
	B->rpos[B->mu+1] = B->tu+1;
	if(A->tu*B->tu != 0)
	{
		for(arow=1;arow<=A->mu;arow++)							//从A的第一行开始，到最后一行，arow是A的当前行
		{
			for(ccol=1;ccol<=B->nu;ccol++)
			{
				ctemp[ccol] = 0;
			}
			C->rpos[arow] = C->tu+1;							//C当前行的第一个元素位于上一行最后一个元素之后

			for(p=A->rpos[arow];p<A->rpos[arow+1];p++)			//对A当前行中每一个非零元素
			{
				brow = A->data[p].j;							//找到对应元素在B中的行数(与稀疏矩阵中MultSMatrix的A->data[i].j==B->data[j].i确定数组行列能相乘的关系相同)
				for(q=B->rpos[brow];q<B->rpos[brow+1];q++)		//找到B中对应行中的元素相乘
				{
					ccol = B->data[q].j;						//乘积元素在C中的列
					ctemp[ccol] += A->data[p].e*B->data[q].e;	//对应ctemp[ccol]的数值每次相加
				}
			}
			//	这个双循环代表两矩阵相乘后新矩阵每一排不同列的值
			for(ccol=1;ccol<=C->nu;ccol++)
			{
				C->tu++;
				if(C->tu>MAXSIZE)
				{
					exit(-1);
				}
				C->data[C->tu].i = arow;
				C->data[C->tu].j = ccol;
				C->data[C->tu].e = ctemp[ccol];
			}
		}
	}
}

void PrintSMatrix(pRLSMatrix TSM)
{
	int i,j,k;
	for(i=1;i<=TSM->mu;i++)
	{
		for(j=1;j<=TSM->nu;j++)
		{
			k=1;
			while(k<=TSM->tu)
			{
				if(i==TSM->data[k].i && j==TSM->data[k].j)
				{
					printf("%d ",TSM->data[k].e);
					break;
				}
				k++;
			}
			if(k>TSM->tu)
			{
				printf("0 ");
			}
		}
		printf("\n");
	}
	printf("\n");
}

/*
void PrintSMatrix(pRLSMatrix A)
{
	int i;
	printf("%d行%d列%d个非零元素。\n",A->mu,A->nu,A->tu);
	printf("行 列 元素值\n");
	for(i=1;i<=A->tu;i++)
	{
		printf("%2d%4d%8d\n",A->data[i].i,A->data[i].j,A->data[i].e);
	}
	for(i=1;i<=A->mu;i++)
	{
		printf("第%d行的第一个非零元素是本矩阵第%d个元素\n",i,A->rpos[i]);
	}
}
*/

void DestroySMatrix(pRLSMatrix A)
{
	A->mu = 0;
	A->nu = 0;
	A->tu = 0;
}

稀疏矩阵的十字链表存储
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdarg.h>

typedef struct OLNode
{
	int i,j;
	int e;
	struct OLNode *right,*down;
}*pOLNode;

typedef struct CrossList
{
	pOLNode *rhead,*chead;			//行和列链表头指向基地址(rhead,chead相当于数组，这里就是给头地址分配地址)
	int mu,nu,tu;
}*pCrossList;

void InitSMatrix(pCrossList);
void CreateSMatrix(pCrossList);
void DestroySMatrix(pCrossList);
void PrintSMatrix(pCrossList);
void CopySMatrix(pCrossList,pCrossList);
void AddSMatrix(pCrossList,pCrossList,pCrossList);
void SubtSMatrix(pCrossList,pCrossList,pCrossList);
void TransposeSMatrix(pCrossList,pCrossList);
void MultSMatrix(pCrossList,pCrossList,pCrossList);
void DelZero(pCrossList);

void main()
{
	CrossList A,B,C;
	InitSMatrix(&A);		//CrossList类型的变量在初次使用之前必须初始化
	InitSMatrix(&B);
/*	printf("创建矩阵A:");
	CreateSMatrix(&A);
	printf("矩阵A:\n");
	PrintSMatrix(&A);
	printf("由矩阵A复制矩阵B:\n");
	CopySMatrix(&A,&B);
	PrintSMatrix(&B);
	DestroySMatrix(&B);
	printf("销毁矩阵B后\n");
	PrintSMatrix(&B);
	printf("创建矩阵B2:(与矩阵A的行、列相同，行、列分别为)\n",A.mu,A.nu);
	CreateSMatrix(&B);
	printf("矩阵B2:\n");
	PrintSMatrix(&B);
	printf("矩阵C1(A+B):\n");
	InitSMatrix(&C);
	AddSMatrix(&A,&B,&C);
	PrintSMatrix(&C);
	DestroySMatrix(&C);
	printf("矩阵C2(A-B):\n");
	SubtSMatrix(&A,&B,&C);
	PrintSMatrix(&C);
	DestroySMatrix(&C);
	printf("矩阵C3(A的转置):\n");
	TransposeSMatrix(&A,&C);
	PrintSMatrix(&C);
	DestroySMatrix(&C);
	DestroySMatrix(&B);
	DestroySMatrix(&A);*/
	printf("创建矩阵A2:\n");
	CreateSMatrix(&A);
	PrintSMatrix(&A);
	printf("创建矩阵B3:(行数应与矩阵的列数相同=%d)\n",A.nu);
	CreateSMatrix(&B);
	PrintSMatrix(&B);
	printf("矩阵C4(A*B):\n");
	MultSMatrix(&A,&B,&C);
	PrintSMatrix(&C);
	DestroySMatrix(&C);
	DestroySMatrix(&B);
	DestroySMatrix(&A);
}

void InitSMatrix(pCrossList A)
{
	A->rhead = A->chead = NULL;
	A->mu = A->nu = A->tu = 0;
}

void CreateSMatrix(pCrossList A)
{
	int i,j,k,m,n,t,e;
	pOLNode p,q;
	if(A->rhead)			//建议数组是否为NULL
	{
		DestroySMatrix(A);
	}
	printf("请输入稀疏矩阵的行数 列数 非零元个数:");
	scanf("%d,%d,%d",&m,&n,&t);
	A->mu = m;
	A->nu = n;
	A->tu = t;
	A->rhead = (pOLNode*)malloc((m+1)*sizeof(OLNode));
	if(!A->rhead)
	{
		exit(-1);
	}
	A->chead = (pOLNode*)malloc((n+1)*sizeof(OLNode));
	if(!A->chead)
	{
		exit(-1);
	}
	for(k=1;k<=m;k++)
	{
		A->rhead[k] = NULL;
	}
	for(k=1;k<=n;k++)
	{
		A->chead[k] = NULL;
	}
	printf("请按任意次序输入%d个非零元素的行 列 元素值:\n",A->tu);
	for(k=0;k<t;k++)
	{
		printf("输入第%d个结点行号、列号以及值：\n", k+1); 
		scanf("%d,%d,%d",&i,&j,&e);
		p = (OLNode*)malloc(sizeof(OLNode));
		if(!p)
		{
			exit(-1);
		}
		p->i = i;
		p->j = j;
		p->e = e;
		if(A->rhead[i]==NULL || A->rhead[i]->j>j)
		{
			p->right = A->rhead[i];
			A->rhead[i] = p;
		}
		else
		{
			for(q=A->rhead[i];q->right&&q->right->j<j;q=q->right);
			p->right = q->right;
			q->right = p;
		}
/*
矩阵A(0代表未分配的位置)
1 0 0 3
0 0 8 0
0 0 0 1
理解:if(A->rhead[i]==NULL || A->rhead[i]->j>j)
假设输入的i、j、e分别为2 2 3,这时A->rhead[i]->j=3>j=2,说明将要插入的i=2、j=3、e=3的位置在这一排的第一个地址位置
p->right=A->rhead[i]指向原来的首地址，A->rhead[i]=p原来首地址指向新插入的
理解:for(q=A->rhead[i];q->right&&q->right->j<j;q=q->right)
q=A->rhead[i]从这一排首地址开始,以q->right&&q->right->j<j作为限制q->right存在,并且用新插入的j>q->right->j找到位置;
*/
		if(A->chead[j]==NULL || A->chead[j]->i>i)
		{
			p->down = A->chead[j];
			A->chead[j] = p;
		}
		else
		{
			for(q=A->chead[j];q->down&&q->down->i<i;q=q->down);
			p->down = q->down;
			q->down = p;
		}
	}
	DelZero(A);
}

void CopySMatrix(pCrossList A,pCrossList B)
{
	int i;
	pOLNode p,q,q1,q2;
	if(B->rhead)
	{
		DestroySMatrix(A);
	}
	B->mu = A->mu;
	B->nu = A->nu;
	B->tu = A->tu;
	B->rhead = (pOLNode*)malloc((B->mu+1)*sizeof(OLNode));
	if(!B->rhead)
		exit(-1);
	B->chead = (pOLNode*)malloc((B->nu+1)*sizeof(OLNode));
	if(!B->chead)
		exit(-1);
	for(i=1;i<=B->mu;i++)
		B->rhead[i] = NULL;
	for(i=1;i<=B->nu;i++)
		B->chead[i] = NULL;
	for(i=1;i<=A->mu;i++)
	{
		p = A->rhead[i];
		while(p)
		{
			q = (OLNode*)malloc(sizeof(OLNode));
			if(!q)
				exit(-1);
			q->i = p->i;
			q->j = p->j;
			q->e = p->e;
			if(!B->rhead[i])
				B->rhead[i] = q1 = q;
			else
				q1 = q1->right = q;
			if(!B->chead[q->j])
			{
				B->chead[q->j] = q;
				q->down = NULL;				//确保尾部所指向的下一个down为NULL
			}
			else
			{
				q2 = B->chead[p->j];
				while(q2->down)
					q2 = q2->down;
				q2->down = q;
				q->down = NULL;
			}
			p = p->right;
		}
		q->right = NULL;					//确保尾部所指向的下一个right为NULL
	}
}

void AddSMatrix(pCrossList A,pCrossList B,pCrossList C)
{
	int i,k;
	pOLNode p,q,m,n;
	C->mu = A->mu;
	C->nu = A->nu;
	C->rhead = (pOLNode*)malloc((A->mu+1)*sizeof(OLNode));
	if(!C->rhead)
		exit(-1);
	C->chead = (pOLNode*)malloc((A->nu+1)*sizeof(OLNode));
	if(!C->chead)
		exit(-1);
	for(k=1;k<=A->mu;k++)
		C->rhead[k] = NULL;
	for(k=1;k<=A->nu;k++)
		C->chead[k] = NULL;
	for(i=1;i<=A->mu;i++)
	{
		p = A->rhead[i];
		q = B->rhead[i];
		while(p || q)
		{
			n = (OLNode*)malloc(sizeof(OLNode));
			if(q && p)
			{
				if(q->j == p->j)
				{
					n->e = q->e+p->e;
					n->i = i;
					n->j = q->j;
					q = q->right;
					p = p->right;
				}
				else if(q->j > p->j)
				{
					n->e = p->e;
					n->i = i;
					n->j = p->j;
					p = p->right;
				}
				else
				{
					n->e = q->e;
					n->i = i;
					n->j = q->j;
					q = q->right;
				}
			}
			else if(q && !p)
			{
				n->e = q->e;
				n->i = i;
				n->j = q->j;
				q = q->right;
			}
			else if(!q && p)
			{
				n->e = p->e;
				n->i = i;
				n->j = p->j;
				p = p->right;
			}
		if(C->rhead[i]==NULL || C->rhead[i]->j>n->j)
		{
			n->right = C->rhead[i];
			C->rhead[i] = n;
		}
		else
		{
			for(m=C->rhead[i];m->right&&m->right->j<n->j;m=m->right);
			n->right = m->right;
			m->right = n;
		}

		if(C->chead[n->j]==NULL || C->chead[n->j]->i>n->i)
		{
			n->down = C->chead[n->j];
			C->chead[n->j] = n;
		}
		else
		{
			for(m=A->chead[n->j];m->down&&m->down->i<i;m=m->down);
			n->down = m->down;
			m->down = n;
		}
		C->tu++;
		}
	}
}

void SubtSMatrix(pCrossList A,pCrossList B,pCrossList C)
{
	int i;
	CrossList D;
	pOLNode p;
	InitSMatrix(&D);
	CopySMatrix(B,&D);
	for(i=1;i<=D.mu;i++)
	{
		p = D.rhead[i];
		while(p)
		{
			p->e = -p->e;
			p = p->right;
		}
	}
	AddSMatrix(A,&D,C);
	DelZero(C);
	DestroySMatrix(&D);
}

void TransposeSMatrix(pCrossList A,pCrossList C)
{
	int u,i;
	pOLNode *head,p,q,r;
	if(C->rhead)
		DestroySMatrix(C);
	CopySMatrix(A,C);
	u = C->mu;
	C->mu = C->nu;
	C->nu = u;
	head = C->chead;
	C->rhead = C->chead;
	C->chead = head;
	for(u=1;u<=C->mu;u++)
	{
		p = C->rhead[u];
		while(p)
		{
			q = p->down;			//q指向下一个节点
			i = p->i;				//交换i和j
			p->i = p->j;
			p->j = i;
			r = p->down;			//交换down和right
			p->down = p->right;
			p->right = r;
			p = q;					//p指向下一个节点
		}
	}
}

void MultSMatrix(pCrossList A,pCrossList B,pCrossList C)
{
	int i,j,k,e;
	pOLNode p,q,n,m,n1,n2;
	C->mu = A->mu;
	C->nu = B->nu;
	C->tu = 0;
	C->rhead = (pOLNode*)malloc((A->mu+1)*sizeof(OLNode));
	if(!C->rhead)
		exit(-1);
	C->chead = (pOLNode*)malloc((B->nu+1)*sizeof(OLNode));
	if(!C->chead)
		exit(-1);
	for(k=1;k<=A->mu;k++)
		C->rhead[k] = NULL;
	for(k=1;k<=A->nu;k++)
		C->chead[k] = NULL;
	for(i=1;i<=B->nu;i++)
	{
		for(j=1;j<=B->nu;j++)
		{
			p = A->rhead[i];
			q = B->chead[j];
			e = 0;
			while(p && q)
			{	
				if(p->j == q->i)
				{
					e += p->e*q->e;
					q = q->down;
					p = p->right;
				}
				else if(q->i > p->j)
					p = p->right;
				else
					q = q->down;
			}
			if(e!=0)
			{
				if(!(n=(pOLNode)malloc(sizeof(OLNode))))
					exit(-1);
				n->down = NULL;
				n->right = NULL;
				n->e = e;
				n->i = i;
				n->j = j;
				if(!C->rhead[i])
					C->rhead[i] = n1 = n;
				else
					n1 = n1->right = n;
				if(!C->chead[j])
					C->chead[j] = n;
				else
				{
					n2 = C->chead[j];
					while(n2->down)
						n2 = n2->down;
					n2->down = n;
				}
				C->tu++;
			}
		}
	}
}

void DelZero(pCrossList A)
{
	int i;
	pOLNode p,q;
	for(i=1;i<=A->mu;i++)
	{
		if(A->rhead[i])								//这里是为了防止A->rhead[i]为空，访问A->rhead[i]->e未分配空间出错
		{
			if(A->rhead[i]->e == 0)
			{
				q = A->rhead[i];
				A->rhead[i] = A->rhead[i]->right;
				free(q);
			}
			p = A->rhead[i];
			while(p && p->right)					//这里按先p后p->right的方式检查，先检查p是为了防止p->right是未分配空间访问出错
			{
				if(p->right->e == 0)
				{
					q = p->right;
					p->right = p->right->right;
					free(q);
				}
				p = p->right;
			}
		}
	}
}

void PrintSMatrix(pCrossList A)
{
	pOLNode q;
	if(!A->tu)
	{
		printf("矩阵为空!\n");
	}
	else
	{
		for(int i=1;i<=A->mu;i++)
		{
			q = A->rhead[i];
			for(int j=1;j<=A->nu;j++)
			{
				if(q && q->j == j)				//if()语句中也是按顺序执行，为了防止q->j是未分配空间访问出错
				{
					printf("%d ",q->e);
					q = q->right;
				}
				else
				{
					printf("0 ");
				}
			}
			printf("\n");
		}
	}
}

void DestroySMatrix(pCrossList A)
{
	int i;
	OLNode *p,*q;
	for(i=1;i<A->nu;i++)
	{
		p = A->rhead[i];
		while(p)
		{
			q = p;
			p = p->right;
			free(q);
		}
	}
	free(A->chead);
	free(A->rhead);
	InitSMatrix(A);
}

广义表的存储结构
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#define MAXSTRLEN 40

typedef char SString[MAXSTRLEN+1];
typedef enum{
	ATOM, LIST	                          // ATOM==0:原子 LIST==1:子表                     
} ElemTag; 
typedef struct GLNode
{
	ElemTag tag;						//公共部分，用于区分原子结构和表节点
	union								//原子节点和表节点的联合部分
	{
		char atom;						//atom是原子的值域，
		struct
		{
			struct GLNode *hp,*tp;
		}ptr;							//ptr是表节点的指针域，prt.hp和prt.tp分别指向表头和表尾
	};
}*GList,GLNode;

void InitGList(GList &);
int GListDepth(GList);
int GListEmpty(GList);
int GListLength(GList);
void StrAssign(SString,char *);
void CreateGList(GList &,SString);
void sever(SString str,SString hstr);
void CopyGList(GList &,GList &);
void Traverse_GL(GList,void(*v)(char));
void Destroy_GL(GList);
GList GetHead(GList);
GList GetTail(GList);
void InsertFirst(GList &,GList);
void DeleteFirst_GL(GList &,GList &);
void visit(char e);

bool Strempty(SString T);
void StrCopy(SString T,SString S);
void Strclear(SString T);

void main()
{
	char p[80];
	SString t;
	GList L,M;									//这里要令初值为地址，同时InitGList函数必须用引用直接使原值L=NULL,不然在函数GListDepth中会出现A没有初始化为NULL的情况，同时A->tag也未设值，出现访问未分配地址的情况
	InitGList(L);
	InitGList(M);
	printf("空广义表L的深度=%d 1是否空? %d(1:是 0:否)\n",GListDepth(L),GListEmpty(L));
	printf("请输入广义表1(书写形式:空表:(),单原子:a,其他:(a,(b),b):\n");
	gets(p);
	StrAssign(t,p);
	CreateGList(L,t);							//这里不能直接导入地址，函数执行完后形参释放，内存虽然分配了，但是跟形参有关的内容全部释放
	printf("广义表L的长度=%d GListLength(L)");
	printf("广义表L的深度=%d 1是否空? %d(1:是 0:否)\n",GListDepth(L),GListEmpty(L));
	printf("遍历广义表1:\n");
	Traverse_GL(L,visit);						//这里的visit相当于一个函数
	printf("\n复制广义表m=1\n");
	CopyGList(L,M);
	printf("遍历广义表1:\n");
	Traverse_GL(M,visit);
	Destroy_GL(M);
	M = GetHead(L);
	printf("\nM是L的表尾,遍历广义表M:\n ");
	Traverse_GL(M,visit);
	Destroy_GL(M);
	M = GetTail(L);
	printf("\nM是L的表尾,遍历广义表M:\n ");
	Traverse_GL(M,visit);
	InsertFirst(M,L);
	printf("\n插入L为M的表头,遍历广义表M:\n");
	Traverse_GL(M,visit);
	printf("\n删除M的表头,遍历广义表M:\n");
	Destroy_GL(L);
	DeleteFirst_GL(M,L);
	Traverse_GL(M,visit);
	printf("\n");
//	Destroy_GL(M);
}

void StrAssign(SString T,char *chars)
{
	if(strlen(chars)>MAXSTRLEN)
	{
		printf("串长超过MAXSTRLEN!\n");
		exit(-1);
	}
	else
	{
		T[0] = strlen(chars);
		for(int i=1;i<=T[0];i++)
		{
			T[i] = chars[i-1];
		}
	}
}

char StrCompare(SString T,SString S)
{
	for(int i=1;i<=T[0]&&i<=S[0];i++)
	{
		if(S[i] != T[i])
		{
			return T[i] - S[i];
		}
	}
	return T[0] - S[0];
}

int StrLength(SString T)
{
	return T[0];
}

void SubString(SString T,SString S,int i,int j)
{
	for(int k=1;k<=j;k++)
	{
		T[k] = S[k+i-1];
	}
	T[0] = j;
}

bool Strempty(SString T)
{
	if(T[0] == 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void Strclear(SString T)
{
	T[0] = 0;
}

void StrCopy(SString T,SString S)
{
	for(int i=0;i<=T[0];i++)
	{
		S[i] = T[i];
	}
	S[0] = T[0];
}

void InitGList(GList &A)
{
	A = NULL;
}

int GListLength(GList L)
{
	if(!L)
		return 0;
	else
	{
		int i=1;
		GList p;
		p = L;
		while(p->ptr.tp)
		{
			i++;
			p = p->ptr.tp;
		}
		return i;
	}
}

int GListDepth(GList A)
{
	int max,dep;
	GList pp;
	if(!A)
		return 1;								//这里的意思是存在空地址情况(),空表深度为1
	if(A->tag == ATOM)
		return 0;								//原子深度为0
	for(max=0,pp=A;pp;pp=pp->ptr.tp)			//递归算法
	{
		dep = GListDepth(pp->ptr.hp);
		if(dep>max)
			max = dep;
	}
	return max+1;
}

int GListEmpty(GList A)
{
	if(!A)
		return 1;
	else
		return 0;
}

void CreateGList(GList &A,SString S)
{
	SString sub,hsub,emp;
	GList p,q;
	StrAssign(emp,"()");
	if(!StrCompare(S,emp))
		A = NULL;
	else
	{
		if(!(A=(GList)malloc(sizeof(GLNode))))
			exit(-1);
		if(StrLength(S)==1)							//S为单原子
		{
			A->tag = ATOM;
			A->atom = S[1];							//创建单原子广义表
		}
		else
		{
			A->tag = LIST;
			p = A;
			SubString(sub,S,2,StrLength(S)-2);		//脱外层括号
			do
			{
				sever(sub,hsub);					//从sub中分离出表头串hsub，表尾sub
				CreateGList(p->ptr.hp,hsub);
				q = p;
				if(!Strempty(sub))
				{
					if(!(p=(GList)malloc(sizeof(GLNode))))
						exit(-1);
					p->tag = LIST;
					q->ptr.tp = p;
				}
			}while(!Strempty(sub));
			q->ptr.tp = NULL;
		}
	}

}

void sever(SString str,SString hstr) 
{
	int n,i,k;  
	SString ch,c1,c2,c3;
	n = StrLength(str);
	StrAssign(c1,",");
	StrAssign(c2,"(");
	StrAssign(c3,")");
	SubString(ch,str,1,1);
	for(i = 1,k = 0;i <= n && StrCompare(ch,c1) || k != 0; ++i)
	{ 
		SubString(ch, str, i, 1);
		if(!StrCompare(ch, c2))								//假设广义表((a,b),c),那么(a,b),c在(a,b)识别时k!=0使括号内的逗号不被检查
			++k;
		else if(!StrCompare(ch,c3))
			--k;
	}
	if(i <= n)
	{
		SubString(hstr, str, 1, i-2);
		SubString(str, str, i, n - i + 1);
	}
	else
	{
		StrCopy(str, hstr);
		Strclear(str);
	}
}

void CopyGList(GList &L,GList &M)
{
	if(!L)
		M = NULL;
	else
	{
		if(!(M=(GList)malloc(sizeof(GLNode))))
			exit(-1);
		M->tag = L->tag;
		if(L->tag==ATOM)
			M->atom = L->atom;
		else
		{
			CopyGList(L->ptr.hp,M->ptr.hp);
			CopyGList(L->ptr.tp,M->ptr.tp);
		}
	}
}

void Traverse_GL(GList L,void(*v)(char))						//这里相当于visit函数为void char *类型
{
	if(L)
		if(L->tag==ATOM)
			v(L->atom);
		else
		{
			Traverse_GL(L->ptr.hp,v);
			Traverse_GL(L->ptr.tp,v);
		}
}

GList GetHead(GList L)
{
	GList h;
	if(!L)
	{
		printf("空表无表头!\n");
		exit(-1);
	}
	CopyGList(L->ptr.hp,h);
	return h;
}

GList GetTail(GList L)
{
	GList h;
	if(!L)
	{
		printf("空表无表头!\n");
		exit(-1);
	}
	CopyGList(L->ptr.tp,h);
	return h;
}

void InsertFirst(GList &M,GList L)
{
	GList p = (GList)malloc(sizeof(GLNode));
	if(!p)
		exit(-1);
	p->tag = LIST;
	p->ptr.hp = L;
	p->ptr.tp = M;
	M = p;
}

void DeleteFirst_GL(GList &L,GList &e)
{
	GList p;
	e = L->ptr.hp;
	p = L;
	L = L->ptr.tp;
	free(p);
}

void Destroy_GL(GList L)
{
	GList q1,q2;
	if(L)
	{
		if(L->tag==ATOM)
		{
			free(L);
			L = NULL;
		}
		else
		{
			q1 = L->ptr.hp;
			q2 = L->ptr.tp;
			free(L);
			L = NULL;
			Destroy_GL(q1);
			Destroy_GL(q2);
		}
	}
}

void visit(char e)
{
	printf("%c ", e);
}

二叉树
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#define MAX_TREE_SIZE 100
#define NIL 0
typedef int SqBiTree[MAX_TREE_SIZE];

typedef struct position
{
	int level,order;
}pos;

void InitBiTree(SqBiTree);
void CreateBiTree(SqBiTree);
int EmptyBiTree(SqBiTree);
int DepthBiTree(SqBiTree);
int BootBiTree(SqBiTree);
int LengthAtomBiTree(SqBiTree);
void LevelOrderTraverse(SqBiTree);
void PreOrderTraverse(SqBiTree,int);
void PreTraverse(SqBiTree,int);
void InOrderTraverse(SqBiTree,int);
void InTraverse(SqBiTree,int);
void PostOrderTraverse(SqBiTree,int);
void PostTraverse(SqBiTree,int);
int Value(SqBiTree,pos);
void Assign(SqBiTree,pos,int);
int findpos(SqBiTree T,int e);
int Parent(SqBiTree,int);
int LeftChild(SqBiTree,int);
int RightChild(SqBiTree,int);
int LeftSibling(SqBiTree,int);
int RightSibling(SqBiTree,int);
void InsertChlid(SqBiTree,SqBiTree,int,int);
void Move(SqBiTree,SqBiTree,int,int);
void Print(SqBiTree);			//逐层，按本层输出二叉树
void DeleteChild(SqBiTree,int,int);
void ClearBiTree(SqBiTree);

void main()
{
	int e,j;
	pos p;
	SqBiTree T,S;
	InitBiTree(T);
	CreateBiTree(T);
/*	printf("建立二叉树后,树空否?%d(1:是 0:否)\n",EmptyBiTree(T));
	printf("建立二叉树后,数的深度=%d\n",DepthBiTree(T));
	printf("二叉树的根为:%d\n",BootBiTree(T));
	printf("层序遍历二叉树:\n");
	LevelOrderTraverse(T);
	printf("先序遍历二叉树:\n");
	PreOrderTraverse(T,1);
	printf("\n中序遍历二叉树:\n");
	InOrderTraverse(T,1);
	printf("\n后序遍历二叉树:\n");
	PostOrderTraverse(T,1);
	printf("\n请输入待修改的层号和序号:");
	scanf("%d,%d",&p.level,&p.order);
	e = Value(T,p);
	printf("带修改的值为%d,请输入新值:",e);
	scanf("%d",&e);
	Assign(T,p,e);
	printf("先序遍历二叉树:\n");
	PreOrderTraverse(T,1);
	printf("节点%d的双亲为%d:",e,Parent(T,e));
	printf("左右孩子分别为%d %d:",LeftChild(T,e),RightChild(T,e));
	printf("左右兄弟分别为%d %d:",LeftSibling(T,e),RightSibling(T,e));
	printf("建立右子树为空的树S:");*/
	InitBiTree(S);
	CreateBiTree(S);
	printf("树S插到树T中,请输入T中树的双亲节点,S为左(0)右(1)子树:");
	scanf("%d,%d",&e,&j);
	InsertChlid(T,S,e,j);
	Print(T);
	printf("删除子树，请输入待删除子树根节点的层号 本层序号 左(0)右(1)子树");
	scanf("%d,%d",&e,&j);
	DeleteChild(T,e,j);
	Print(T);
	ClearBiTree(T);
	printf("清除二叉树后，树空否?%d(1:是 0:否)\n",EmptyBiTree(T));
	printf("二叉树的根为:%d\n",BootBiTree(T));
}

void InitBiTree(SqBiTree T)
{
	for(int i=0;i<MAX_TREE_SIZE;i++)
		T[i] = NIL;
}

void CreateBiTree(SqBiTree T)
{
	int i,n;
	/*			二叉树存储的是字符型
	char s[MAX_TREE_SIZE];
	printf("请按层输入节点的值(字符),空格表示空节点，节点数字<=%d:\n",MAX_TREE_SIZE);
	printf("例如 abcdefg\n");
	gets(s);
	n = strlen(s);
	for(i=0;i<=n;i++)
	{
		T[i] = s[i];
		if(i!=0 && T[(i+1)/2-1] == NIL && T[i]!=NIL)
		{
			printf("出现无双亲的非根节点%c\n",T[i]);
			exit(-1);
		}
	}
	for(i=n;i<MAX_TREE_SIZE;i++)
		T[i] = NIL;
	*/
	i=0;
	printf("请安层顺序输入节点的值(整型),0表示空节点,输入999结束,节点数<=%d\n",MAX_TREE_SIZE);
	while(1)
	{
		scanf("%d",&T[i]);
		if(T[i]==999)
				break;
		if(i!=0 && T[(i+1)/2-1]==NIL && T[i]!=NIL)//此节点(不空)无双亲且不是根
		{
			printf("出现无双亲的非根节点!\n");
			exit(-1);
		}
		i++;
	}
	while(i<MAX_TREE_SIZE)
	{
		T[i] = NIL;
		i++;
	}
}

int EmptyBiTree(SqBiTree T)
{
	if(T[0]==NIL)
		return 0;
	else
		return 1;
}

int DepthBiTree(SqBiTree T)
{
	int i,j=1;
	for(i=MAX_TREE_SIZE-1;i>0;i--)
	{
		if(T[i]!=NIL)
			break;
	}
	do
		j++;
	while(i>=pow(2,j));
	return j;
}

int LengthAtomBiTree(SqBiTree T)
{
	for(int i=MAX_TREE_SIZE-1;T[i]==0;i--);
	return i;
}

int BootBiTree(SqBiTree T)
{
	if(EmptyBiTree(T))
		return -1;
	else
		return T[0];
}

void LevelOrderTraverse(SqBiTree T)
{
	for(int i=0;i<MAX_TREE_SIZE;i++)
		if(T[i]!=0)
			printf("%d ",T[i]);
	printf("\n");
}

void PreTraverse(SqBiTree T,int e)
{
	printf("%d ",T[e]);
	if(T[2*e+1]!=NIL)
		PreTraverse(T,2*e+1);
	if(T[2*e+2]!=NIL)
		PreTraverse(T,2*e+2);
}

void PreOrderTraverse(SqBiTree T,int e)
{
	if(EmptyBiTree(T))
	{
		printf("%d ",T[0]);
		PreTraverse(T,e);
		PreTraverse(T,e+1);
	}
	else
		printf("二叉树为空!\n");
}

void InTraverse(SqBiTree T,int e)
{
	if(T[2*e+1]!=NIL)
		InTraverse(T,2*e+1);
	printf("%d ",T[e]);
	if(T[2*e+2]!=NIL)
		InTraverse(T,2*e+2);
}

void InOrderTraverse(SqBiTree T,int e)
{
	if(EmptyBiTree(T))
	{
		InTraverse(T,e);
		printf("%d ",T[0]);
		InTraverse(T,e+1);
	}
	else
		printf("二叉树为空!\n");
}

void PostTraverse(SqBiTree T,int e)
{
	if(T[2*e+1]!=NIL)
		PostTraverse(T,2*e+1);
	if(T[2*e+2]!=NIL)
		PostTraverse(T,2*e+2);
	printf("%d ",T[e]);
}

void PostOrderTraverse(SqBiTree T,int e)
{
	if(EmptyBiTree(T))
	{
		PostTraverse(T,e);
		PostTraverse(T,e+1);
		printf("%d ",T[0]);
	}
	else
		printf("二叉树为空!\n");
}

int Value(SqBiTree T,pos P)
{
	return	T[int(pow(2,P.level-1)+P.order-2)];		//这里pow一定要int型 不然会出错
}

void Assign(SqBiTree T,pos P,int e)
{
	int i=int(pow(2,P.level-1)+P.order-2);
	if(e!=NIL && T[(i+1)/2-1]==NIL)	
		printf("叶子非空但双亲为空!\n");
	else if(e==NIL && (T[i*2+1]!=NIL||T[i*2+2]!=NIL))
		printf("双亲为空但有叶子!\n");
	else
		T[i] = e;
}

int findpos(SqBiTree T,int e)
{
	for(int i=0;i<MAX_TREE_SIZE;i++)
	{
		if(T[i]==e)
			return i;
	}
	return 0;
}

int Parent(SqBiTree T,int e)
{
	if(findpos(T,e)==0)
		return 0;
	else
		return T[(findpos(T,e)+1)/2-1];
}

int LeftChild(SqBiTree T,int e)
{
	if(findpos(T,e)==0)
		return 0;
	else
		return T[findpos(T,e)*2+1];
}

int RightChild(SqBiTree T,int e)
{
	if(findpos(T,e)==0)
		return 0;
	else
		return T[findpos(T,e)*2+2];
}

int LeftSibling(SqBiTree T,int e)
{
	if(findpos(T,e)==0)
		return 0;
	if(!(findpos(T,e)%2))
		return T[findpos(T,e)-1];
	else
		return 0;
}

int RightSibling(SqBiTree T,int e)
{
	if(findpos(T,e)==0)
		return 0;
	if((findpos(T,e))%2)
		return T[findpos(T,e)-1];
	else
		return 0;
}

void InsertChlid(SqBiTree T,SqBiTree S,int e,int j)
{
	int i,k;
	i=findpos(T,e);
	k = 2*i+1+j;
	if(T[k]!=0)
			Move(T,T,2*k+2,k);
	Move(T,S,k,0);
}

void Move(SqBiTree T,SqBiTree S,int i,int j)
{
	if(S[j*2+1]!=NIL)
		Move(T,S,i*2+1,j*2+1);
	if(S[j*2+2]!=NIL)
		Move(T,S,i*2+2,j*2+2);
	T[i] = S[j];
}

void Delete(SqBiTree T,int i)
{
	if(T[i*2+1]!=NIL)
		Delete(T,i*2+1);
	if(T[i*2+2]!=NIL)
		Delete(T,i*2+2);
	T[i] = 0;
}

void DeleteChild(SqBiTree T,int e,int j)
{
	int i,k;
	i=findpos(T,e);
	k = 2*i+1+j;
	if(T[k]==0)
	{
		printf("子树为空!\n");
		exit(-1);
	}
	else
		Delete(T,k);
}

void Print(SqBiTree T)
{
	int i,k,j;
	for(i=1;LengthAtomBiTree(T)>pow(2,i)-2;i++)
	{
		printf("第%d层: ",i);
		j=1;
		for(k=int(pow(2,i-1)-1);k<=pow(2,i)-2;k++)
		{
			if(T[k]!=0)
			{
				printf("%d:%d ",j,T[k]);
			}
			j++;
		}
		printf("\n");
	}
}

void ClearBiTree(SqBiTree T)
{
	for(int i=0;i<MAX_TREE_SIZE;i++)
		T[i] = NIL;
}

二叉树的二叉链表存储结构
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#define STACK_INIT_SIZE 10
#define STACKINCREMENT 2
#define QUEUEMAX 30

typedef struct BiTNode
{
	int data;
	BiTNode *lchild,*rchild;
}BiTNode,*pBiTNode;

typedef struct stack
{
	BiTNode *top;
	BiTNode *bottom;
	int stacksize;
}Stack,*pStack;

typedef struct Queue
{
	BiTNode *Base;
	int front;
	int rear;
}Queue,*qQueue;

void InitBiTree(pBiTNode &);
int BiTreeEmpty(pBiTNode);
int BiTreeDepth(pBiTNode);
char Root(pBiTNode);
void CreateBiTree(pBiTNode &);
void InOrderTraversel(pBiTNode);
void NoInOrderTraversel1(pBiTNode);
void NoInOrderTraversel2(pBiTNode);
void PostOrderTraverse(pBiTNode);
void levelTraverse(pStack,pStack,pBiTNode);
void LevelOrderTraverse(pBiTNode);
void LevelOrderTraverse1(pBiTNode);
pBiTNode Point(pBiTNode,char);
char Value(pBiTNode);
void Assign(pBiTNode,char);
char Parent(pBiTNode,char);
char LeftSibling(pBiTNode,char);
char RightSibling(pBiTNode,char);
char LeftChild(pBiTNode,char);
char RightChild(pBiTNode,char);
void PreOrderTraverse(pBiTNode);
void InsertChild(pBiTNode,int,pBiTNode);
void DeleteChild(pBiTNode,int);
void DestroyBiTree(pBiTNode &);

void init_Stack(pStack);
void push_Stack(pStack,pBiTNode);
void pop_Stack(pStack,pBiTNode);
int gettop(pStack,pBiTNode);
bool stackempty(pStack);

void init_Queue(qQueue,int);
void en_Queue(qQueue,pBiTNode);
void de_Queue(qQueue,pBiTNode);
bool EmptyQueue(qQueue);

void main()
{
	int i;
	char e1;
	pBiTNode T,S,p;
	InitBiTree(T);
	printf("构造空二叉树后,树空否?%d(1:是 0:否)树的深度=%d\n",BiTreeEmpty(T),BiTreeDepth(T));
	if((e1=Root(T))!='*')
		printf("二叉树的根为:%c\n",e1);
	else
		printf("树空,无根\n");
	printf("请先序输入二叉树(如:ab三个'*'表示a为根节点,b为左子树的二叉树):");
	CreateBiTree(T);
	printf("建立二叉树后,树空否?%d(1:是 0:否)树的深度=%d\n",BiTreeEmpty(T),BiTreeDepth(T));
	if((e1=Root(T))!='*')
		printf("二叉树的根为:%c\n",e1);
	else
		printf("树空,无根\n");
	printf("中序递归遍历二叉树:\n");
	InOrderTraversel(T);
/*	printf("\n中序非递归遍历二叉树:\n");
	NoInOrderTraversel1(T);
	printf("\n中序非递归遍历二叉树(另一种方法):\n");
	NoInOrderTraversel2(T);
	printf("\n后序递归遍历二叉树:\n");
	PostOrderTraverse(T);
	printf("\n层序遍历二叉树:\n");
	LevelOrderTraverse(T);
	printf("\n层序遍历二叉树(另一种方法):\n");
	LevelOrderTraverse1(T);
	printf("\n请输入一个节点的值:");
	fflush(stdin);
	scanf("%c%*c",&e1);
	p = Point(T,e1);
	printf("节点的值为%c\n",Value(p));
	printf("欲改变此节点的值,请输入新值:");
	scanf("%c%*c",&e1);
	Assign(p,e1);
	printf("层序遍历二叉树:\n");
	LevelOrderTraverse(T);
	printf("\n%c的双亲是%c",e1,Parent(T,e1));
	printf("\n%c的右兄弟是%c",e1,RightSibling(T,e1));
	printf("\n%c的左兄弟是%c",e1,LeftSibling(T,e1));
	printf("\n%c的右儿子是%c",e1,RightChild(T,e1));
	printf("\n%c的左儿子是%c\n",e1,LeftChild(T,e1));*/
	printf("构造一个右子树为空的二叉树S:\n");
	printf("请先序输入二叉树(如:ab三个'*'表示a为根节点,b为子树的二叉树):");
	InitBiTree(S);
	fflush(stdin);
	CreateBiTree(S);
	printf("先序递归遍历二叉树S:\n");
	PreOrderTraverse(S);
	printf("树S插到树T中,请输入树T中树S的双亲节点 S为左(0)右(1)子树:");
	scanf("%*c%c,%d",&e1,&i);
	p = Point(T,e1);
	InsertChild(p,i,S);
	printf("先序递归遍历二叉树S:\n");
	PreOrderTraverse(T);
	printf("删除子树,请输入待删除子树的双亲节点 左(0)右(1)子树:");
	scanf("%*c%c,%d",&e1,&i);
	p = Point(T,e1);
	DeleteChild(p,i);
	printf("先序递归遍历二叉树S:\n");
	PreOrderTraverse(T);
	DestroyBiTree(T);
}

void InitBiTree(pBiTNode &T)
{
	T = NULL;
}

int BiTreeEmpty(pBiTNode T)
{
	if(T==NULL)
		return 1;
	else
		return 0;
}

int BiTreeDepth(pBiTNode T)
{
	int max=0,dep;
	if(!T)
		return 0;
	else
	{
		if(T->lchild!=NULL)
			if((dep=BiTreeDepth(T->lchild))>max)
				max = dep;
		if(T->rchild!=NULL)
			if((dep=BiTreeDepth(T->rchild))>max)
				max = dep;
	}
	return max+1;
}

char Root(pBiTNode T)
{
	if(BiTreeEmpty(T))
		return '*';
	else
		return T->data;
}

void CreateBiTree(pBiTNode &T)
{
	char e;
	scanf("%c",&e);
	if(e!='*')
	{
		if(!(T=(pBiTNode)malloc(sizeof(BiTNode))))
			exit(-1);
		else
		{
			T->data = e;
			CreateBiTree(T->lchild);
			CreateBiTree(T->rchild);
		}
	}
	else
		T = NULL;
}

void PreOrderTraverse(pBiTNode T)
{
	printf("%c ",T->data);
	if(T->lchild!=NULL)
		InOrderTraversel(T->lchild);
	if(T->rchild!=NULL)
		InOrderTraversel(T->rchild);
}

void InOrderTraversel(pBiTNode T)
{
	if(T->lchild!=NULL)
		InOrderTraversel(T->lchild);
	printf("%c ",T->data);
	if(T->rchild!=NULL)
		InOrderTraversel(T->rchild);
}

void NoInOrderTraversel1(pBiTNode T)		//中序遍历二叉树T的非递归(利用客栈)		
{
	Stack S;
	pBiTNode p = (pBiTNode)malloc(sizeof(BiTNode));
	if(!p)
		exit(-1);
	init_Stack(&S);
	while(T || !stackempty(&S))
	{
		if(T)
		{
			push_Stack(&S,T);
			T = T->lchild;
		}
		else
		{
			pop_Stack(&S,p);			//pop_Stack(&S,T)是错误的 T最后没有分配空间 执行错误
			printf("%c ",p->data);
			T = p->rchild;				//这里的p无需纠结是否是源地址，这里p->rchild和原来T中对应相同
		}
	}
}

void NoInOrderTraversel2(pBiTNode T)
{
	Stack S;
	pBiTNode q,p = (pBiTNode)malloc(sizeof(BiTNode));
	if(!p)
		exit(-1);
	init_Stack(&S);
	push_Stack(&S,T);
	while(!stackempty(&S))
	{
		while(gettop(&S,p) && p->lchild!=NULL)
		{
			push_Stack(&S,p->lchild);
		}
		if(!stackempty(&S))
		{
			do
			{
				pop_Stack(&S,p);
				printf("%c ",p->data);
			}while(p->rchild==NULL && !stackempty(&S));			//****这里添加!stackempty(&S)是限制最后p->rchild==NULL
			if(p->rchild!=NULL)
				push_Stack(&S,p->rchild);
		}
	}
}

void PostOrderTraverse(pBiTNode T)
{
	if(T->lchild!=NULL)
		PostOrderTraverse(T->lchild);
	if(T->rchild!=NULL)
		PostOrderTraverse(T->rchild);
	printf("%c ",T->data);
}

void levelTraverse(pStack S,pStack S1,pBiTNode p)
{
	while(!stackempty(S))
	{
		pop_Stack(S,p);
		if(p->rchild!=NULL)
		{
			printf("%c ",p->rchild->data);
			push_Stack(S1,p->rchild);
		}
		if(p->lchild!=NULL)
		{
			printf("%c ",p->lchild->data);
			push_Stack(S1,p->lchild);
		}
	}
}

void LevelOrderTraverse(pBiTNode T)
{
	int i=1;
	Stack S,S1;
	pBiTNode p = (pBiTNode)malloc(sizeof(BiTNode));
	if(!p)
		exit(-1);
	init_Stack(&S);
	init_Stack(&S1);;
	push_Stack(&S,T);
	printf("第1层:");
	printf("%c ",T->data);
	while(BiTreeDepth(T)>=i)
	{
		printf("\n第%d层:",i);
		levelTraverse(&S,&S1,p);
		if((i++)<=BiTreeDepth(T))
		{
			printf("\n第%d层:",i+1);
			levelTraverse(&S1,&S,p);
			i++;
		}
	}
}

void LevelOrderTraverse1(pBiTNode T)
{
	Queue q;
	pBiTNode a = (pBiTNode)malloc(sizeof(BiTNode));
	if(T)
	{
		init_Queue(&q,QUEUEMAX);
		en_Queue(&q,T);
		while(!EmptyQueue(&q))
		{
			de_Queue(&q,a);
			printf("%c",a->data);
			if(a->lchild!=NULL)
				en_Queue(&q,a->lchild);
			if(a->rchild!=NULL)
				en_Queue(&q,a->rchild);
		}
	}
}

pBiTNode Point(pBiTNode T,char a)
{
	if(T->data == a)
		return T;
	else
	{
		if(T->lchild!=NULL)
			if(Point(T->lchild,a)!=NULL)
				return Point(T->lchild,a);
		if(T->rchild!=NULL)
			if(Point(T->rchild,a)!=NULL)
				return Point(T->rchild,a);
	}
	return NULL;
}

/*
pBiTNode Point(pBiTNode T,char a)
{
	Queue q;
	pBiTNode p = (pBiTNode)malloc(sizeof(BiTNode));		//这里命名p之后,return回去的p地址不是对应源地址
	if(T)
	{
		init_Queue(&q,QUEUEMAX);
		en_Queue(&q,T);
		while(!EmptyQueue(&q))
		{
			de_Queue(&q,p);					//出队，队列元素赋值给a
			if(p->data==a)
				return p;
			if(p->lchild)					//有左孩子
				en_Queue(&q,p->lchild);		//入队左孩子
			if(p->rchild)
				en_Queue(&q,p->rchild);
		}
	}
	return NULL;
}
*/

char Value(pBiTNode p)
{
	return p->data;
}

void Assign(pBiTNode T,char a)
{
	T->data = a;
}

char Parent(pBiTNode T,char e1)
{
	Queue q;
	pBiTNode p = (pBiTNode)malloc(sizeof(BiTNode));		//这里命名p之后,return回去的p地址不是对应源地址
	if(T)
	{
		init_Queue(&q,QUEUEMAX);
		en_Queue(&q,T);
		while(!EmptyQueue(&q))
		{
			de_Queue(&q,p);					//出队，队列元素赋值给a
			if((p->lchild&&p->lchild->data==e1)||(p->rchild&&p->rchild->data==e1))
				return p->data;
			else
			{
				if(p->lchild)					//有左孩子
					en_Queue(&q,p->lchild);		//入队左孩子
				if(p->rchild)
					en_Queue(&q,p->rchild);
			}
		}
	}
	return NULL;
}

char LeftSibling(pBiTNode T,char e1)
{
	Queue q;
	pBiTNode p = (pBiTNode)malloc(sizeof(BiTNode));		//这里命名p之后,return回去的p地址不是对应源地址
	if(T)
	{
		init_Queue(&q,QUEUEMAX);
		en_Queue(&q,T);
		while(!EmptyQueue(&q))
		{
			de_Queue(&q,p);					//出队，队列元素赋值给a
			if(p->rchild&&p->rchild->data==e1)
				return p->lchild->data;
			else
			{
				if(p->lchild)					//有左孩子
					en_Queue(&q,p->lchild);		//入队左孩子
				if(p->rchild)
					en_Queue(&q,p->rchild);
			}
		}
	}
	return '*';
}

char RightSibling(pBiTNode T,char e1)
{
	Queue q;
	pBiTNode p = (pBiTNode)malloc(sizeof(BiTNode));		//这里命名p之后,return回去的p地址不是对应源地址
	if(T)
	{
		init_Queue(&q,QUEUEMAX);
		en_Queue(&q,T);
		while(!EmptyQueue(&q))
		{
			de_Queue(&q,p);					//出队，队列元素赋值给a
			if(p->lchild&&p->lchild->data==e1)
				return p->rchild->data;
			else
			{
				if(p->lchild)					//有左孩子
					en_Queue(&q,p->lchild);		//入队左孩子
				if(p->rchild)
					en_Queue(&q,p->rchild);
			}
		}
	}
	return '*';
}

char LeftChild(pBiTNode T,char e1)
{
	if(Point(T,e1)->lchild!=NULL)
		return Point(T,e1)->lchild->data;
	else
		return '*';
}

char RightChild(pBiTNode T,char e1)
{
	if(Point(T,e1)->rchild!=NULL)
		return Point(T,e1)->rchild->data;
	else
		return '*';
}

void InsertChild(pBiTNode T,int pos,pBiTNode S)
{
	pBiTNode p;
	if(pos==0)
	{
		p = T->lchild;
		T->lchild = S;
	}
	else if(pos==1)
	{
		p = T->rchild;
		T->rchild = S;
	}
	S->rchild = p;
}

void DestroyBiTree(pBiTNode &T)
{
	if(T!=NULL)
	{
		if(T->lchild)
			DestroyBiTree(T->lchild);
		if(T->rchild)
			DestroyBiTree(T->rchild);
		free(T);
		T = NULL;
	}
}

void DeleteChild(pBiTNode T,int pos)
{
	if(pos==0)
	{
		T->lchild = NULL;
	}
	else if(pos==1)
	{
		T->rchild = NULL;
	}
}

void init_Stack(pStack ST)
{
	ST->bottom = (BiTNode*)malloc(STACK_INIT_SIZE*sizeof(BiTNode));
	if(ST->bottom == NULL)
	{
		printf("栈的头地址创建失败!");
		exit(-1);
	}
	else
	{
		ST->top = ST->bottom;
		ST->stacksize = STACK_INIT_SIZE;
	}
}

void push_Stack(pStack ST,pBiTNode T)
{
	if(ST->top-ST->bottom>=ST->stacksize)
	{
		ST->bottom = (BiTNode*)realloc(ST->bottom,(ST->stacksize+STACKINCREMENT)*sizeof(BiTNode));		//realloc用于修改已经分配的空间
		if(ST->bottom == NULL)
		{
			printf("动态内存分配失败!");
			exit(-1);
		}
		ST->top = ST->bottom + ST->stacksize;
		ST->stacksize = ST->stacksize + STACKINCREMENT;
	}
	*(ST->top) = *T;					//这一步分解就是*(ST->top) = num;    ST->top++;
	ST->top++;
}

void pop_Stack(pStack ST,pBiTNode T)
{
	if(stackempty(ST))
	{
		printf("栈为空，无法出栈!\n");
		exit(-1);
	}
	else
	{
		ST->top--;
		*T = *(ST->top);
	}
}

int gettop(pStack ST,pBiTNode T)
{
	if(ST->top>ST->bottom)
	{
		ST->top--;
		*T = *(ST->top);
		ST->top++;
		return 1;
	}
	else
		return 0;
}

bool stackempty(pStack ST)
{
	if(ST->bottom == ST->top)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void init_Queue(qQueue Q,int length)
{
	Q->Base = (pBiTNode)malloc((length+1)*sizeof(Queue));
	if(Q->Base == NULL)
	{
		printf("空间分配失败!\n");
		exit(-1);
	}
	Q->front = 0;
	Q->rear = 0;
}

void en_Queue(qQueue Q,pBiTNode T)
{
	Q->Base[Q->rear] = *T;
	Q->rear++;
}

void de_Queue(qQueue Q,pBiTNode T)
{
	*T = Q->Base[Q->front];
	Q->front++;
}

bool EmptyQueue(qQueue Q)
{
	if(Q->rear == Q->front)
		return true;
	else
		return false;
}

二叉树的三叉链表存储表示
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#define QUEUEMAX 30

typedef struct BiTPNode
{
	char data;
	BiTPNode *parent,*lchild,*rchild;
}BiTPNode,*pBiTPNode;

typedef struct Queue
{
	BiTPNode *Base;
	int front;
	int rear;
}Queue,*qQueue;

void InitBitree(pBiTPNode &);
int BiTreeEmpty(pBiTPNode);
int BitreeDepth(pBiTPNode);
char Root(pBiTPNode);
//void Create(pBiTPNode &);
//void CreateBiTree(pBiTPNode &);
void CreateBiTree(pBiTPNode &,pBiTPNode);
void PreOrderTraverse(pBiTPNode);
void InOrderTraversel(pBiTPNode);
void PostOrderTraverse(pBiTPNode);
void Print(pBiTPNode);
void LevelOrderTraverse1(pBiTPNode);
pBiTPNode Point(pBiTPNode,char);
void InsertChild(pBiTPNode,int,pBiTPNode);
char Value(pBiTPNode);
void Assign(pBiTPNode,char);
char Parent(pBiTPNode,char);
char RightSibling(pBiTPNode,char);
char LeftSibling(pBiTPNode,char);
char RightChild(pBiTPNode,char);
char LeftChild(pBiTPNode,char);
void DeleteChild(pBiTPNode,char);
void DestroyBiTree(pBiTPNode);

void init_Queue(qQueue,int);
void en_Queue(qQueue,pBiTPNode);
void de_Queue(qQueue,pBiTPNode);
bool EmptyQueue(qQueue);

void main()
{
	int i;
	char e1;
	pBiTPNode T,S,p;
	InitBitree(T);
	printf("构造空二叉树后,树空否?%d(1:是 0:否)树的深度=%d\n",BiTreeEmpty(T),BitreeDepth(T));
	if((e1=Root(T))!='*')
		printf("二叉树的根为:%c\n",e1);
	else
		printf("树空,无根\n");
	printf("请先序输入二叉树(如:ab三个'*'表示a为根节点,b为左子树的二叉树):");
//	CreateBiTree(T);
	CreateBiTree(T,NULL);
	printf("构造空二叉树后,树空否?%d(1:是 0:否)树的深度=%d\n",BiTreeEmpty(T),BitreeDepth(T));
	if((e1=Root(T))!='*')
		printf("二叉树的根为:%c\n",e1);
	else
		printf("树空,无根\n");
	printf("\n中序非递归遍历二叉树:\n");
	InOrderTraversel(T);
	printf("\n后序递归遍历二叉树:\n");
	PostOrderTraverse(T);
	fflush(stdin);
	printf("\n层序遍历二叉树(另一种方法):\n");
	LevelOrderTraverse1(T);
	printf("\n请输入一个节点的值:");
	fflush(stdin);
	scanf("%c%*c",&e1);
	p = Point(T,e1);
	printf("节点的值为%c\n",Value(p));
	printf("欲改变此节点的值,请输入新值:");
	scanf("%c%*c",&e1);
	Assign(p,e1);
	printf("\n层序遍历二叉树(另一种方法):\n");
	LevelOrderTraverse1(T);
	printf("\n%c的双亲是%c",e1,Parent(T,e1));
	printf("\n%c的右兄弟是%c",e1,RightSibling(T,e1));
	printf("\n%c的左兄弟是%c",e1,LeftSibling(T,e1));
	printf("\n%c的右儿子是%c",e1,RightChild(T,e1));
	printf("\n%c的左儿子是%c\n",e1,LeftChild(T,e1));
	printf("构造一个右子树为空的二叉树S:\n");
	printf("请先序输入二叉树(如:ab三个'*'表示a为根节点,b为子树的二叉树):");
	InitBitree(S);
	CreateBiTree(S,NULL);
	printf("先序递归遍历二叉树S:\n");
	PreOrderTraverse(S);
	printf("树S插到树T中,请输入树T中树S的双亲节点 S为左(0)右(1)子树:");
	scanf("%*c%c,%d",&e1,&i);
	p = Point(T,e1);
	InsertChild(p,i,S);
	printf("先序递归遍历二叉树S:\n");
	PreOrderTraverse(T);
	printf("删除子树,请输入待删除子树的双亲节点 左(0)右(1)子树:");
	scanf("%*c%c,%d",&e1,&i);
	p = Point(T,e1);
	DeleteChild(p,i);
	printf("先序递归遍历二叉树S:\n");
	PreOrderTraverse(T);
	DestroyBiTree(T);
}

void InitBitree(pBiTPNode &T)
{
	T = NULL;
}

int BiTreeEmpty(pBiTPNode T)
{
	if(T==NULL)
		return 1;
	else
		return 0;
}

int BitreeDepth(pBiTPNode T)
{
	int i,j;
	if(!T)
		return 0;
	if(T->lchild)
		i = BitreeDepth(T->lchild);
	else
		i = 0;
	if(T->rchild)
		i = BitreeDepth(T->rchild);
	else
		j = 0;
	return i>j?i+1:j+1;
}

char Root(pBiTPNode T)
{
	if(BiTreeEmpty(T))
		return '*';
	else
		return T->data;
}

void CreateBiTree(pBiTPNode &T,pBiTPNode p)
{
	char e;
	scanf("%c",&e);
	if(e!='*')
	{
		if(!(T=(pBiTPNode)malloc(sizeof(BiTPNode))))
			exit(-1);
		else
		{
			T->data = e;
			T->parent = p;
			CreateBiTree(T->lchild,T);
			CreateBiTree(T->rchild,T);
		}
	}
	else
		T = NULL;
}

/*
void CreateBiTree(pBiTPNode &T)
{
	Queue q;
	pBiTPNode p;
	{
		exit(-1);
	}
	if(T)
	{
		T->parent = NULL;	//根节点的双亲为"空"
		init_Queue(&q,QUEUEMAX);
		en_Queue(&q,T);
		while(!EmptyQueue(&q))
		{
			de_Queue(&q,p);							//这里要将de_Queue传地址 而不是传值 不然程序出错(修改de_Queue)
			if(p->lchild)
			{
				p->lchild->parent = p;
				en_Queue(&q,p->lchild);
			}
			if(p->rchild)
			{
				p->rchild->parent = p;
				en_Queue(&q,p->rchild);
			}
		}
	}
}

void Create(pBiTPNode &T)
{
	char e;
	scanf("%c",&e);
	if(e!='*')
	{
		if(!(T=(pBiTPNode)malloc(sizeof(BiTPNode))))
			exit(-1);
		else
		{
			T->data = e;
			Create(T->lchild);
			Create(T->rchild);
		}
	}
	else
		T = NULL;
}
*/

void PreOrderTraverse(pBiTPNode T)
{
	Print(T);
	if(T->lchild!=NULL)
		PreOrderTraverse(T->lchild);
	if(T->rchild!=NULL)
		PreOrderTraverse(T->rchild);
}

void InOrderTraversel(pBiTPNode T)
{
	if(T->lchild!=NULL)
		InOrderTraversel(T->lchild);
	Print(T);
	if(T->rchild!=NULL)
		InOrderTraversel(T->rchild);
}

void PostOrderTraverse(pBiTPNode T)
{
	if(T->lchild!=NULL)
		PostOrderTraverse(T->lchild);
	if(T->rchild!=NULL)
		PostOrderTraverse(T->rchild);
	Print(T);
}

void LevelOrderTraverse1(pBiTPNode T)
{
	Queue q;
	pBiTPNode a = (pBiTPNode)malloc(sizeof(BiTPNode));
	if(T)
	{
		printf("%c是根节点\n",T->data);
		init_Queue(&q,QUEUEMAX);
		en_Queue(&q,T);
		while(!EmptyQueue(&q))
		{
			de_Queue(&q,a);
			if(a->lchild!=NULL)
			{
				printf("%c是%c的左孩子\n",a->lchild->data,a->data);
				en_Queue(&q,a->lchild);
			}
			if(a->rchild!=NULL)
			{
				printf("%c是%c的左孩子\n",a->rchild->data,a->data);
				en_Queue(&q,a->rchild);
			}
		}
	}
}

pBiTPNode Point(pBiTPNode T,char a)
{
	if(T->data == a)
		return T;
	else
	{
		if(T->lchild!=NULL)
			if(Point(T->lchild,a)!=NULL)
			{
				return Point(T->lchild,a);
			}
			else
			{
				if(T->rchild!=NULL)
					if(Point(T->rchild,a)!=NULL)
						return Point(T->rchild,a);
			}
	}
	return NULL;
}

char Value(pBiTPNode p)
{
	return p->data;
}

void Assign(pBiTPNode T,char a)
{
	T->data = a;
}

char Parent(pBiTPNode T,char a)
{
	return Point(T,a)->parent->data;
}

char RightSibling(pBiTPNode T,char a)
{
	if(Point(T,a)->parent->rchild!=NULL)
		return Point(T,a)->parent->rchild->data;
	else
		return '*';
}

char LeftSibling(pBiTPNode T,char a)
{
	if(Point(T,a)->parent->lchild!=NULL)
		return Point(T,a)->parent->lchild->data;
	else
		return '*';
}

char RightChild(pBiTPNode T,char a)
{
	if(Point(T,a)->rchild!=NULL)
		return Point(T,a)->rchild->data;
	else
		return '*';
}
char LeftChild(pBiTPNode T,char a)
{
	if(Point(T,a)->lchild!=NULL)
		return Point(T,a)->lchild->data;
	else
		return '*';
}

void InsertChild(pBiTPNode T,int pos,pBiTPNode S)
{
	pBiTPNode p;
	if(pos==0)
	{
		p = T->lchild;
		T->lchild = S;
	}
	else if(pos==1)
	{
		p = T->rchild;
		T->rchild = S;
	}
	S->parent = T;
	S->rchild = p;
}

void DeleteChild(pBiTPNode T,int pos)
{
	if(pos==0)
	{
		T->lchild = NULL;
	}
	else if(pos==1)
	{
		T->rchild = NULL;
	}
}

void DestroyBiTree(pBiTPNode T)
{
	if(T!=NULL)
	{
		if(T->lchild)
			DestroyBiTree(T->lchild);
		if(T->rchild)
			DestroyBiTree(T->rchild);
		free(T);
		T = NULL;
	}
}

void Print(pBiTPNode T)
{
	if(T->parent==NULL)
		printf("%c是根节点\n",T->data);
	else
	{
		if(T->parent->lchild == T)
			printf("%c是%c的左孩子\n",T->data,T->parent->data);
		if(T->parent->rchild == T)
			printf("%c是%c的右孩子\n",T->data,T->parent->data);
	}
}

void init_Queue(qQueue Q,int length)
{
	Q->Base = (pBiTPNode)malloc((length+1)*sizeof(BiTPNode));
	if(Q->Base == NULL)
	{
		printf("空间分配失败!\n");
		exit(-1);
	}
	Q->front = 0;
	Q->rear = 0;
}

void en_Queue(qQueue Q,pBiTPNode T)
{
	Q->Base[Q->rear] = *T;
	Q->rear++;
}

void de_Queue(qQueue Q,pBiTPNode T)
{
	*T = Q->Base[Q->front];
	Q->front++;
}

bool EmptyQueue(qQueue Q)
{
	if(Q->rear == Q->front)
		return true;
	else
		return false;
}

二叉树的二叉搜索
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
enum PointerTag{Link,Thread};		//Link(0):指针,Thread(1):线索

typedef struct BiThrNode
{
	char data;
	BiThrNode *lchild,*rchild;		//左右孩子指针
	PointerTag LTag,RTag;			//左右标志
}*BiThrTree;

BiThrTree pre;

void CreatrBiThrTree(BiThrTree &);
void InOrderThreading(BiThrTree &,BiThrTree);
void InThreading(BiThrTree);
void InOrderTraverse(BiThrTree);

void main()
{
	BiThrTree H,T;
	printf("请按先序输入二叉树(例如:ab三个空格表示a为根节点,b为左子树的二叉树)\n");
	CreatrBiThrTree(T);
	InOrderThreading(H,T);
	InOrderTraverse(H);
}

void CreatrBiThrTree(BiThrTree &T)
{
	char h;
	scanf("%c",&h);
	if(h=='*')
		T = NULL;
	else
	{
		if(!(T=(BiThrTree)malloc(sizeof(BiThrNode))))
			exit(-1);
		T->data = h;
		CreatrBiThrTree(T->lchild);
		if(T->lchild)
			T->LTag = Link;
		CreatrBiThrTree(T->rchild);
		if(T->rchild)
			T->RTag = Link;
	}
}

void InThreading(BiThrTree p)
{
	if(p)
	{
		InThreading(p->lchild);		//递归左子树线索化
		if(!p->lchild)
		{
			p->LTag = Thread;		//前驱线索
			p->lchild = pre;		//左孩子指针指向前驱
		}
		if(!pre->rchild)				//前驱没有右孩子
		{
			pre->RTag = Thread;		//后续线索
			pre->rchild = p;		//前驱右孩子指针向后续(当前节点p)
		}
		pre = p;					//保持pre指向p的前去(从递归最内层一次往前)
		InThreading(p->rchild);
	}
}

void InOrderThreading(BiThrTree &Thrt,BiThrTree	T)
{
	if(!(Thrt=(BiThrTree)malloc(sizeof(BiThrNode))))
		exit(-1);
	Thrt->LTag = Link;			//建头节点
	Thrt->RTag = Thread;
	Thrt->rchild = Thrt;		//右指针回指
	if(!T)						//如果左指针为空,则左指针回指
		Thrt->lchild = Thrt;
	else
	{
		Thrt->lchild = T;
		pre = Thrt;
		InThreading(T);
		pre->rchild = Thrt;
		pre->RTag = Thread;
		Thrt->rchild = pre;
	}
}

void InOrderTraverse(BiThrTree T)
{
	BiThrTree p;
	p = T->lchild;
	while(p!=T)
	{
		while(p->LTag==Link)
			p = p->lchild;
		printf("%c->",p->data);
		while(p->RTag==Thread && p->rchild!=T)
		{
			p = p->rchild;
			printf("%c->",p->data);
		}
		p = p->rchild;
	}
}

树的双亲表示及存储
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#define MAX_TREE_SIZE 100
#define QUEUE_SIZE 50

typedef struct PTNode
{
	char data;
	int parent;
}*pPTNode;

typedef struct PTree
{
	PTNode nodes[MAX_TREE_SIZE];
	int n;							//节点数
}*pPTree;

typedef struct Queue
{
	PTNode *Base;
	int front;
	int rear;
}Queue,*qQueue;

void InitTree(pPTree);
bool TreeEmpty(pPTree);
char Root(pPTree);
int TreeDepth(pPTree);
void CreatrTree(pPTree);
void TraverseTree(pPTree);
void Assign(pPTree,char,char);
char Parent(pPTree,char);
char LeftChild(pPTree,char);
char RightSibling(pPTree,char);
void InsertChild(pPTree,char,int,pPTree);
void Print(pPTree);
void DeleteChild(pPTree,char,int);

void init_Queue(qQueue,int);
void en_Queue(qQueue,pPTNode);
void de_Queue(qQueue,pPTNode);
bool EmptyQueue(qQueue);

int main()
{
	int i;
	char e1,e2;
	PTree T,H;
	InitTree(&T);
	printf("建立空树后,树空否?%d(1:是 0:否) 树的根为%c 树的深度为%d\n",TreeEmpty(&T),Root(&T),TreeDepth(&T));
	CreatrTree(&T);
	printf("建立树T后,树空否?%d(1:是 0:否) 树的根为%c 树的深度为%d\n",TreeEmpty(&T),Root(&T),TreeDepth(&T));
	printf("层遍历树T\n");
	TraverseTree(&T);
	printf("\n请输入待修改的节点的值 新值:");
	scanf("%c%*c%c%*c",&e1,&e2);
	Assign(&T,e1,e2);
	printf("\n层遍历修改后的树T\n");
	TraverseTree(&T);
	printf("\n%c的双亲是%c,长子是%c,下一个兄弟是%c\n",e2,Parent(&T,e2),LeftChild(&T,e2),RightSibling(&T,e2));
	printf("建立树H\n");
	InitTree(&H);
	CreatrTree(&H);
	printf("层遍历树T\n");
	TraverseTree(&H);
	printf("将树H插到树H中,请输入T中的双亲节点 子树序号:");
	scanf("%c%d%*c",&e1,&i);
	InsertChild(&T,e1,i,&H);
	Print(&T);
	printf("删除树T中节点e的第i棵子树，请输入e i:");
	scanf("%c%d%*c",&e1,&i);
	DeleteChild(&T,e1,i);
	Print(&T);
	scanf("%c%d%*c",&e1,&i);
	return 0;
}

void InitTree(pPTree T)
{
	for(int i=0;i<MAX_TREE_SIZE;i++)
	{
		T->nodes[i].data = 0;
		T->nodes[i].parent = 0;
		T->n = 0;
	}
}

bool TreeEmpty(pPTree T)
{
	if(T->n==0)
		return true;
	else
		return false;
}

char Root(pPTree T)
{
	if(T->n!=0)
		return T->nodes[0].data;
	else
		return '*';
}

int TreeDepth(pPTree T)
{
	int i=1,j=T->nodes[T->n-1].parent;
	if(T->n==0)
		return 0;
	else
	{
		while(j!=-1)
		{
			j = T->nodes[j].parent;
			i++;
		}
		return i;
	}
}

void CreatrTree(pPTree T)
{
	Queue q;
	PTNode p,qq;
	int i=1,j,l;
	char c[MAX_TREE_SIZE];				//临时存放孩子节点
	init_Queue(&q,QUEUE_SIZE);
	printf("请输入根节点('*'为空):");
	scanf("%c%*c",&T->nodes[0].data);	//根节点序号为0
	if(T->nodes[0].data!='*')
	{
		T->nodes[0].parent = -1;		//根节点无双亲
		qq.data = T->nodes[0].data;
		qq.parent = 0;
		en_Queue(&q,&qq);
		while(i<MAX_TREE_SIZE && !EmptyQueue(&q))
		{
			de_Queue(&q,&qq);				//出队一个节点
			printf("请按长幼顺序输入节点%c的所有孩子:",qq.data);
			gets(c);
			l = strlen(c);
			for(j=0;j<l;j++)
			{
				T->nodes[i].data = c[j];
				T->nodes[i].parent = qq.parent;
				p.data = c[j];
				p.parent = i;
				en_Queue(&q,&p);
				i++;
			}
		}
		if(i>MAX_TREE_SIZE)
		{
			printf("节点数超过数组容量\n");
			exit(-1);
		}
		T->n = i;
	}
	else
		T->n = 0;
}

void TraverseTree(pPTree T)
{
	for(int i=0;i<T->n;i++)
	{
		printf("->%c",T->nodes[i].data);
	}
}

void Assign(pPTree T,char e1,char e2)
{
	int i;
	for(i=0;T->nodes[i].data!=e1;i++);
	T->nodes[i].data = e2;
}

char Parent(pPTree T,char e2)
{
	int i;
	for(i=0;T->nodes[i].data!=e2;i++);
	return T->nodes[T->nodes[i].parent].data;
}

char LeftChild(pPTree T,char e2)
{
	int i;
	for(i=0;T->nodes[T->nodes[i].parent].data!=e2 && i<T->n;i++);
	if(i<T->n)
		return T->nodes[i].data;
	else
		return '*';
}

char RightSibling(pPTree T,char e2)
{
	int i;
	for(i=0;T->nodes[i].data!=e2 && i<T->n;i++);
	if(i!=T->n && T->nodes[i+1].parent == T->nodes[i].parent)
		return T->nodes[i+1].data;
	else
		return '*';
}

void InsertChild(pPTree T,char e1,int pos,pPTree H)						//pos代表插入的位子
{
	int j,l,k,f=1,n=0;
	PTNode t;
	if(!TreeEmpty(T))
	{
			for(j=0;T->nodes[j].data!=e1 && j<T->n;j++);
		l = j + 1;				//如果c是p的第一棵树，则插入在
		if(pos>1)
		{
			for(k=j+1;k<T->n;k++)
				if(T->nodes[k].parent == j)
				{
					n++;		//孩子数加1
					if(n == pos-1)	//找到e1的第pos-1个孩子，其序号为k
						break;
				}
			l = k + 1;
		}//e1的序号为j，H插在l处
		if(l<T->n)
			for(k=T->n-1;k>=l;k--)
			{
				T->nodes[k+H->n] = T->nodes[k];			//依次将序号l以后的节点向后移动H->n个位置
				if(T->nodes[k].parent>=l)
					T->nodes[k+H->n].parent +=H->n;		//依次将序号l以后的节点的父节点向后移动H->n个为位置
			}
		for(k=0;k<H->n;k++)
		{
			T->nodes[l+k].data = H->nodes[k].data;		//依次将H中的数据插入到T中l以后的位置
			T->nodes[l+k].parent = H->nodes[k].parent+l;//依次将H中的父节点位置插入到T中以后的位置(这里+l是新父节点的位置)
		}
		T->nodes[l].parent = j;
		T->n += H->n;
		while(f)				//从插入点之后，将节点仍按层排序
		{		
			f = 0;
			for(j=1;j<T->n-1;j++)
			{
				if(T->nodes[j].parent>T->nodes[j+1].parent)		//比较双亲结点位置大小
				{
					t = T->nodes[j];
					T->nodes[j] = T->nodes[j+1];
					T->nodes[j+1] = t;
					f = 1;
					for(k=j;k<T->n;k++)							//在儿子树位置调整后，同时调整孙子树中父节点位置
						if(T->nodes[k].parent == j)
							T->nodes[k].parent++;
						else if(T->nodes[k].parent == j+1)
							T->nodes[k].parent--;
				}
			}
		}
	}
	else
	{
		printf("树为空!\n");
		exit(-1);
	}
	
}

void DeleteChild(pPTree T,char e1,int pos)
{
	int i,j,k;
	Queue q;
	PTNode p;
	init_Queue(&q,QUEUE_SIZE);
	for(i=0;T->nodes[T->nodes[i].parent].data!=e1 && i<T->n;i++);
	if(i!=T->n)
	{
		en_Queue(&q,&T->nodes[i+pos-1]);
		T->nodes[i+pos-1].parent = T->n;
	}
	while(!EmptyQueue(&q)&&i<T->n)
	{
		de_Queue(&q,&p);
		for(j=i;j<T->n;j++)
		{
			if(T->nodes[T->nodes[j].parent].data == p.data)
			{
				en_Queue(&q,&T->nodes[j]);
				T->nodes[j].parent = T->n;
			}
		}
		i = j;
	}
	for(i=0;i<T->n;i++)
	{
		for(j=0;j<=i;j++)
		{
			if(T->nodes[j].parent>T->nodes[j+1].parent)
			{
				p = T->nodes[j];
				T->nodes[j] = T->nodes[j+1];
				T->nodes[j+1] = p;
				for(k=j;k<T->n;k++)							//在儿子树位置调整后，同时调整孙子树中父节点位置
					if(T->nodes[k].parent == j)
						T->nodes[k].parent++;
					else if(T->nodes[k].parent == j+1)
						T->nodes[k].parent--;
			}
		}
	}
	T->n -= q.rear;
}

void Print(pPTree T)
{
	printf("***节点***双亲***\n");
	printf("***%c*** ***\n",T->nodes[0].data);
	for(int i=1;i<T->n;i++)
	{
		printf("***%c***%c***\n",T->nodes[i].data,T->nodes[T->nodes[i].parent].data);
	}
}

void init_Queue(qQueue Q,int length)
{
	Q->Base = (pPTNode)malloc((length+1)*sizeof(PTNode));
	if(Q->Base == NULL)
	{
		printf("空间分配失败!\n");
		exit(-1);
	}
	Q->front = 0;
	Q->rear = 0;
}

void en_Queue(qQueue Q,pPTNode T)
{
	Q->Base[Q->rear] = *T;
	Q->rear++;
}

void de_Queue(qQueue Q,pPTNode T)
{
	*T = Q->Base[Q->front];
	Q->front++;
}

bool EmptyQueue(qQueue Q)
{
	if(Q->rear == Q->front)
		return true;
	else
		return false;
}

树的二叉链表
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

typedef struct CSNodn
{
    char data;
    CSNodn *firstchild,*nextsibling;
}CSNodn,*CSTree;

typedef struct QNode
{
	CSTree QNodedata;
	struct QNode *pNext;
}QNode,*qQNode;

typedef struct Queue
{
	qQNode front;
	qQNode rear;
}Queue,*qQueue;

void InitTree(CSTree &);
bool TreeEmpty(CSTree);
char Root(CSTree);
int TreeDepth(CSTree);
void CreateTree(CSTree &);
void PreOrderTraverse(CSTree);
CSTree Point(CSTree,char);
void Assign(char,CSTree);
void PostOrderTraverse(CSTree);
char Parent(CSTree,char);
char LeftChild(CSTree,char);
char RightSibling(CSTree,char);
void LevelOrderTraverse(CSTree);
void InsertChild(CSTree,CSTree,int,CSTree);
void DeleteChild(CSTree,CSTree,int);
void DestroyTree(CSTree);

void init_QU(qQueue);
void enQU(qQueue,CSTree);
void deQU(qQueue QU,CSTree &);
bool empty(qQueue);

int main()
{
    int i;
    CSTree T,S,p;
    char e,e1;
    InitTree(T);
    printf("构造空树后，树空否？%d(1:是 0:否) 树根为%c 树的深度为%d\n",TreeEmpty(T),Root(T),TreeDepth(T));
    CreateTree(T);
	printf("构造树T后，树空否？%d(1:是 0:否) 树根为%c 树的深度为%d\n",TreeEmpty(T),Root(T),TreeDepth(T));
	printf("先根遍历树T:\n");
	PreOrderTraverse(T);
	printf("请输入待修改的节点的值 新值:");
	scanf("%c%*c%c%*c",&e,&e1);
	p = Point(T,e);
	Assign(e1,p);
	printf("先根遍历树T:\n");
	PreOrderTraverse(T);
	printf("\n后根遍历树T:\n");
	PostOrderTraverse(T);
	printf("\n%c的双亲是%c,长子是%c,下一个兄弟是%c",e1,Parent(T,e1),LeftChild(T,e1),RightSibling(T,e1));
	printf("\n建立树S:\n");
	InitTree(S);
	CreateTree(S);
	printf("层序遍历树S:\n");
	LevelOrderTraverse(S);
	printf("\n将树S插到树T中，请输入T中S的双亲节点 子树序号:");
	scanf("%c%*c%d",&e,&i);
	p = Point(T,e);
	InsertChild(T,p,i,S);
	printf("层序遍历树T:\n");
	LevelOrderTraverse(T);
	printf("\n删除树T中节点e的第i棵子树，请输入e i:");
	fflush(stdin);
	scanf("%c%d",&e,&i);
	p = Point(T,e);
	DeleteChild(T,p,i);
	printf("层序遍历树T:\n");
	LevelOrderTraverse(T);
	DestroyTree(T);
	scanf("%d",&i);
    return 0;
}

void InitTree(CSTree &T)
{
    T = NULL;
}

bool TreeEmpty(CSTree T)
{
    if(T==NULL)
        return true;
    else
        return false;    
}

char Root(CSTree T)
{
    if(!TreeEmpty(T))
        return T->data;
    else
        return '*';
}

int TreeDepth(CSTree T)
{
	int j;
	CSTree p1;
    if(TreeEmpty(T))
		return 0;
	else
	{
		j=TreeDepth(T->firstchild);
		p1 = T->nextsibling;
		while(p1)
		{
			if(TreeDepth(p1->firstchild)>j)
				j =  TreeDepth(p1->firstchild);
			p1 = p1->nextsibling;
		}
		return j+1;
	}
	
}

void CreateTree(CSTree &T)
{
	int i,l;
    char e,e1[20];
    CSTree p,p1;
    Queue q;
    init_QU(&q);
    printf("请输入根节点:");
    scanf("%c%*c",&e);
    if(!(T=(CSTree)malloc(sizeof(CSNodn))))
        exit(-1);
    T->data = e;
	T->nextsibling = NULL;
    enQU(&q,T);
    while(!empty(&q))
    {
        deQU(&q,p);
		printf("请按长幼顺序输入节点%c的所有孩子:",p->data);
		gets(e1);
		if((l=strlen(e1))>0)
		{
			if(!(p->firstchild = (CSTree)malloc(sizeof(CSNodn))))
			exit(-1);
			p1 = p->firstchild;
			p1->data = e1[0];
			enQU(&q,p1);
			for(i=1;i<l;i++)
			{
				if(!(p1->nextsibling=(CSTree)malloc(sizeof(CSNodn))))
        			exit(-1);
				p1 = p1->nextsibling;
				p1->data = e1[i];
				enQU(&q,p1);
			}
			p1->nextsibling = NULL;
		}
		else
			p->firstchild = NULL;
	}
}

void PreOrderTraverse(CSTree T)
{
	printf("%c ",T->data);
	if(T->firstchild)
		PreOrderTraverse(T->firstchild);
	if(T->nextsibling)
		PreOrderTraverse(T->nextsibling);
}

void PostOrderTraverse(CSTree T)
{
	if(T->firstchild)
		PostOrderTraverse(T->firstchild);
	printf("%c ",T->data);
	if(T->nextsibling)
		PostOrderTraverse(T->nextsibling);
}

void LevelOrderTraverse(CSTree T)
{
	int i=1;
    CSTree p,p1;
    Queue q;
    init_QU(&q);
	printf("S第%d层为:%c",i,T->data);
	i++;
	enQU(&q,T);
	while(!empty(&q))
	{
		deQU(&q,p);
		if((p1=p->firstchild)!=NULL)
		{
			printf("\nS第%d层为:",i);
			i++;
			while(p1)
			{
				printf("%c ",p1->data);
				enQU(&q,p1);
				p1 = p1->nextsibling;
			}
		}
	}
}

CSTree Point(CSTree T,char e)
{
	if(T->data==e)
		return T;
	else
	{
		if(T->firstchild)
			if(Point(T->firstchild,e)!=NULL)
				return Point(T->firstchild,e);
		if(T->nextsibling)
			if(Point(T->nextsibling,e))
				return Point(T->nextsibling,e);
	}
	return NULL;
}

void Assign(char e,CSTree p)
{
	p->data = e;
}

char Parent(CSTree T,char e)
{
	int i,j=1;
    CSTree p,p1;
	if(T->data==e)
		return '*';
    Queue q;
    init_QU(&q);
	enQU(&q,T);
	while(!empty(&q)&&j==1)
	{
		deQU(&q,p);
		if(p->firstchild)
		{
			p1 = p->firstchild;
			enQU(&q,p1);
			while(p1)
			{
				if(p1->data==e)
				{
					j=0;
					break;
				}
				p1 = p1->nextsibling;
				if(p1)
					enQU(&q,p1);
			}
		}
	}
	return p->data;
}

char LeftChild(CSTree T,char e)
{
	if(Point(T,e))
		if(Point(T,e)->firstchild!=NULL)
			return Point(T,e)->firstchild->data;
		else
			return '*';
	else
		return '*';
}

char RightSibling(CSTree T,char e)
{
	if(Point(T,e))
		if(Point(T,e)->nextsibling!=NULL)
			return Point(T,e)->nextsibling->data;
		else
			return '*';
	else
		return '*';
}

void InsertChild(CSTree T,CSTree p,int i,CSTree S)
{
	int j;
	CSTree q,q1;
	if(T)
	{
		if(i==1)
		{
			q = p->firstchild;
			p->firstchild = S;
			S->nextsibling = q;
		}
		else
		{
			q = p->firstchild;
			for(j=1;j<i-1;j++)
			{
				q = q->nextsibling;
			}
			q1 = q->nextsibling;
			q->nextsibling = S;
			S->nextsibling = q1;
		}
	}
	else
		exit(-1);	
}

void DeleteChild(CSTree T,CSTree p,int i)
{
	int j;
	CSTree q,q1;
	if(T)
	{
		if(i==1)
		{
			q = p->firstchild->nextsibling;
			p->firstchild = q;
		}
		else
		{
			q = p->firstchild;
			for(j=1;j<i-1;j++)
			{
				q = q->nextsibling;
			}
			q1 = q->nextsibling->nextsibling;
		    q->nextsibling = q1;
		}
	}
	else
		exit(-1);
}

void DestroyTree(CSTree T)
{
	if(T)
	{
		if(T->firstchild)
			DestroyTree(T->firstchild);
		if(T->nextsibling)
			DestroyTree(T->nextsibling);
		free(T);
		T=NULL;
	}
}

void init_QU(qQueue QU)
{
	qQNode head_Node = (qQNode)malloc(sizeof(QNode));
	if(head_Node == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	QU->front = QU->rear = head_Node;
	head_Node->pNext = NULL;
}
	
void enQU(qQueue QU,CSTree T)
{
	qQNode pNew = (qQNode)malloc(sizeof(QNode));
	if(pNew == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	pNew->QNodedata = T;
	QU->rear->pNext = pNew;
	QU->rear = pNew;
	pNew->pNext = NULL;
}

void deQU(qQueue QU,CSTree &T)
{
	qQNode q = QU->front->pNext;
	if(empty(QU))
		exit(-1);
	QU->front->pNext = q->pNext;
	T = q->QNodedata;
	free(q);
	if(QU->rear == q)
		QU->rear = QU->front;
}

bool empty(qQueue QU)
{
	if(QU->rear == QU->front)
		return true;
	else
		return false;
}

赫夫曼树和赫夫曼编码的存储表示
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#define UINTMAX 1000;

typedef struct 
{
    unsigned int weight;
    unsigned int parent,lchild,rchild;
}HTNode,*HuffmanTree;

typedef char **HuffmanCode;

void HuffmanCoding(HuffmanTree &,HuffmanCode &,int*,int);
void select(HuffmanTree,int,int&,int&);
int min(HuffmanTree,int);

int main()
{
    HuffmanTree HT;
    HuffmanCode HC;
    int *w,n,i;
    printf("请输入权值的个数(>1)");
    scanf("%d",&n);
    w = (int*)malloc(n*sizeof(int));
    printf("请依次输入%d个权值(整型):\n",n);
    for(i=0;i<=n-1;i++)
    {
        scanf("%d",w+i);
    }
    HuffmanCoding(HT,HC,w,n);
    for(i=1;i<=n;i++)
        puts(HC[i]);
    scanf("%d",&i);
    return 0;
}

void HuffmanCoding(HuffmanTree &HT,HuffmanCode &HC,int* w,int n)
{
    int m,i,s1,s2,start;
    unsigned c,f;
    HuffmanTree p;
    char *cd;
    if(n<=1)
        exit(-1);
    m = 2*n-1;      //树根节点和子节点加起来一共有m个
    HT = (HuffmanTree)malloc((m+1)*sizeof(HTNode));
    for(p=HT+1,i=1;i<=n;i++,p++,w++)
    {
        (*p).weight = *w;
        (*p).parent = 0;
        (*p).lchild = 0;
        (*p).rchild = 0;
    }
    for(;i<=m;i++,p++)
        (*p).parent = 0;
    for(i=n+1;i<=m;i++)                 //建立赫夫曼树
    {
        select(HT,i-1,s1,s2);           //s1,s2分别为parent为0且weight最小的两个节点
        HT[s1].parent = HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
    //从叶子到根逆向求每个字符的赫夫曼
    HC = (HuffmanCode)malloc((n+1)*sizeof(char*));
    cd = (char*)malloc(n*sizeof(char));
    cd[n-1] = '\0';      //编码结束符位置
    for(i=1;i<=n;i++)
    {
        start = n-1;    //编码结束符位置
        for(c=i,f=HT[i].parent;f!=0;c=f,f=HT[f].parent)     //这里循环生成前n个子树的权重对应的编码
        {
            if(HT[f].lchild==c)         //判断是左分支还是右分支
                cd[--start] = '0';
            else
                cd[--start] = '1';
            HC[i] = (char*)malloc((n-start)*sizeof(char));  //为第i个字符编码分配空间
            strcpy(HC[i],&cd[start]);                       //从cd复制编码串到HC
        }
    }
    free(cd);     //释放工作空间
}

void select(HuffmanTree t,int i,int &s1,int &s2)
{
    int j;
    s1 = min(t,i);
    s2 = min(t,i);
    if(s1>s2)
    {
        j = s1;
        s1 = s2;
        s2 = j;
    }
}

int min(HuffmanTree t,int i)
{
    int j,flag;
    unsigned int k = UINTMAX;          //这里选取一个肯定大于所有权重的数
    for(j=1;j<=i;j++)
    {
        if(t[j].weight<k&&t[j].parent==0)
            {
                k=t[j].weight;
                flag = j;
            }
    }
    t[flag].parent = 1;                 //这里是找到最小值后做个标记，下次在找的时候就忽略这个最小值，找的为次小值
    return flag;
}

图的数组表示法
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>

#define true 1
#define false 0
#define INFINITY INT_MAX
#define MAX_NAME 5
#define MAX_INFO 20
#define MAX_VERTEX_NUM 20
enum GraphKind{DG,DN,AG,AN};        //{有向图，有向网，无向图，无向网}对应{0,1,2,4}
/*
二者的区别：
　　邻接矩阵（Adjacency Matrix）：是表示顶点之间相邻关系的矩阵。设G=(V,E)是一个图，其中V={v1,v2,…,vn}。
    G的邻接矩阵是一个具有下列性质的n阶方阵：
　　①对无向图而言，邻接矩阵一定是对称的，而且主对角线一定为零（在此仅讨论无向简单图），副对角线不一定为0，
    有向图则不一定如此。
　　②在无向图中，任一顶点i的度为第i列所有元素的和，在有向图中顶点i的出度为第i行所有元素的和，而入度为第i列所有元素的和。
　　③用邻接矩阵法表示图共需要n^2个空间，由于无向图的邻接矩阵一定具有对称关系，所以扣除对角线为零外，
    仅需要存储上三角形或下三角形的数据即可，因此仅需要n（n-1）/2个空间。 
*/

typedef int BOOL;
BOOL visited[MAX_VERTEX_NUM];
typedef int VRType;
typedef char VertexType[MAX_VERTEX_NUM];
typedef char InfoType; 

typedef struct
{
    VRType adj;     //顶点关系类型。对无权图，用1(是)或0(否)表示相邻否；
                    //对带权图，则为权值类型；
    InfoType *info; //该弧相关信息的指针
}ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];

struct MGraph
{
    VertexType vexs[MAX_VERTEX_NUM];    //顶点向量
    AdjMatrix arcs;                     //邻接矩阵
    int vexnum,arcnum;                  //图的当权顶点数和弧数
    GraphKind kind;                     //图的种类标志
};

typedef struct QNode
{
	int data;
	struct QNode *pNext;
}QNode,*qQNode;

typedef struct Queue
{
	qQNode front;
	qQNode rear;
}Queue,*qQueue;

void CreateFAG(MGraph &);
int LocateVex(MGraph,VertexType);
void Display(MGraph);
void PutVex(MGraph &,VertexType,VertexType);    
void DFSTraverse(MGraph);
void DFS(MGraph,int);
void DFSTraverse1(MGraph);
void DFS1(MGraph,int);
int FirstAdjVex(MGraph,VertexType);
int NextAdjVex(MGraph,VertexType,VertexType);
void BFSTraverse(MGraph);
void CreateGraph(MGraph &);
void CreateDG(MGraph &); //构造有向图

void CreateDN(MGraph &); //构造有向网
void CreateAG(MGraph &); //构造无向图
void CreateAN(MGraph &); //构造无向网

void InsertVex(MGraph&,VertexType);             //插入新的顶点
void InsertArc(MGraph&,VertexType,VertexType);  //输入网或图的方向
void DeleteArc(MGraph&,VertexType,VertexType);
void DestroyGraph(MGraph&);
void Deletevex(MGraph&,VertexType);

void init_QU(qQueue);
void enQU(qQueue,int);
void deQU(qQueue,int &);
bool empty(qQueue);

int main()
{
    int i,n,k,j;
    VertexType v1,v2;
    MGraph g;
    CreateFAG(g);
    Display(g);
    printf("修改顶点的值，请输入原值 新值:");
    scanf("%s%s",v1,v2);
    PutVex(g,v1,v2);
    printf("深度优先搜索的结果(非递归):\n");
    DFSTraverse(g);
    printf("\n深度优先搜索的结果(递归):\n");
    DFSTraverse1(g);
    printf("\n广度优先搜索的结果\n");
    BFSTraverse(g);
    printf("删除一条边或弧，请输入待删除边或弧的弧尾 弧头:");
    scanf("%s%s",v1,v2);
    DeleteArc(g,v1,v2);
    Display(g);
    DestroyGraph(g);
    printf("请按顺序选择有向图，有向网，无向图，无向网\n");
    for(i=0;i<4;i++)
    {
        CreateGraph(g);
        Display(g);
        printf("插入新顶点，请输入顶点的值:");
        scanf("%s",v1);
        InsertVex(g,v1);
        printf("插入与新顶点有关的弧或边，请输入弧或边数:");
        scanf("%d",&n);
        for(k=0;k<n;k++)
        {
            printf("请另一顶点的值:");
            scanf("%s",v2);
            if(g.kind<=1)
            {
                printf("对于有向图或网，请输入另一点的方向(0:弧头 1:弧尾):");
                scanf("%d",&j);
                if(j)
                    InsertArc(g,v2,v1);
                else
                    InsertArc(g,v1,v2);
            }
            else
            InsertArc(g,v1,v2);
        }
        Display(g);
        printf("删除顶点及相关的弧或边，请输入顶点的值:");
        scanf("%s",v1);
        Deletevex(g,v1);
		Display(g);
    }   
    scanf("%d",&i);
	return 0;
}

void CreateFAG(MGraph &G)
{
    int i,j,k;
//    char filename[130];
    VertexType va,vb;
    FILE *graphlist;
    printf("请输入数据文件名(f7-1.dat):");
  //  scanf("%s",filename);
    if((graphlist = fopen("D:\\VC++6.0\\VC++6.0\\MyProjects\\数据结构\\图\\图的数组存储表示\\f7-1.txt","a+"))!=NULL)
    {
        fscanf(graphlist,"%d",&G.vexnum);
        fscanf(graphlist,"%d",&G.arcnum);
        for(i=0;i<G.vexnum;i++)
            fscanf(graphlist,"%s",&G.vexs[i]);
        for(i=0;i<G.vexnum;i++)
        {
            for(j=0;j<G.vexnum;j++)
            {
                G.arcs[i][j].adj = 0;
                G.arcs[i][j].info = NULL;
            }
        }
        for(k=0;k<G.arcnum;k++)
        {
            fscanf(graphlist,"%s%s",va,vb);             //空格隔开va和vb
            i = LocateVex(G,va);
            j = LocateVex(G,vb);
            G.arcs[i][j].adj = G.arcs[j][i].adj = 1;    //无向图
        }
        G.kind = AG;
        fclose(graphlist);
    }
	else
		exit(-1);
}

void Display(MGraph G)
{
    int i,j;
    char *s=(char*)malloc(7*sizeof(char)),
		 *s1=(char*)malloc(3*sizeof(char));
    switch(G.kind)
    {
        case DG:strcpy(s,"有向图\0");
                strcpy(s1,"弧\0");
                break;
        case DN:strcpy(s,"有向网\0");
				strcpy(s1,"弧\0");
				break;
		case AG:strcpy(s,"无向图\0");
				strcpy(s1,"边界\0");
				break;
		case AN:strcpy(s,"无向网\0");
				strcpy(s1,"边\0");     
    }
/*
#include<stdio.h>
#include<stdlib.h>

int main(void) {
    char s[]="123456789";
    char d[]="123";

    strcpy(d,s);

    printf("%s,\n%s",d,s);

    return 0;
}
运行输出123456789
       56789
这里涉及到内存覆盖问题d,s内存段为strcpy()运行前为d 123\000,s 123456789\000
运行strcpy()后d 1234,s 56789\000
这里最好的办法是分配动态内存
char *s=(char*)malloc(7*sizeof(char)),
	 *s1=(char*)malloc(3*sizeof(char));
*/
    printf("\n%d个顶点%d条%s的%s\n",G.vexnum,G.arcnum,s1,s);
    for(i=0;i<G.vexnum;i++)
    {
        printf("G.vexs[%d]=%s\n",i,G.vexs[i]);
    }
    printf("G.arcs.adj:\n");
    for(i=0;i<G.vexnum;i++)
    {
        for(j=0;j<G.vexnum;j++)
        {
            printf("%d ",G.arcs[i][j].adj);
        }
        printf("\n");
    }
    printf("G.arcs.info:\n");       //输出G.arcs.info
    printf("顶点1(弧尾) 顶点2(弧头) 该%s信息:\n",s1);
    if(G.kind<2)					//有向图
    {
		for(i=0;i<G.vexnum;i++)
        {
            for(j=0;j<G.vexnum;j++)
            {
                if(G.arcs[i][j].info)
                printf("%5s %11s      %s\n",G.vexs[i],G.vexs[j],G.arcs[i][j].info);
            }
        }
	}	
    else								//无向图
    {
        for(i=0;i<G.vexnum;i++)
        {
            for(j=i+1;j<G.vexnum;j++)	//无向图j=i+1可以减少遍历重复项
            {
                if(G.arcs[i][j].info)
                printf("%5s %11s      %s\n",G.vexs[i],G.vexs[j],G.arcs[i][j].info);
            }
        }
    }
}

int LocateVex(MGraph G,VertexType u)
{
    int i;
    for(i=0;i<G.vexnum;i++)
    {
        if(strcmp(u,G.vexs[i])==0)
            return i;
    }
    return -1;
}

void PutVex(MGraph &G,VertexType v1,VertexType v2)
{
    int i;
    for(i=0;i<G.vexnum;i++)
    {
        if(strcmp(G.vexs[i],v1)==0)
        {
            strcpy(G.vexs[i],v2);
            break;
        }
    }
}

void DFSTraverse(MGraph G)
{
    int i;
    for(i=0;i<G.vexnum;i++)
    {
        visited[i] = false;
    }
    printf("%s ",G.vexs[0]);
    visited[0] = true;
    for(i=0;i<G.vexnum-1;i++)
    {
            DFS(G,i);
    }
}

void DFS(MGraph G,int i)
{
    int j;
    for(j=0;j<G.vexnum;j++)
    {
        if(G.arcs[i][j].adj==1 && visited[j]==false)
        break;
    }
    visited[j] = true;
    printf("%s ",G.vexs[j]);
}

void DFSTraverse1(MGraph G)
{
    int i;
    for(i=0;i<G.vexnum;i++)
    {
        visited[i] = false;
    }
    for(i=0;i<G.vexnum;i++)
    {
        if(visited[i]==false)
            DFS1(G,i);
    }
}

void DFS1(MGraph G,int i)
{
    int w;
//    char *w2;
    VertexType v1,w1;
    visited[i] = true;
    printf("%s ",G.vexs[i]);
    strcpy(v1,G.vexs[i]);
    for(w=FirstAdjVex(G,v1);w>=0;w=NextAdjVex(G,v1,strcpy(w1,G.vexs[w])))     //这里的返回值是地址地址 VertexType是char型数组 首地址也是地址
    {
/*
w=FirstAdjVex(G,v1)是找到对应的第一个adj==1的情况
w=NextAdjVex(G,v1,strcpy(w1,GetVex(G,w)))是找到这一行下一个对应adj==1的情况 这里的v1对应的是行，strcpy(w1,GetVex(G,w))对应的是列
*/
        if(!visited[w])
            DFS1(G,w);
    }
}
/*
strcpy()函数
char * __cdecl strcpy(char * dst, const char * src)
{
        char * cp = dst;
        while( *cp++ = *src++ )
                ;               // Copy src over dst 
        return( dst );
} 
返回值是复制字符串的地址
*/

void BFSTraverse(MGraph G)
{
    int v,u,w;
    VertexType w1,u1;
    Queue Q;
    for(v=0;v<G.vexnum;v++)
    {
        visited[v] = 0;
    }
    init_QU(&Q);
    for(v=0;v<G.vexnum;v++)
    {
        if(!visited[v])
        {
            visited[v] = true;
            printf("%s ",G.vexs[v]);
            enQU(&Q,v);
            while(!empty(&Q))
            {
                deQU(&Q,u);
                strcpy(u1,G.vexs[u]);
                for(w=FirstAdjVex(G,u1);w>=0;w=NextAdjVex(G,u1,strcpy(w1,G.vexs[w])))
                {
                    if(!visited[w])
                    {
                        visited[w] = true;
                        printf("%s ",G.vexs[w]);
                        enQU(&Q,w);
                    }
                }
            }
        }
    }
    printf("\n");
}

int FirstAdjVex(MGraph G,VertexType v)  //用来找下一个顶点的首个adj==1的量
{
    int i,j=0,k;
    k = LocateVex(G,v);
    if(G.kind==DN || G.kind==AN)        //网
        j = INFINITY;
    for(i=0;i<G.vexnum;i++)
    {
        if(G.arcs[k][i].adj==1)
 //           if(visited[i]==false)
                return i;
    }
    return -1;
}

int NextAdjVex(MGraph G,VertexType v1,VertexType w)
{
    int i,j=0,k1,k2;
    k1 = LocateVex(G,v1);       //k1为顶点所在位置  对应行
    k2 = LocateVex(G,w);        //k2为顶点所在位置  对应列
    if(G.kind==DN || G.kind==AN)
        j = INFINITY;
    for(i=k2+1;i<G.vexnum;i++)
        if(G.arcs[k1][i].adj!=j)
            return i;
    return -1;
}

void DeleteArc(MGraph& G,VertexType v1,VertexType v2)
{
    int i,j;
    i = LocateVex(G,v1);     //尾
    j = LocateVex(G,v2);     //头
    if(i<0||j<0)
        exit(-1);
    if(G.kind%2==0)
        G.arcs[i][j].adj = 0;
    else
        G.arcs[i][j].adj = INFINITY;
    if(G.arcs[i][j].info)    //有向的是以行为尾巴，列为头
    {
        free(G.arcs[i][j].info);
        G.arcs[i][j].info = NULL;
    }
    if(G.kind>=2)           //无向，删除对称弧
    {
        G.arcs[j][i].adj = G.arcs[i][j].adj;
        G.arcs[j][i].info = NULL;
    }
    G.arcnum--;
}

void DestroyGraph(MGraph& G)
{
    int i,j;
    if(G.kind<2)
        for(i=0;i<G.vexnum;i++)
            for(j=0;j<G.vexnum;j++)
                if(G.kind==0&&G.arcs[i][j].adj==1||G.kind==1&&G.arcs[i][j].adj!=INFINITY)   //有向图的弧||有向网的弧
                    if(G.arcs[i][j].info)
                    {
                        free(G.arcs[i][j].info);
                        G.arcs[i][j].info = NULL;
                    }
    else
        for(i=0;i<G.vexnum;i++)
            for(j=i+1;j<G.vexnum;j++)
            {
                if(G.arcs[i][j].adj==1&&G.kind==2||G.arcs[i][j].adj!=INFINITY&&G.kind==3)       //无向图的边||无向网的边
                    if(G.arcs[i][j].info)
                    {
                        free(G.arcs[i][j].info);
                        G.arcs[i][j].info = G.arcs[i][j].info = NULL;
                    }
            }
    G.vexnum = 0;
    G.arcnum = 0;
}

void CreateGraph(MGraph &G)
{
    printf("请输入图G的类型(有向图:0,有向网:1,无向图:2,无向网:3)");
    scanf("%d",&G.kind);
    switch(G.kind)
    {
        case DG:CreateDG(G); //构造有向图
			 break;
        case DN:CreateDN(G); //构造有向网
			 break;
		case AG:CreateAG(G); //构造无向图
			 break;
        case AN:CreateAN(G); //构造无向网
			 break;
    }
}

void CreateDG(MGraph &G)
{
    int i,j,k,l,IncInfo;
    char s[MAX_INFO],*info;
    VertexType va,vb;
    printf("请输入有向图G的顶点数,弧数,弧是否有其他信息(是:1 否:0):");
    scanf("%d,%d,%d",&G.vexnum,&G.arcnum,&IncInfo);
    printf("请输入%d个顶点的值(%d个字符):\n",G.vexnum,MAX_NAME);
    for(i=0;i<G.vexnum;i++)
    {
        scanf("%s",G.vexs[i]);
    }
    for(i=0;i<G.vexnum;i++)
    {
        for(j=0;j<G.vexnum;j++)
        {
            G.arcs[i][j].adj = 0;       //图
            G.arcs[i][j].info = NULL;
        }
    }
    printf("请输入%d条弧的弧尾 弧头(以空格作为间隔):\n",G.arcnum);
    for(k=0;k<G.arcnum;k++)
    {
        scanf("%s%s%*c",va,vb);
        i = LocateVex(G,va);
        j = LocateVex(G,vb);
        G.arcs[i][j].adj = 1;
        if(IncInfo)
        {
            printf("请输入该弧的相关信息(%d个字符):",MAX_INFO);
            gets(s);
            l = strlen(s);
            if(l)
            {
                info =  (char*)malloc((l+1)*sizeof(char));
                strcpy(info,s);
                G.arcs[i][j].info = info;
            }
        }
    }
    G.kind = DG;
}

void CreateAG(MGraph &G)
{
	int i,j,l,IncInfo;
	char s[MAX_INFO],*info;
	VertexType va,vb;
	printf("请输入无向图G的顶点,边数,边是否含其他信息(是:1,否:0)");
	scanf("%d,%d,%d",&G.vexnum,&G.arcnum,&IncInfo);
	printf("请输入%d个顶点的值(%d个字符):\n",G.vexnum,MAX_NAME);
	for(i=0;i<G.vexnum;i++)
	{
		scanf("%s",G.vexs[i]);
	}
	for(i=0;i<G.vexnum;i++)
	{
		for(j=0;j<G.vexnum;j++)
		{
			G.arcs[i][j].adj = 0;
			G.arcs[i][j].info = NULL;
		}
	}
	printf("请输入%d条弧的弧尾 弧头(以空格作为间隔):\n",G.arcnum);
	for(i=0;i<G.arcnum;i++)
	{
		scanf("%s%s%*c",va,vb);
		i = LocateVex(G,va);
        j = LocateVex(G,vb);
		G.arcs[i][j].adj = 1;
		G.arcs[j][i].adj = 1;
		if(IncInfo)
		{
			printf("请输入该弧的相关信息(%d个字符):",MAX_INFO);
			gets(s);
			l = strlen(s);
			if(l)
			{
				info = (char*)malloc(sizeof(char)*(l+1));
				strcpy(info,s);
				G.arcs[i][j].info = info;
			}
		}
	}
	G.kind = AG;
}

void CreateDN(MGraph &G)
{
	int i,j,l,w,IncInfo;
	char s[MAX_INFO],*info;
	VertexType va,vb;
	printf("请输入无向图G的顶点,边数,边是否含其他信息(是:1,否:0)");
	scanf("%d,%d,%d",&G.vexnum,&G.arcnum,&IncInfo);
	printf("请输入%d个顶点的值(%d个字符):\n",G.vexnum,MAX_NAME);
	for(i=0;i<G.vexnum;i++)
	{
		scanf("%s",G.vexs[i]);
	}
	for(i=0;i<G.vexnum;i++)
    {
        for(j=0;j<G.vexnum;j++)
        {
            G.arcs[i][j].adj = INFINITY;       //网	
            G.arcs[i][j].info = NULL;
        }
    }
	printf("请输入%d条弧的弧尾 弧头(以空格作为间隔):\n",G.arcnum);
	for(i=0;i<G.arcnum;i++)
	{
		scanf("%s%s%d%*c",va,vb,&w);
		i = LocateVex(G,va);
        j = LocateVex(G,vb);
		G.arcs[i][j].adj = w;
		if(IncInfo)
		{
			printf("请输入该弧的相关信息(%d个字符):",MAX_INFO);
			gets(s);
			l = strlen(s);
			if(l)
			{
				info = (char*)malloc(sizeof(char)*(l+1));
				strcpy(info,s);
				G.arcs[i][j].info = info;
			}
		}
	}
	G.kind = DN;
}

void CreateAN(MGraph &G)
{
	int i,j,l,w,IncInfo;
	char s[MAX_INFO],*info;
	VertexType va,vb;
	printf("请输入无向图G的顶点,边数,边是否含其他信息(是:1,否:0)");
	scanf("%d,%d,%d",&G.vexnum,&G.arcnum,&IncInfo);
	printf("请输入%d个顶点的值(%d个字符):\n",G.vexnum,MAX_NAME);
	for(i=0;i<G.vexnum;i++)
	{
		scanf("%s",G.vexs[i]);
	}
	for(i=0;i<G.vexnum;i++)
    {
        for(j=0;j<G.vexnum;j++)
        {
            G.arcs[i][j].adj = INFINITY;       //网	
            G.arcs[i][j].info = NULL;
        }
    }
	printf("请输入%d条弧的弧尾 弧头(以空格作为间隔):\n",G.arcnum);
	for(i=0;i<G.arcnum;i++)
	{
		scanf("%s%s%d%*c",va,vb,&w);
		i = LocateVex(G,va);
        j = LocateVex(G,vb);
		G.arcs[i][j].adj = w;
		G.arcs[j][i].adj = w;
		if(IncInfo)
		{
			printf("请输入该弧的相关信息(%d个字符):",MAX_INFO);
			gets(s);
			l = strlen(s);
			if(l)
			{
				info = (char*)malloc(sizeof(char)*(l+1));
				strcpy(info,s);
				G.arcs[i][j].info = info;
			}
		}
	}
	G.kind = AG;
}

void InsertVex(MGraph &G,VertexType v)
{
    int i;
    strcpy(G.vexs[G.vexnum],v);
    for(i=0;i<=G.vexnum;i++)
    {
        if(G.kind%2)    //网
        {
            G.arcs[G.vexnum][i].adj = INFINITY;
            G.arcs[i][G.vexnum].adj = INFINITY;
        }
        else
        {
            G.arcs[G.vexnum][i].adj = 0;
            G.arcs[i][G.vexnum].adj = 0;
        }
        G.arcs[G.vexnum][i].info = NULL;
        G.arcs[i][G.vexnum].info = NULL;
    }
    G.vexnum++;
}

void InsertArc(MGraph &G,VertexType v1,VertexType v2)
{
    int i,j,l;
    char *info,s[MAX_INFO];
    i = LocateVex(G,v1);
    j = LocateVex(G,v2);
    if(i<0||j<0)
        exit(-1);
    G.arcnum++;
    if(G.kind%2)
    {
        printf("请输入此弧或边的权值:");
        scanf("%d",G.arcs[i][j].adj);
    }
    else
        G.arcs[i][j].adj = 1;
    printf("是否有该弧或边的相关信息(0:无 1:有):");
    scanf("%d%*c",&i);
    if(i)
    {
        printf("请输入该弧或边的相关信息(%d个字符):",MAX_INFO);
        gets(s);
        l = strlen(s);
        if(l)
        {
            info = (char*)malloc(sizeof(char)*(l+1));
            strcpy(info,s);
            G.arcs[i][j].info = info;
        }
    }
    if(G.kind>1)    //无向
    {
        G.arcs[i][j].adj = G.arcs[i][j].adj;
        G.arcs[i][j].info = G.arcs[i][j].info;      //指向同一个相关信息
    }
}

void Deletevex(MGraph& G,VertexType v1)
{
    int i,j;
    j = LocateVex(G,v1);
    if(G.kind%2)
    {
        for(i=0;i<G.vexnum;i++)
        {
            if(G.arcs[j][i].adj != INFINITY)
            {
                G.arcnum--;
                G.arcs[j][i].adj = INFINITY;
                free(G.arcs[j][i].info);
                G.arcs[j][i].info = NULL;
            }
            if(G.kind>1)
            {
                G.arcs[i][j].adj = INFINITY;
                free(G.arcs[j][i].info);
                G.arcs[j][i].info = NULL;
            }
            else
            {
                if(G.arcs[i][j].adj != INFINITY)
                {
                    G.arcnum--;
                    G.arcs[i][j].adj = INFINITY;
                    free(G.arcs[i][j].info);
                    G.arcs[i][j].info = NULL;
                }
            }
        }
    }
    else
    {
        for(i=0;i<G.vexnum;i++)
        {
            if(G.arcs[j][i].adj == 1)
            {
                G.arcnum--;
                G.arcs[j][i].adj = 0;
                G.arcs[j][i].info = NULL;
            }
            if(G.kind>1)
            {
                G.arcs[i][j].adj = 0;
                G.arcs[j][i].info = NULL;
             }
            else
            {
                if(G.arcs[i][j].adj == 1)
                {
                    G.arcnum--;
                    G.arcs[i][j].adj = 0;
                    G.arcs[i][j].info = 0;
                }
            }
        }
    }
    G.vexnum--;
}

void init_QU(qQueue QU)
{
	qQNode head_Node = (qQNode)malloc(sizeof(QNode));
	if(head_Node == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	QU->front = QU->rear = head_Node;
	head_Node->pNext = NULL;
}
	
void enQU(qQueue QU,int T)
{
	qQNode pNew = (qQNode)malloc(sizeof(QNode));
	if(pNew == NULL)
	{
		printf("内存分配失败!\n");
		exit(-1);
	}
	pNew->data = T;
	QU->rear->pNext = pNew;
	QU->rear = pNew;
	pNew->pNext = NULL;
}

void deQU(qQueue QU,int &T)
{
	qQNode q = QU->front->pNext;
	if(empty(QU))
		exit(-1);
	QU->front->pNext = q->pNext;
	T = q->data;
	free(q);
	if(QU->rear == q)
		QU->rear = QU->front;
}

bool empty(qQueue QU)
{
	if(QU->rear == QU->front)
		return true;
	else
		return false;
}